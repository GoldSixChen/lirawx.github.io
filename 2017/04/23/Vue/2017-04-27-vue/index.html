<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="let life = undefined;">
  <meta name="keyword" content="just coding.">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      vue全面介绍--全家桶（vue笔记一） | DVRAW.
    
  </title>
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/gitment.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>
  <script src="/js/qrious.js"></script>
<script src="/js/gitment.js"></script>
</head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>DVRAW.</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">Projects</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">Projects</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>vue全面介绍--全家桶（vue笔记一）</h2>
  <p class="post-date">2017-04-23</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body">
  <article class="post-article">
    <section class="markdown-content"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>  “简单却不失优雅，小巧而不乏大匠”。<br>Vue.js 是一个JavaScriptMVVM库，是一套构建用户界面的渐进式框架。它是以数据驱动和组件化的思想构建的，采用自底向上增量开发的设计。相比于Angular.js，Vue.js提供了更加简洁、更易于理解的API，使得我们能够快速地上手并使用Vue.js；同时比起 React + Redux 相对复杂的架构，Vue.js 更加轻量级也更加容易上手，是初创项目的首选前端框架。Vue 的核心库只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。并且作者是华人的关系，Vue拥有着对华人开发者最友好的api文档和官方教程。<br><a id="more"></a></p>
<h2 id="vue、React、Angular1对比"><a href="#vue、React、Angular1对比" class="headerlink" title="vue、React、Angular1对比"></a>vue、React、Angular1对比</h2><p>在Angular1中，在scope作用域中每一次数据变化，会触发watcher的重新计算，angular对常用的dom事件，xhr事件等做了封装， 在里面触发进入angular的digest流程。在digest流程里面，会从rootscope开始遍历， 检查所有的watcher。并且，如果一些 watcher 触发另一个更新，脏检查循环（digest cycle）可能要运行多次。Vue则没有这个问题，因为它使用基于依赖追踪的观察系统并且异步队列更新，数据的变化都是独立处罚的，除非数据之间有明确的依赖关系。<br>vue官方宣称vue的渲染性能优于react。为了有理有据让人信服，vue开发团队建立了一个简单的对比性能的项目（<a href="https://github.com/chrisvfritz/vue-render-performance-comparisons），它负责渲染10000个列表项100次。Vue官方将每一个参照项目都分别运行" target="_blank" rel="external">https://github.com/chrisvfritz/vue-render-performance-comparisons），它负责渲染10000个列表项100次。Vue官方将每一个参照项目都分别运行</a> 20 次并取最好的结果结果如下图：<br><img src="http://img.blog.csdn.net/20170328173227286?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhlbmdoYW8zNTc5MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>由此可见，Vue的性能是远好于Angular1，并且稍微优于React的。</p>
<h2 id="社区拓展对比"><a href="#社区拓展对比" class="headerlink" title="社区拓展对比"></a>社区拓展对比</h2><p>Angular1的背后是Google，所以社区基础是不需要担心的，从Tutorial到StackOverflow的问题数量都可以反映出生态系统很完整。Vue和React都有强大的社区支持。React有状态管理库Flux、ReduxVue，相应的，Vue有vuex。Vue 和 React 都提供了强大的路由库来应对大型应用。然而Vue的路由库和状态管理库都是由官方维护支持的。React 则是选择把这些问题交给社区维护，因此创建了一个更分散的生态系统。但相对的，React 的生态系统相比 Vue 更加繁荣。此外，Vue 提供了Vue-cli 脚手架，包括了Webpack，Browserify，甚至路由库，能让你非常容易地构建项目。</p>
<h2 id="学习陡峭度对比"><a href="#学习陡峭度对比" class="headerlink" title="学习陡峭度对比"></a>学习陡峭度对比</h2><p>在指令与组件方面，Vue中将指令和组件分得更清晰。指令只封装 DOM 操作，而组件代表一个自给自足的独立单元，有自己的视图和数据逻辑。在 Angular1 中两者有不少相混的地方。在API与框架设计方面，angular1都比vue要复杂的多。就个人感觉而言，angular1和React的学习曲线会相对陡峭一些，而vue的编码方式会更趋近于前端开发者的编程习惯。<br>因为vue的作者是中国人，vue的官方网站、教程和api肯定是最完善、最易懂的。此外，每次大版本的发布，都会伴随着详尽的迁移说明文档，包含了很多详尽的阐述以及许多迁移的例子，甚至还有迁移工具。</p>
<h2 id="vue的缺点"><a href="#vue的缺点" class="headerlink" title="vue的缺点"></a>vue的缺点</h2><p>Vue就这么好，难道没有缺点吗？当然有，vue虽然在16年非常火爆，但是相比于angular和react，不论是成熟度还是社区活跃度都还不是对手。此外，Vue明确声明了自己放弃了对IE8的支持。再看看现在的招聘网站上，有多少写了需要有angular经验，而又有多少写了需要vue经验，就可见vue的影响力相比于angular和react还差的很远。</p>
<h2 id="vue全家桶及项目架构"><a href="#vue全家桶及项目架构" class="headerlink" title="vue全家桶及项目架构"></a>vue全家桶及项目架构</h2><p>Vue有著名的全家桶系列，包含了vue-router（<a href="http://router.vuejs.org），vuex（http://vuex.vuejs.org），" target="_blank" rel="external">http://router.vuejs.org），vuex（http://vuex.vuejs.org），</a> vue-resource（<a href="https://github.com/pagekit/vue-resource）。再加上构建工具vue-cli，就是一个完整的vue项目的核心构成。" target="_blank" rel="external">https://github.com/pagekit/vue-resource）。再加上构建工具vue-cli，就是一个完整的vue项目的核心构成。</a></p>
<h3 id="vue-router路由"><a href="#vue-router路由" class="headerlink" title="vue-router路由"></a>vue-router路由</h3><p>推荐使用npm工具来安装vue-router<br>npm install vue-router<br>通过import导入并定义Vue模块、vue-router模块和需要使用的组件，在本例中，分别是Goods、Ratings和Seller组件。最后，如果在一个模块化工程中使用它，必须要通过 Vue.use() 明确地安装路由功能。<br>import Vue from’vue’<br>importRouter from’vue-router’</p>
<p>import Goods from ‘@/components/goods/goods’;<br>import Ratings from ‘@/components/ratings/ratings’;<br>import Seller from ‘@/components/seller/seller’;</p>
<p>Vue.use(Router); // 需要import Vue和Router，不然会报错undefined<br>通过const router= new VueRouter（）来定义一个路由，并传入对应的配置，包括路径path和组件components。</p>
<h3 id="vuex状态管理"><a href="#vuex状态管理" class="headerlink" title="vuex状态管理"></a>vuex状态管理</h3><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。如前面所提到的，Vuex 已经集成到 Vue 的官方调试工具vue Devtools，可以轻松的查看项目中的Vuex状态变化情况。<br>假设有这样一个场景：我们的项目规模比较大，有多个父组件，每个父组件同时又包含多个子组件。如何保持对所有时间的追踪将变得很困难。到底哪个事件是哪个组件派发的，哪个组件该监听哪个事件？父组件将变得和子组件耦合越来越严重，因为它需要明确的派发和监听子组件的某些事件。项目逻辑分散在各个组件当中，很容易导致逻辑的混乱，不利于我们项目的维护。<br>这就是 Vuex 用来解决的问题。 Vuex 的四个核心概念分别是：<br>The state tree：Vuex 使用单一状态树，用一个对象就包含了全部的应用层级状态。至此它便作为一个『唯一数据源(SSOT)』而存在。这也意味着，每个应用将仅仅包含一个 store 实例。单状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。<br>Getters：用来从 store 获取 Vue 组件数据。<br>Mutators：事件处理器用来驱动状态的变化。<br>Actions：可以给组件使用的函数，以此用来驱动事件处理器 mutations<br>Vuex和简单的全局对象是不同的，当Vuex从store中读取状态值的时候，若状态发生了变化，那么相应的组件也会高效的更新。并且，改变store中状态的唯一途径就是提交commit mutations。这样便于我们跟踪每一次状态的变化。只要发生了状态的变化，一定伴随着mutation的提交。</p>
<h3 id="vue-resource介绍"><a href="#vue-resource介绍" class="headerlink" title="vue-resource介绍"></a>vue-resource介绍</h3><p>Vue-resource有体积小，支持IE9以上的浏览器，支持promise特性的特点。同样推荐使用npm来安装Vue-resource。<br>$ npm install vue-resource<br>在安装并引入vue-resource后，可以基于全局的Vue对象使用http，也可以基于某个Vue实例使用http。<br>在发送请求后，使用then方法来处理响应结果，then方法有两个参数，第一个参数是响应成功时的回调函数，第二个参数是响应失败时的回调函数。<br>vue-resource的请求API是按照REST风格设计的，它提供了7种请求API：<br>· get(url,[options])<br>· head(url,[options])<br>· delete(url,[options])<br>· jsonp(url,[options])<br>· post(url,[body], [options])<br>· put(url, [body],[options])<br>· patch(url,[body], [options])</p>
<h3 id="vue工程目录结构"><a href="#vue工程目录结构" class="headerlink" title="vue工程目录结构"></a>vue工程目录结构</h3><p><img src="http://img.blog.csdn.net/20170328173526370?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhlbmdoYW8zNTc5MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>components/文件夹用来存放Vue 组件。个人建议，把每一个组件中使用到的image图片放置到对应的组件子文件目录下，便于统一的管理<br>Node_modules/npm安装的该项目的依赖库<br>vuex/文件夹存放的是和 Vuex store 相关的东西（state对象，actions，mutations)<br>router/文件夹存放的是跟vue-router相关的路由配置项<br>build/文件是 webpack 的打包编译配置文件<br>static/文件夹存放一些静态的、较少变动的image或者css文件<br>config/文件夹存放的是一些配置项，比如服务器访问的端口配置等<br>dist/该文件夹一开始是不存在，在我们的项目经过 build 之后才会产出<br>App.vue根组件，所有的子组件都将在这里被引用<br>index.html整个项目的入口文件，将会引用我们的根组件 App.vue<br>main.js入口文件的 js 逻辑，在webpack 打包之后将被注入到 index.html 中</p>
<h2 id="Vue核心功能"><a href="#Vue核心功能" class="headerlink" title="Vue核心功能"></a>Vue核心功能</h2><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p>假设有如下的购物车结算场景，用户选中商品的总金额是根据商品数量、选中商品种类数<br>和商品单价来变化的。然而，数量、选中种类数量和单价这几个对象都是根据用户选择而动态变化的，如果在前端模版中为了计算最终商品总额，放入这几个动态变化的变量（商品数量、商品单价、选中商品种类），会让这个逻辑变得复杂难以维护。在这种情况下，模版便不再简洁清晰。Vue给出了此种场景的解决方案，在任何复杂的逻辑，vue都推荐使用计算属性。</p>
<h4 id="computed-vs-method"><a href="#computed-vs-method" class="headerlink" title="computed vs method"></a>computed vs method</h4><p>也许会有疑问，这个计算属性和定义一个method方法不是差不多么？这两者最大的区别是计算属性是基于它的依赖进行缓存的。计算属性只有在它的相关依赖发生变化时才会重新计算求值。在本例中，只有当选择商品的价格price和数量count发生变化时，这个计算属性totalPrice才会重新计算新的值。这就意味着，只要totalPrice这个值没有发生变化，多次访问该计算属性会立即返回之前的计算结果，而不必再次执行计算。</p>
<h3 id="模版语法"><a href="#模版语法" class="headerlink" title="模版语法"></a>模版语法</h3><p>Vue.js 使用了基于 HTML 的模版语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模板都是合法的 HTML ，所以能被遵循规范的浏览器和 HTML 解析器解析。Vue的模版语法包括了使用双大括号插入文本、使用v-html插入纯HTML内容、使用v-bind插入对象、类似angular的v-if、v-show、v-for指令、以及过滤器等等。</p>
<h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><p>组件（Component）是 Vue.js 最强大的功能。组件可以封装可重用的代码，通过传入对象的不同，实现组件的复用。<br>举一个简单的组建例子，我们首先编写一个star组件，它就是一个普通的star.vue文件。它的作用就是简单实现了一个五角星。<br>如何在其他的vue文件中使用这个star组件呢？如下图所示，首先通过import引入star组件对象，并在想使用star组件的vue文件中声明注册star组件。现在就可以愉快的通过标签来在该vue文件中任意地方使用star组件了。在你想展示一个五角星的地方，使用一个star标签，就可以轻松完成这个功能。<br>组件实例的作用域是孤立的。这意味着不能在子组件的模板内直接引用父组件的数据。要让子组件使用父组件的数据，我们需要通过子组件的props选项。如本例所示，子组件star要显式的使用props选项声明它期待获得的数据。在这里就是指的“size”和“score”两个变量。我们可以通过父级给子组件star传入大小和数值这两个对象，来实现对子组件的定制化。</p>
<h3 id="过渡效果"><a href="#过渡效果" class="headerlink" title="过渡效果"></a>过渡效果</h3><p>Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果，可以用简单的几行代码实现酷炫的过渡效果。Vue 提供了 transition 的封装组件，在使用v-if、v-show等方法使得transition内部dom元素发生变化时，可以给任何元素和组件添加 entering/leaving 过渡。<br>当v-show中内容发生变化时，transition组件中的元素会发生状态的改变，在应用了transition封装后，Vue会自动识别目标元素是否应用了CSS过渡效果动画，如果有，会在合适的时机添加 entering/leaving的class来实现该过渡效果。<br>下图所示是一个简单的过渡效果的例子，需要将想实现过渡效果的元素放在transition标签中包裹，通过name=“slide-fade”来声明过渡效果名称，并在对应的vue文件中添加过渡效果<br>的css样式，这样就可以简单的完成该元素的过渡效果。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>根据不完全统计，包括饿了么、稀土掘金、苏宁易购、美团、天猫、荔枝FM、房多多、Laravel、htmlBurger等国内外知名大公司都在使用vue进行新项目的开发和旧项目的前端重构工作。<br>此外，vue + vuex+ vue-resource + vue-router + webpack + es6 + less的项目架构成为了越来越多大公司的第一选择。</p>
</section>
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#vue" >
    <span class="tag-code">vue</span>
  </a>

      </div>
    
    <!--
    <div class="money-like">
      <div class="reward-btn">
        赏
        <span class="money-code">
          <span class="alipay-code">
            <div class="code-image"></div>
            <b>使用支付宝打赏</b>
          </span>
          <span class="wechat-code">
            <div class="code-image"></div>
            <b>使用微信打赏</b>
          </span>
        </span>
      </div>
      <p class="notice">若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏</p>
    </div>
     -->
    <div class="qrcode">
      <canvas id="share-qrcode"></canvas>
      <p class="notice">扫描二维码，分享此文章</p>
    </div>
    
      <div id="comments"></div>
    
  </article>
</main>

<script>
  (function () {
    var url = 'https://lirawx.me/2017/04/23/Vue/2017-04-27-vue/';
    var banner = 'undefined'
    if (banner !== 'undefined') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

     // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      var imageW = $(this).width()
      var imageH = $(this).height()

      var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
      zoom = zoom < 1 ? 1 : zoom
      zoom = zoom > 2 ? 2 : zoom
      var transY = (($(window).height() - imageH) / 2).toFixed(2)

      $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
      $('.image-view-wrap').addClass('wrap-active')
      $('.image-view-wrap img').css({
        'width': `${imageW}`,
        'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
      })
      $('html').css('overflow', 'hidden')

      $('.image-view-wrap').on('click', function() {
        $(this).remove()
        $('html').attr('style', '')
      })
    })

    // qrcode
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });

    // gitment
    var gitmentConfig = "lirawx";
    if (gitmentConfig != "undefined") {
      var gitment = new Gitment({
        id: "vue全面介绍--全家桶（vue笔记一）",
        owner: "lirawx",
        repo: "blog",
        oauth: {
          client_id: "fbf58e21712e09b5f132",
          client_secret: "ef1956862ff59fd6674c89519b74ee6d934b9b56"
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  })();
</script>

    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2017 lirawx. <br> Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    |
    Theme by <a href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine == 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->

<script>
    var _baId = '9d96dd222ca2ed3fec333e0f5fa70590';
    // Originial
    var _hmt = _hmt || [];
    (function() {
        var hm = document.createElement("script");
        hm.src = "//hm.baidu.com/hm.js?" + _baId;
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>


<!-- GA part-->

<script>
  var UID = 'UA-80549073-1';
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', UID, 'auto');
  ga('send', 'pageview');

</script>


<script src="/js/script.js"></script>

  </body>
</html>