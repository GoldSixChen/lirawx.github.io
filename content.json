[{"title":"webpack 4 基本配置","date":"2018-03-16T10:01:22.000Z","path":"2018/03/2018-03-16.html","text":"核心概念入口(entry)webpack.config.js 可以通过在 webpack 配置中配置 entry 属性，来指定一个入口起点（或多个入口起点）module.exports = &#123; entry: './path/to/my/entry/file.js'&#125;; 输出(output)output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件。你可以通过在配置中指定一个 output 字段，来配置这些处理过程 const path = require('path');module.exports = &#123; entry: './path/to/my/entry/file.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'my-first-webpack.bundle.js' &#125;&#125;; loaderloader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。 test 属性，用于标识出应该被对应的 loader 进行转换的某个或某些文件。use 属性，表示进行转换时，应该使用哪个 loader。 .css 文件 // css 加载 先加载css-loader ,之后sytle-loader 插入html. &#123; test: /\\.css$/, // test: /\\.less$/, // test: /\\.scss$/, use: [ &#123; loader: \"style-loader\"&#125;, &#123; loader: \"css-loader\"&#125;, // &#123; loader: \"less-loader\"&#125;, // &#123; loader: \"less-loader\"&#125;, ] &#125; .js 文件 ，一般要es6 转 es5 // ES6 转码 &#123; test: /\\.js$/, exclude: /(node_modules|bower_components)/, use: &#123; loader: 'babel-loader', options: &#123; presets: ['@babel/preset-react'] &#125; &#125; &#125; .png | .gif 等图片处理 // 图片加载 &#123; test: /\\.(png|jpg|gif)$/, use: [ &#123; loader: \"file-loader\", options: &#123;&#125; &#125; ] &#125; 插件(plugins)loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。 想要使用一个插件，你只需要 require() 它，然后把它添加到 plugins 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建它的一个实例。 常用插件 ExtractTextWebpackPlugin 它会将所有的入口 chunk(entry chunks)中引用的 *.css，移动到独立分离的 CSS 文件。因此，你的样式将不再内嵌到 JS bundle 中，而是会放到一个单独的 CSS 文件（即 styles.css）当中。 如果你的样式文件大小较大，这会做更快提前加载，因为 CSS bundle 会跟 JS bundle 并行加载。 const ExtractTextPlugin = require(\"extract-text-webpack-plugin\");module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.css$/, use: ExtractTextPlugin.extract(&#123; fallback: \"style-loader\", use: \"css-loader\" &#125;) &#125; ] &#125;, plugins: [ new ExtractTextPlugin(\"styles.css\"), ]&#125; 开发环境建议不要拆分css文件，热更新不会生效。 HtmlWebpackPlugin该插件将为你生成一个HTML5文件，其中包括使用script标签的body中的所有webpack包。 只需添加插件到你的webpack配置如下： var HtmlWebpackPlugin = require('html-webpack-plugin');var path = require('path');var webpackConfig = &#123; entry: 'index.js', output: &#123; path: path.resolve(__dirname, './dist'), filename: 'index_bundle.js' &#125;, plugins: [new HtmlWebpackPlugin()]&#125;; 参考资料webpack 官网","tags":[{"name":"js","slug":"js","permalink":"https://lirawx.me/tags/js/"},{"name":"webpack","slug":"webpack","permalink":"https://lirawx.me/tags/webpack/"}]},{"title":"手写一个redux","date":"2018-02-25T10:01:22.000Z","path":"2018/02/2018-02-25-手写redux.html","text":"首先需要讲一些概念。 纯函数 一个函数的返回结果只依赖于它的参数，并且在执行过程里面没有副作用，我们就把这个函数叫做纯函数。特点: 函数的返回结果只依赖于它的参数。 函数执行过程里面没有副作用。 React.js 特性 —— context 组件间 共享状态 属性只能传入子组件父组件不能读取该属性 高阶组件 高阶组件是一个函数（而不是组件），它接受一个组件作为参数，返回一个新的组件 共享结构的对象 就是类似把 obj 所有的属性都复制到 obj2 里面，相当于对象的浅复制，obj 里面的内容和 obj2 是完全一样的，但是却是两个不同的对象。除了浅复制对象，还可以覆盖、拓展对象属性例： obj const obj2 = &#123; ...obj, b: 3, c: 4&#125; // =&gt; &#123; a: 1, b: 3, c: 4 &#125;，覆盖了 b，新增了 c 简介在一个正常的 react app中需要 组件 也需要组件间交互的数据的store。在这个app中我们用provider 容器包裹 组件，用context 中包围store, 在组件间共享。每个组件都做纯组件化，不包含逻辑，只根据props 渲染。 这就是redux 的设计模式。 套路就是 // 定一个 reducerfunction reducer (state, action) &#123; /* 初始化 state 和 switch case */&#125;// 生成 storeconst store = createStore(reducer)// 监听数据变化重新渲染页面store.subscribe(() =&gt; renderApp(store.getState()))// 首次渲染页面renderApp(store.getState()) // 后面可以随意 dispatch 了，页面自动更新store.dispatch(...) 组件组件就不多说了，主要 Smart 组件 vs Dumb 组件。 Dumb 组件 不包含所有逻辑Smart 组件包含逻辑和从context 中获取相应的数据 store它接受的参数叫 reducer，reducer 是一个函数, 而且是纯函数（Pure Function）function createStore (reducer) &#123; let state = null const listeners = [] // 观察着模式 发布和订阅 // 根据数据是否更新重新渲染相应的足迹 const subscribe = (listener) =&gt; listeners.push(listener) const getState = () =&gt; state const dispatch = (action) =&gt; &#123; state = reducer(state, action) listeners.forEach((listener) =&gt; listener()) &#125; dispatch(&#123;&#125;) // 初始化 state return &#123; getState, dispatch, subscribe &#125;&#125; reducerreducer接受两个参数，一个是 state，一个是 action。如果没有传入 state 或者 state 是 null，那么它就会返回一个初始化的数据。如果有传入 state 的话，就会根据 action 来“修改“数据，但其实它没有、也规定不能修改 state，而是要通过上节所说的把修改路径的对象都复制一遍，然后产生一个新的对象返回。如果它不能识别你的 action，它就不会产生新的数据，而是（在 default 内部）把 state 原封不动地返回。 reducer 是不允许有副作用的。你不能在里面操作 DOM，也不能发 Ajax 请求，更不能直接修改 state，它要做的仅仅是 —— 初始化和计算新的 state。 function themeReducer (state, action) &#123; if (!state) return &#123; themeName: 'Red Theme', themeColor: 'red' &#125; switch (action.type) &#123; case 'UPATE_THEME_NAME': return &#123; ...state, themeName: action.themeName &#125; case 'UPATE_THEME_COLOR': return &#123; ...state, themeColor: action.themeColor &#125; default: return state &#125;&#125;const store = createStore(themeReducer)... Github部分代码react-redux.js import React, &#123; Component &#125; from 'react'import PropTypes from 'prop-types'export const connect = (mapStateToProps, mapDispatchToProps) =&gt; (WrappedComponent) =&gt; &#123; class Connect extends Component &#123; static contextTypes = &#123; store: PropTypes.object &#125; constructor () &#123; super() this.state = &#123; allProps: &#123;&#125; &#125; &#125; componentWillMount () &#123; const &#123; store &#125; = this.context this._updateProps() store.subscribe(() =&gt; this._updateProps()) &#125; _updateProps () &#123; const &#123; store &#125; = this.context let stateProps = mapStateToProps ? mapStateToProps(store.getState(), this.props) : &#123;&#125; // 防止 mapStateToProps 没有传入 let dispatchProps = mapDispatchToProps ? mapDispatchToProps(store.dispatch, this.props) : &#123;&#125; // 防止 mapDispatchToProps 没有传入 this.setState(&#123; allProps: &#123; ...stateProps, ...dispatchProps, ...this.props &#125; &#125;) &#125; render () &#123; return &lt;WrappedComponent &#123;...this.state.allProps&#125; /&gt; &#125; &#125; return Connect&#125;export class Provider extends Component &#123; static propTypes = &#123; store: PropTypes.object, children: PropTypes.any &#125; static childContextTypes = &#123; store: PropTypes.object &#125; getChildContext () &#123; return &#123; store: this.props.store &#125; &#125; render () &#123; return ( &lt;div&gt;&#123;this.props.children&#125;&lt;/div&gt; ) &#125;&#125; index.js import React, &#123; Component &#125; from 'react'import PropTypes from 'prop-types'import ReactDOM from 'react-dom'import Header from './Header'import Content from './Content'import './index.css'import &#123; Provider &#125; from './react-redux'function createStore (reducer) &#123; let state = null const listeners = [] const subscribe = (listener) =&gt; listeners.push(listener) const getState = () =&gt; state const dispatch = (action) =&gt; &#123; state = reducer(state, action) listeners.forEach((listener) =&gt; listener()) &#125; dispatch(&#123;&#125;) // 初始化 state return &#123; getState, dispatch, subscribe &#125;&#125;const themeReducer = (state, action) =&gt; &#123; if (!state) return &#123; themeColor: 'red' &#125; switch (action.type) &#123; case 'CHANGE_COLOR': return &#123; ...state, themeColor: action.themeColor &#125; default: return state &#125;&#125;const store = createStore(themeReducer)// 删除 Index 里面所有关于 context 的代码class Index extends Component &#123; render () &#123; return ( &lt;div&gt; &lt;Header /&gt; &lt;Content /&gt; &lt;/div&gt; ) &#125;&#125;// 把 Provider 作为组件树的根节点ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;Index /&gt; &lt;/Provider&gt;, document.getElementById('root')) 参考资料 开源、免费、专业、简单的 React.js 在线教程","tags":[{"name":"js","slug":"js","permalink":"https://lirawx.me/tags/js/"},{"name":"react","slug":"react","permalink":"https://lirawx.me/tags/react/"},{"name":"redux","slug":"redux","permalink":"https://lirawx.me/tags/redux/"}]},{"title":"ueditor java web的使用","date":"2018-01-29T10:01:22.000Z","path":"2018/01/ueditor.html","text":"ueditor 可以下载生产环境打包版本也可以自己手动编译，ueditor 运用grunt打包。 ueditor 文档地址 ➡️ ueditor github 地址 ➡️ 当然还有一个umeditor , 它是ueditor 的简洁版 , github 仓库 下面讲一下java 中ueditor 的使用。 截图 环境配置首先你必须有一个简单的java web 项目，我这边是一个maven web 项目，简单讲一下配置. ueditor 用到了5个jar 包，其中json.jar ,ueditor-1.1.2.jar 包maven 仓库没有，你需要加入本地包，请看maven如何加入本地包,剩下来的就是pom.xml加入需要的jar包。 &lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.9&lt;/version&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;/dependency&gt; java 配置解压或者打包变异出来的ueditor 的dist 文件夹中，有一个jsp文件夹，其中一个controller.jsp 还有一个config.json 文件。这是主要的文件上传，图片插入等功能的controller 层和配置文件。 当配置好文件和目录结构时，需要重新配置url前缀。具体config.json 文件中 图片上传：imagePathFormat、imageUrlPrefix 涂鸦上传：scrawlPathFormat、scrawlUrlPrefix 截屏上传：snapscreenPathFormat、snapscreenUrlPrefix 附件上传：filePathFormat、fileUrlPrefix 视频上传：videoPathFormat、videoUrlPrefix 例子: 网站根目录是：”D://apache/www/“ 配置项 imagePathFormat 的值为： imagePathFormat = &quot;/ueditor/php/upload/image/&#123;yyyy&#125;-&#123;mm&#125;-&#123;dd&#125;_&#123;rand:6&#125;_&#123;filename&#125;&quot; 上传的文件名可能是这样：”2014-06-13_712623_照片.jpg” 存放的路径是： D://apache/www/ueditor/php/upload/image 常见问题 当easyui 和ueditor 一起使用时，ueditor 的弹框会到easyui dialog 的后面，懂前端的人都知道这是z-index 的问题。 所以需要修改ueditor的z-index 值。 需要修改2处: 第一处: ueditor.css /* 弹出菜单 */.edui-default .edui-popup &#123; z-index: 9800; background-color: #ffffff; width:auto; height:auto;&#125; ueditor.config.js zIndex : 9800 //编辑器层级的基数,默认是900","tags":[{"name":"java ueditor","slug":"java-ueditor","permalink":"https://lirawx.me/tags/java-ueditor/"}]},{"title":"maven 使用本地jar 包","date":"2018-01-29T10:01:22.000Z","path":"2018/01/2018-01-29.html","text":"引入本地jar包 将本地Jar包安装到本地仓库，再按常规方式引用 mvn install:install-file -Dfile=libs\\tools.jar -DgroupId=com.sun -DartifactId=tools -Dversion=1.5.0 -Dpackaging=jar -DgeneratePom=true &lt;dependency&gt; &lt;groupId&gt;com.sun&lt;/groupId&gt; &lt;artifactId&gt;tools&lt;/artifactId&gt; &lt;version&gt;1.5.0&lt;/version&gt;&lt;/dependency&gt; 直接添加本地依赖 &lt;dependency&gt; &lt;groupId&gt;com.sun&lt;/groupId&gt; &lt;artifactId&gt;tools&lt;/artifactId&gt; &lt;version&gt;1.5.0&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;C:/java/jdk/lib/tools.jar&lt;/systemPath&gt;&lt;/dependency&gt; 编译时配置额外的依赖包路径&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.6&lt;/source&gt; &lt;target&gt;1.6&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;compilerArguments&gt; &lt;extdirs&gt;src\\main\\webapp\\WEB-INF\\lib&lt;/extdirs&gt; &lt;/compilerArguments&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 将额外的本地依赖文件打到war包中&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;2.3&lt;/version&gt; &lt;configuration&gt; &lt;warName&gt;${project.artifactId}&lt;/warName&gt; &lt;webResources&gt; &lt;resource&gt; &lt;directory&gt;lib/&lt;/directory&gt; &lt;targetPath&gt;WEB-INF/lib&lt;/targetPath&gt; &lt;includes&gt; &lt;include&gt;**/*.jar&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/webResources&gt; &lt;/configuration&gt; &lt;/plugin&gt;","tags":[{"name":"maven jar","slug":"maven-jar","permalink":"https://lirawx.me/tags/maven-jar/"}]},{"title":"2017年终总结","date":"2018-01-02T00:27:15.000Z","path":"2017/12/2017-2018.html","text":"2017年已经接近尾声，今年是离开学校的第一年，也是开始工作的第一年，从象牙塔到社会大熔炉，是结束也是开始，今年的目标很没有志气，只是希望安稳的开始工作，掌握应有的技术知识，可以工作稳定下来，甚至可以说活下来。目标很低，但是我很知足，生活还是可以安逸和祥和。今年学习很快，学了很多，真正用的很少，spring,springmvc,mybatis,shiro,redis,等后端的基本已经很熟练，编码基本都是那样，严格按照google java 编程风格，同时，熟悉maven 工程管理项目，maven + spring + springmvc + mybatis 等普通java web 项目的搭建，同时在java开发中，一些基本的应用，例如spring文件上传，整合阿里短信平台，七牛云存储等。。逐步搭建了相应的框架实现相应的功能，在视图方面，熟悉了Thymeleaf, Velocity等模版引擎的应用，当然，学习主要是应用。下面讲项目： 企业信息库搭建该项目的技术结构，同时负责用户订单模块，包括了订单下单，订单结算，订单的查询，后台管理订单的增删改查，发货，再次发货等功能。 邀请函系统主要是解决现有系统的bug，同时增加相应的公共。重写了邀请函附件上传功能，增加多个文件上传，统一预览功能。增加了受理后自动盖上公章的功能，主要是imageio类的应用。实现条形码的实现，运用google zXing 工具包。当然还有一些其他功能的修正，如重新注册，一些显示问题等。 境外投资前端要用easyui做，所以需要修改一下接口。前端页面手写bootstrap 搭建。等等。 以上是今年主要完成的工作，同时明年应当有所计划，现阶段，后端java 基本开发逻辑已经很清楚了，技术感觉略处于饱和，时代的潮流，后端已经开始剥离一些功能，转入前端，后端只需要开放相应的接口，所以2018年应当把工作重心放到前端上，尤其是一些框架，vue react等前端框架，同时拥抱es6,es7 javascript技术，构建自有的前端技术栈，同时java 后端采用spring boot 快速开发，开放相应的api，数据库可以用mycat 实现读写分离，在服务器架构上可以用docker实现一台ecs 多个项目共存，互不影响。同时可以应用nodejs处理高并发的请求，实现全栈技术的实际应用。","tags":[{"name":"年终总结","slug":"年终总结","permalink":"https://lirawx.me/tags/年终总结/"}]},{"title":"docker容器简单总结","date":"2017-12-31T04:37:33.000Z","path":"2017/12/docker.html","text":"docker 现代化服务端部署运行环境的解决方案，避免了很多程序兼容性的问题，所以值得每个软件开发人掌握，一下是我自己学习之后稍微的整理出的知识点。 容器技术容器技术是docker 的核心和基础。核心知识主要回答有关容器 what, why 和 how 三方面的问题。 其中以 how 为重，将展开讨论架构、镜像、容器、网络和存储。进阶知识包括将容器真正用于生产所必需的技术，包括多主机管理、跨主机网络、监控、数据管理、日志管理和安全管理。 大家有兴趣深入docker，可以去看看《每天5分钟玩转Docker容器技术》这本书。 容器平台技术“容器平台技术”包括容器编排引擎、容器管理平台和基于容器的 PaaS。容器平台技术在生态环境中占据着举足轻重的位置，对于容器是否能够落地，是否能应用于生产至关重要。 容器核心技术一想到容器就想到docker，docker因为构建了完整的容器生态系统，所以他成功了。 容器核心技术 容器规范 容器runtime 容器管理工具 容器定义工具 Registries 容器OS 容器规范(OCI) ，不同的组织和厂商开发的容器能够在不同的runtime中运行。 容器 runtime，需要跟操作系统kernel紧密结合，java 程序类似容器，jvm 类似runtime。jvm 为java 程序提供运行环境。所以容器只能在runtime 中运行。lxc、runc 和 rkt 是目前主流的三种容器 runtime。 容器管理工具 容器管理工具对内与 runtime 交互，对外为用户提供 interface。runc 的管理工具是 docker engine。docker engine 包含后台 deamon 和 cli 两个部分。我们通常提到 Docker，一般就是指的 docker engine。 容器定义工具，容器定义工具允许用户定义容器的内容和属性，这样容器就能够被保存，共享和重建。docker image 是 docker 容器的模板，runtime 依据 docker image 创建容器。dockerfile 是包含若干命令的文本文件，可以通过这些命令创建出 docker image。ACI (App Container Image) 与 docker image 类似，只不过它是由 CoreOS 开发的 rkt 容器的 image 格式。 Registry，容器是通过 image 创建的，需要有一个仓库来统一存放 image，这个仓库就叫做 Registry。 容器 OS ，容器 OS 是专门运行容器的操作系统。与常规 OS 相比，容器 OS 通常体积更小，启动更快。因为是为容器定制的 OS，通常它们运行容器的效率会更高。 以上是一些简单的技术名词介绍，方便大家理解容器，下面讲怎么样应用docker. 容器的优势对于开发人员 Build Once, Run Anywhere容器意味着环境隔离和可重复性。开发人员只需为应用创建一次运行环境，然后打包成容器便可在其他机器上运行。另外，容器环境与所在的 Host 环境是隔离的，就像虚拟机一样，但更快更简单。 对于运维人员 Configure Once, Run Anything只需要配置好标准的 runtime 环境，服务器就可以运行任何容器。这使得运维人员的工作变得更高效，一致和可重复。容器消除了开发、测试、生产环境的不一致性。 Docker 架构 Docker 客户端最常用的 Docker 客户端是 docker 命令。通过 docker 我们可以方便地在 Host 上构建和运行容器。 Docker 服务器Docker daemon 是服务器组件，以 Linux 后台服务的方式运行。可以查看运行情况systemctl status docker.service Docker 镜像可将 Docker 镜像看成只读模板，通过它可以创建 Docker 容器。例如某个镜像可能包含一个 Ubuntu 操作系统、一个 Apache HTTP Server 以及用户开发的 Web 应用。镜像有多种生成方法： 可以从无到有开始创建镜像 也可以下载并使用别人创建好的现成的镜像 还可以在现有镜像上创建新的镜像 我们可以将镜像的内容和创建步骤描述在一个文本文件中，这个文件被称作 Dockerfile，通过执行 docker build 命令可以构建出 Docker 镜像。 Docker 容器Docker 容器就是 Docker 镜像的运行实例。 用户可以通过 CLI（docker）或是 API 启动、停止、移动或删除容器。可以这么认为，对于应用软件，镜像是软件生命周期的构建和打包阶段，而容器则是启动和运行阶段。 RegistryRegistry 是存放 Docker 镜像的仓库，Registry 分私有和公有两种。docker pull命令可以从 Registry 下载镜像。 docker run命令则是先下载镜像（如果本地没有），然后再启动容器。 helloword下载hello-wrold镜像docker pull hello-world查看docker imges hello-world运行docker run hello-world&gt; Hello from Docker! 到此docker就介绍完了。可以去参考一下链接。 参考链接每天5分钟玩转Docker容器技术（一）每天5分钟玩转Docker容器技术（二）每天5分钟玩转Docker容器技术（三）","tags":[{"name":"docker","slug":"docker","permalink":"https://lirawx.me/tags/docker/"}]},{"title":"常用设计模式总结","date":"2017-12-22T00:00:00.000Z","path":"2017/12/设计模式.html","text":"设计模式 工厂模式 抽象工厂模式 代理模式 单例模式 策略模式 原型模式 模板模式 工厂模式 简介 ：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。 优点： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。 缺点： 每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。 使用场景： 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。 简单实现 public class ShapeFactory &#123; //使用 getShape 方法获取形状类型的对象 public Shape getShape(String shapeType)&#123; if(shapeType == null)&#123; return null; &#125; if(shapeType.equalsIgnoreCase(\"CIRCLE\"))&#123; return new Circle(); &#125; else if(shapeType.equalsIgnoreCase(\"RECTANGLE\"))&#123; return new Rectangle(); &#125; else if(shapeType.equalsIgnoreCase(\"SQUARE\"))&#123; return new Square(); &#125; return null; &#125;&#125; 实现利用反射实现 public class ShapeFactory &#123; public static Object getClass(Class&lt;?extends Shape&gt; clazz) &#123; Object obj = null; try &#123; obj = Class.forName(clazz.getName()).newInstance(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; return obj; &#125;&#125; 调用 Rectangle rect = (Rectangle) ShapeFactory.getClass(Rectangle.class);rect.draw();Square square = (Square) ShapeFactory.getClass(Square.class);square.draw(); 抽象工厂模式 简介 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类 优点：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。 缺点：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。 使用场景： 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。 实现 抽象工厂函数 public abstract class AbstractFactory &#123; abstract Color getColor(String color); abstract Shape getShape(String shape) ;&#125; 根据参数不同生产不同工厂函数 public class ShapeFactory extends AbstractFactory &#123; @Override public Shape getShape(String shapeType)&#123; if(shapeType == null)&#123; return null; &#125; if(shapeType.equalsIgnoreCase(\"CIRCLE\"))&#123; return new Circle(); &#125; else if(shapeType.equalsIgnoreCase(\"RECTANGLE\"))&#123; return new Rectangle(); &#125; else if(shapeType.equalsIgnoreCase(\"SQUARE\"))&#123; return new Square(); &#125; return null; &#125; @Override Color getColor(String color) &#123; return null; &#125;&#125;public class ColorFactory extends AbstractFactory &#123; @Override public Shape getShape(String shapeType)&#123; return null; &#125; @Override Color getColor(String color) &#123; if(color == null)&#123; return null; &#125; if(color.equalsIgnoreCase(\"RED\"))&#123; return new Red(); &#125; else if(color.equalsIgnoreCase(\"GREEN\"))&#123; return new Green(); &#125; else if(color.equalsIgnoreCase(\"BLUE\"))&#123; return new Blue(); &#125; return null; &#125;&#125; 代理模式 简介 为其他对象提供一种代理以控制对这个对象的访问。 优点： 1、职责清晰。 2、高扩展性。 3、智能化。 缺点： 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。 使用场景：按职责来划分，通常有以下使用场景： 1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理。 实现 public interface Image &#123; void display();&#125; public class RealImage implements Image &#123; private String fileName; public RealImage(String fileName)&#123; this.fileName = fileName; loadFromDisk(fileName); &#125; @Override public void display() &#123; System.out.println(\"Displaying \" + fileName); &#125; private void loadFromDisk(String fileName)&#123; System.out.println(\"Loading \" + fileName); &#125;&#125; public class ProxyImage implements Image&#123; private RealImage realImage; private String fileName; public ProxyImage(String fileName)&#123; this.fileName = fileName; &#125; @Override public void display() &#123; if(realImage == null)&#123; realImage = new RealImage(fileName); &#125; realImage.display(); &#125;&#125; public class ProxyPatternDemo &#123; public static void main(String[] args) &#123; Image image = new ProxyImage(\"test_10mb.jpg\"); image.display(); System.out.println(\"\"); image.display(); &#125;&#125; 单例模式 简介 保证一个类仅有一个实例，并提供一个访问它的全局访问点 优点： 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 2、避免对资源的多重占用（比如写文件操作）。 缺点： 没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。 使用场景： 1、要求生产唯一序列号。 2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。 实现方式 1.懒汉式： 是否 Lazy 初始化：是 是否多线程安全：是 实现难度：易 描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。优点：第一次调用才初始化，避免内存浪费。缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。 代码实现： public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 双检锁/双重校验锁（DCL，即 double-checked locking） JDK 版本：JDK1.5 起 是否 Lazy 初始化：是 是否多线程安全：是 实现难度：较复杂 描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。getInstance() 的性能对应用程序很关键。 代码实例： public class Singleton &#123; private volatile static Singleton singleton; private Singleton ()&#123;&#125; public static Singleton getSingleton() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125; 枚举 JDK 版本：JDK1.5 起 是否 Lazy 初始化：否 是否多线程安全：是 实现难度：易 描述：这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。不能通过 reflection attack 来调用私有构造方法。 代码实例： public enum Singleton &#123; INSTANCE; public void whateverMethod() &#123; &#125;&#125; 策略模式 简介 在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。关键就是要实现同一个接口 优点： 1、算法可以自由切换。2、避免使用多重条件判断。3、扩展性良好。 缺点： 1、策略类会增多。2、所有策略类都需要对外暴露。 使用场景： 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。2、一个系统需要动态地在几种算法中选择一种。3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。 实现 统一接口 public interface Strategy &#123; public int doOperation(int num1, int num2);&#125; public class OperationAdd implements Strategy&#123; @Override public int doOperation(int num1, int num2) &#123; return num1 + num2; &#125;&#125; 省略了 OperationSubstract OperationMultiply 容器 public class Context &#123; private Strategy strategy; public Context(Strategy strategy)&#123; this.strategy = strategy; &#125; public int executeStrategy(int num1, int num2)&#123; return strategy.doOperation(num1, num2); &#125;&#125; 调用实例 public class StrategyPatternDemo &#123; public static void main(String[] args) &#123; Context context = new Context(new OperationAdd()); System.out.println(\"10 + 5 = \" + context.executeStrategy(10, 5)); context = new Context(new OperationSubstract()); System.out.println(\"10 - 5 = \" + context.executeStrategy(10, 5)); context = new Context(new OperationMultiply()); System.out.println(\"10 * 5 = \" + context.executeStrategy(10, 5)); &#125;&#125; 原型模式 简介 原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。 优点： 1、性能提高。2、逃避构造函数的约束。 缺点： 1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。2、必须实现 Cloneable 接口。3、逃避构造函数的约束。 使用场景： 1、资源优化场景。2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。3、性能和安全要求的场景。 4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。5、一个对象多个修改者的场景。 6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过clone的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。 实现 public abstract class Shape implements Cloneable &#123; private String id; protected String type; abstract void draw(); public String getType()&#123; return type; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public Object clone() &#123; Object clone = null; try &#123; clone = super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return clone; &#125;&#125; public class Rectangle extends Shape &#123; public Rectangle()&#123; type = \"Rectangle\"; &#125; @Override public void draw() &#123; System.out.println(\"Inside Rectangle::draw() method.\"); &#125;&#125; import java.util.Hashtable;public class ShapeCache &#123; private static Hashtable&lt;String, Shape&gt; shapeMap = new Hashtable&lt;String, Shape&gt;(); public static Shape getShape(String shapeId) &#123; Shape cachedShape = shapeMap.get(shapeId); return (Shape) cachedShape.clone(); &#125; // 对每种形状都运行数据库查询，并创建该形状 // shapeMap.put(shapeKey, shape); // 例如，我们要添加三种形状 public static void loadCache() &#123; Circle circle = new Circle(); circle.setId(\"1\"); shapeMap.put(circle.getId(),circle); Square square = new Square(); square.setId(\"2\"); shapeMap.put(square.getId(),square); Rectangle rectangle = new Rectangle(); rectangle.setId(\"3\"); shapeMap.put(rectangle.getId(),rectangle); &#125;&#125; public class PrototypePatternDemo &#123; public static void main(String[] args) &#123; ShapeCache.loadCache(); Shape clonedShape = (Shape) ShapeCache.getShape(\"1\"); System.out.println(\"Shape : \" + clonedShape.getType()); Shape clonedShape2 = (Shape) ShapeCache.getShape(\"2\"); System.out.println(\"Shape : \" + clonedShape2.getType()); Shape clonedShape3 = (Shape) ShapeCache.getShape(\"3\"); System.out.println(\"Shape : \" + clonedShape3.getType()); &#125;&#125; 模板模式 简介 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 优点： 1、封装不变部分，扩展可变部分。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。 缺点： 每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。 使用场景： 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。 实现 public abstract class Game &#123; abstract void initialize(); abstract void startPlay(); abstract void endPlay(); //模板 public final void play()&#123; //初始化游戏 initialize(); //开始游戏 startPlay(); //结束游戏 endPlay(); &#125;&#125; public class Cricket extends Game &#123; @Override void endPlay() &#123; System.out.println(\"Cricket Game Finished!\"); &#125; @Override void initialize() &#123; System.out.println(\"Cricket Game Initialized! Start playing.\"); &#125; @Override void startPlay() &#123; System.out.println(\"Cricket Game Started. Enjoy the game!\"); &#125;&#125; public class TemplatePatternDemo &#123; public static void main(String[] args) &#123; Game game = new Cricket(); game.play(); System.out.println(); game = new Football(); game.play(); &#125;&#125;","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://lirawx.me/tags/设计模式/"}]},{"title":"docker 实现 mysql 的主从复制","date":"2017-12-19T00:00:00.000Z","path":"2017/12/mysql-主从复制.html","text":"Docker 是一个开源的引擎，可以轻松的为任何应用创建一个轻量级、可移植、自给自足的容器。 docker 的使用就不多说，直接进入怎么配置mysql 主从复制 实现步骤 准备两台 MySQL 服务器 配置主服务器（Master） 配置从服务器（Slave） 完成Master和Slave链接 测试配置是否成功 docker 虚拟两台 MySQL 服务器命令如下：创建主服务器 docker run --name mysql_master -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:latest 通过镜像 mysql:latest ,该景象基于debain os 。启动一个名为 mysql_master 的 MySQL 服务器，端口号是3306，映射的宿主机端口号是3306，root 账号密码是123456 创建从服务器 docker run --name mysql_slave -p 3307:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:latest 可以使用 docker ps 查看当前运行的容器 下面需要进行一些相关配置 首先我们先逐个获取容器运行的ip地址 # masterdocker inspect --format='&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;' c66b935ea94d172.17.0.2# slavedocker inspect --format='&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;' 2bb11aa899e4172.17.0.3 配置主服务器（Master）docker exec -it c66b935ea94d /bin/bash 在安装vim之前要先升级一下软件包 apt-get updateapt install -y vim 之后配置mysql，配置文件在/etc/mysql/my.cnf [mysqld]## 设置server_id，一般设置为IP，同一局域网内注意要唯一server_id=100## 复制过滤：也就是指定哪个数据库不用同步（mysql库一般不同步）binlog-ignore-db=mysql## 开启二进制日志功能，可以随便取，最好有含义（关键就是这里了）log-bin=edu-mysql-bin## 为每个session 分配的内存，在事务过程中用来存储二进制日志的缓存binlog_cache_size=1M## 主从复制的格式（mixed,statement,row，默认格式是statement）binlog_format=mixed## 二进制日志自动删除/过期的天数。默认值为0，表示不自动删除。expire_logs_days=7## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致slave_skip_errors=1062 在我的容器中，my.cnf 的路径是 /etc/mysql。配置完成后重启 mysql ，使用如下命令： service mysql restart 这个命令会使得容器停止，重新启动就可以了。 docker start c66b935ea94d 接下来创建数据同步用户： CREATE USER &apos;slave&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos;;GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO &apos;slave&apos;@&apos;%&apos;;flush privileges; 配置从服务器（Slave）配置文件 my.cnf [mysqld]## 设置server_id，一般设置为IP,注意要唯一server_id=101## 复制过滤：也就是指定哪个数据库不用同步（mysql库一般不同步）binlog-ignore-db=mysql## 开启二进制日志功能，以备Slave作为其它Slave的Master时使用log-bin=edu-mysql-slave1-bin## 为每个session 分配的内存，在事务过程中用来存储二进制日志的缓存binlog_cache_size=1M## 主从复制的格式（mixed,statement,row，默认格式是statement）binlog_format=mixed## 二进制日志自动删除/过期的天数。默认值为0，表示不自动删除。expire_logs_days=7## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致slave_skip_errors=1062## relay_log配置中继日志relay_log=edu-mysql-relay-bin## log_slave_updates表示slave将复制事件写进自己的二进制日志log_slave_updates=1## 防止改变数据(除了特殊的线程)read_only=1 完成Master和Slave链接注意，需要保证 Master 和 Slave 除了不同步的数据库，其他数据库的数据要一致。在 Master 进入 MySQL， 然后执行命令： show master status; 记录下 File 和 Position 字段的值，后面会用到。 然后到 Slave 中进入 mysql，执行命令：change master to master_host='172.17.0.2', master_user='slave', master_password='123456', master_port=3306, master_log_file='edu-mysql-bin.000001', master_log_pos=929, master_connect_retry=30; 命令解释：master_host: Master 的IP地址master_user: 在 Master 中授权的用于数据同步的用户master_password: 同步数据的用户的密码master_port: Master 的数据库的端口号master_log_file: 指定 Slave 从哪个日志文件开始复制数据，即上文中提到的 File 字段的值master_log_pos: 从哪个 Position 开始读，即上文中提到的 Position 字段的值master_connect_retry: 当重新建立主从连接时，如果连接失败，重试的时间间隔，单位是秒，默认是60秒。 在 Slave 的 MySQL 终端执行查看主从同步状态 show slave status \\G; SlaveIORunning 和 SlaveSQLRunning 是No，表明 Slave 还没有开始复制过程。相反 SlaveIORunning 和 SlaveSQLRunning 是Yes表明已经开始工作了，因为我已经运行过了，所以我的显示的都是 Yes。 执行以下命令，开始开启主从同步：start slave; OK! slave 基本命令start slave; //开启slavestop slave; // 停止主从复制reset slave; // 充值slave 状态。或者 change master to master_host=’ ‘","tags":[{"name":"mysql docker","slug":"mysql-docker","permalink":"https://lirawx.me/tags/mysql-docker/"}]},{"title":"mysql 读写分离mycat实现","date":"2017-12-19T00:00:00.000Z","path":"2017/12/mycat-读写分离.html","text":"环境 必须已经配置mysql主从复制，可以参考文章➡️mysql主从复制 实验拓扑： mycat / \\ master – slave (主从复制) mycat: 172.17.0.1master: 172.17.0.2slave: 172.17.0.3 Mycat 提供了编译好的安装包，下载地址：http://dl.mycat.io Index of /../1.6-RELEASE/ 28-Oct-2016 12:56 -1.6.5-DEV/ 15-Jan-2017 07:10 -2.0-dev/ 02-Jan-2017 07:24 -mycat-web-1.0/ 02-Jan-2017 07:40 -yum/ 18-May-2016 02:51 -Mycat-server-1.4-beta-20150604171601-linux.tar.gz 27-Jun-2015 10:09 7663894apache-maven-3.3.3-bin.tar.gz 27-Jun-2015 10:09 8042383apache-tomcat-7.0.62.tar.gz 27-Jun-2015 10:09 8824528jdk-7u79-linux-x64.tar.gz 27-Jun-2015 10:09 153512879jdk-8u20-linux-x64.tar.gz 27-Jun-2015 10:09 160872342phpMyAdmin-4.4.9-all-languages.tar.gz 27-Jun-2015 10:09 9352049probe-2.3.3.zip 27-Jun-2015 10:09 7957290toolset.sh 26-Oct-2015 05:03 16015zookeeper-3.4.6.tar.gz 下载 wget http://dl.mycat.io/1.6-RELEASE/Mycat-server-1.6-RELEASE-20161028204710-linux.tar.gz Mycat-server 包解压后可直接使用。 tar -xf Mycat-server-1.6-RELEASE-20161028204710-linux.tar.gz -C /usr/local/ 目录结构: [root@vm2 local]# tree -L 1 mycatmycat|-- bin|-- catlet|-- conf|-- lib|-- logs-- version.txt5 directories, 1 file bin 目录中是可执行文件以及脚本，我们可以使用其中的 mycat 脚本控制mycat的启动和关闭。conf 目录中是配置文件，这里配置读写分离主要使用 schema.xml 和 server.xml。其他配置分片的配置请参考官方文档。logs 目录存放日志文件，遇到mycat出错了，就在这里查看问题的原因。 这里只讲解一下读写分离用到的配置文件：server.xml, schema.xml。 前提：已经有一个配置好的 mysql 一主一从架构。 一个主从集群在Mycat里面由一个 dataNode 定义，dataNode 定义了一个数据库实例及其中的一个具体的库。Mycat 的一个数据库实例可以实际上是一个主从复制架构：一主多从，一主一从，多主多从等等，具体在 dataHost 中定义。 这里建立一个非拆分库（将mycat逻辑库绑定到一个具体的 dataNode 上）testdb，绑定到 dn1 这个 dataNode 上。 schema.xml: &lt;schema name=\"testdb\" checkSQLschema=\"false\" sqlMaxLimit=\"100\" dataNode=\"dn1\"&gt;&lt;/schema&gt; 现在所有的表会走默认的节点 dn1。逻辑库 testdb，对应了数据节点 dn1。dn1 对应着真实的数据库实例上的一个真实的库。 &lt;dataNode name=\"dn1\" dataHost=\"vm3306\" database=\"db1\" &gt;&lt;/dataNode&gt; dataNode 标签定义了 MyCat 中的数据节点,也就是我们通常说所的数据分片。一个 dataNode 标签就是 一个独立的数据分片。例子中所表述的意思为:使用名字为 vm3306 数据库实例上的 db1 物理数据库,这就组成一个数据分片,最 后,我们使用名字 dn1 标识这个分片。该属性用于定义该分片属性哪个具体数据库实例上的具体库,因为这里使用两个纬度来定义分片,就是:实 例+具体的库。因为每个库上建立的表和表结构是一样的。所以这样做就可以轻松的对表进行水平拆分。dataHost: 包含一个 writeHost 和 一个 readHost，它们之前已经配置好主从复制了。balance=”3”：表示写请求只发给节点，读请求只发给读节点。 &lt;dataHost name=\"vm3306\" maxCon=\"1000\" minCon=\"10\" balance=\"3\" writeType=\"0\" dbType=\"mysql\" dbDriver=\"native\"&gt; &lt;heartbeat&gt;select user()&lt;/heartbeat&gt; &lt;!-- can have multi write hosts --&gt; &lt;writeHost host=\"hostM1\" url=\"192.168.0.120:3306\" user=\"tuser\" password=\"guli123\"&gt; &lt;!-- can have multi read hosts --&gt; &lt;readHost host=\"hostS1\" url=\"192.168.0.122:3306\" user=\"tuser\" password=\"guli123\"/&gt; &lt;/writeHost&gt; &lt;!-- &lt;writeHost host=\"hostM2\" url=\"localhost:3316\" user=\"tuser\" password=\"guli123\"/&gt; --&gt;&lt;/dataHost&gt; user 及 password属性是后端主从mysql的账户密码信息。 dataHost属性说明： writeType=”0”, 所有写操作发送到配置的第一个 writeHost,第一个挂了切到还生存的第二个 writeHost,重新启动后已切换后的为准,切换记录在配置文件中:dnindex.properties . balance=”3”,所有读请求随机的分发到 wiriterHost 对应的 readhost 执行,writerHost 不负担读压力,注意 balance=3 只在 1.4 及其以后版本有,1.3 没有。 &lt;user name=\"test\"&gt; &lt;property name=\"password\"&gt;root&lt;/property&gt; &lt;property name=\"schemas\"&gt;testdb&lt;/property&gt; &lt;/user&gt; &lt;user name=\"user\"&gt; &lt;property name=\"password\"&gt;user&lt;/property&gt; &lt;property name=\"schemas\"&gt;testdb&lt;/property&gt; &lt;property name=\"readOnly\"&gt;true&lt;/property&gt; &lt;/user&gt; 这边定义mycat 的用户 配置相应的权限 启动mycat cd /usr/local/mycat/bin./mycat start Mycat 管理命令与监控登录:目前 mycat 有两个端口,8066 数据端口,9066 管理端口,命令行的登陆是通过 9066 管理端口来操 作,登录方式类似于 mysql 的服务端登陆。 mysql -h127.0.0.1 -utest -ptest -P9066 [-dmycat]-h 后面是主机,即当前 mycat 按照的主机地址,本地可用 127.0.0.1 远程需要远程 ip -u Mycat server.xml 中配置的逻辑库用户-p Mycat server.xml 中配置的逻辑库密码-P 后面是端口 默认 9066,注意 P 是大写-d Mycat server.xml 中配置的逻辑库 mysql -h127.0.0.1 -uroot -p123456 -P9066 从 9066 管理端口登陆后，执行 show @@help 可以查看到所有帮助命令 其他主要和mysql 差不多，就不多说了。","tags":[{"name":"mycat mysql","slug":"mycat-mysql","permalink":"https://lirawx.me/tags/mycat-mysql/"}]},{"title":"mysql 悲观锁和乐观锁","date":"2017-12-19T00:00:00.000Z","path":"2017/12/mysql-悲观锁-乐观锁.html","text":"简介在数据库的锁机制中介绍过，数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。 乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。 无论是悲观锁还是乐观锁，都是人们定义出来的概念，可以认为是一种思想。其实不仅仅是关系型数据库系统中有乐观锁和悲观锁的概念，像memcache、hibernate、tair等都有类似的概念。 针对于不同的业务场景，应该选用不同的并发控制方式。所以，不要把乐观并发控制和悲观并发控制狭义的理解为DBMS中的概念，更不要把他们和数据中提供的锁机制（行锁、表锁、排他锁、共享锁）混为一谈。其实，在DBMS中，悲观锁正是利用数据库本身提供的锁机制来实现的。 悲观锁 在关系数据库管理系统里，悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）是一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作都某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。 在数据库中，悲观锁的流程如下： 在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。 如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。 具体响应方式由开发者根据实际需要决定。 如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。 其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。 MySQL InnoDB中使用悲观锁 要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。set autocommit=0; //0.开始事务begin;/begin work;/start transaction; (三者选一就可以)//1.查询出商品信息select status from t_goods where id=1 for update;//2.根据商品信息生成订单insert into t_orders (id,goods_id) values (null,1);//3.修改商品status为2update t_goods set status=2;//4.提交事务commit;/commit work; 上面的查询语句中，我们使用了select…for update的方式，这样就通过开启排他锁的方式实现了悲观锁。此时在t_goods表中，id为1的 那条数据就被我们锁定了，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。 乐观锁在关系数据库管理系统里，乐观并发控制（又名“乐观锁”，Optimistic Concurrency Control，缩写“OCC”）是一种并发控制的方法。它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。乐观事务控制最早是由孔祥重（H.T.Kung）教授提出。 实现流程 数据版本,为数据增加的一个版本标识。当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期数据。 SQL语句 1.查询出商品信息select (status,status,version) from t_goods where id=#&#123;id&#125;2.根据商品信息生成订单3.修改商品status为2update t_goodsset status=2,version=version+1where id=#&#123;id&#125; and version=#&#123;version&#125;;","tags":[{"name":"mysql 并发控制","slug":"mysql-并发控制","permalink":"https://lirawx.me/tags/mysql-并发控制/"}]},{"title":"maven 分模块工程","date":"2017-12-17T00:00:00.000Z","path":"2017/12/maven-module.html","text":"在平时的Javaweb项目开发中为了便于后期的维护，我们一般会进行分层开发，最常见的就是分为domain（域模型层）、dao（数据库访问层）、service（业务逻辑层）、web（表现层），这样分层之后，各个层之间的职责会比较明确，后期维护起来也相对比较容易，今天我们就是使用Maven来构建以上的各个层。每个层对应一个模块，这里domain层为model 包， web 层为controller层。 项目结构如下: .├── README.md├── maven_archetype_custom.iml├── maven_archetype_custom_common│ ├── maven_archetype_custom_common.iml│ ├── pom.xml│ └── src├── maven_archetype_custom_controller│ ├── maven_archetype_custom_controller.iml│ ├── pom.xml│ └── src├── maven_archetype_custom_dao│ ├── maven_archetype_custom_dao.iml│ ├── pom.xml│ └── src├── maven_archetype_custom_model│ ├── maven_archetype_custom_model.iml│ ├── pom.xml│ └── src├── maven_archetype_custom_service│ ├── maven_archetype_custom_service.iml│ ├── pom.xml│ └── src├── pom.xml└── src ├── main └── test 环境 mac os 10.13.2 idea 2017.2 maven 3.5 实现步骤parent 包普通maven项目就好，主要是配置pom.xml ，所有的依赖jar包都可以写入pom.xml 后面创建的模块会继承这个pom.xml。差不多这种感觉： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.lirawx&lt;/groupId&gt; &lt;artifactId&gt;maven_archetype_custom&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;modules&gt; &lt;module&gt;maven_archetype_custom_common&lt;/module&gt; &lt;module&gt;maven_archetype_custom_model&lt;/module&gt; &lt;module&gt;maven_archetype_custom_dao&lt;/module&gt; &lt;module&gt;maven_archetype_custom_service&lt;/module&gt; &lt;module&gt;maven_archetype_custom_controller&lt;/module&gt; &lt;/modules&gt; .......&lt;/project&gt; 接下来创建其他模块，直接parent 包右键new -&gt; module 就好，然后除了controller包也就是web层是webapp 也就是war打包以外其他都是普通maven项目,也就是packaging设置为pom。 项目结构搭建好了，现在还不能整个项目编译，我们稍稍修改一些配置。controller 层依赖service层，service 层依赖dao层，dao层依赖model层，所以我们需要在pom.xml中添加相关依赖。这边我所有工具包都在common包下，所以他们都依赖common包， 下面贴一下配置model 层 &lt;parent&gt; &lt;artifactId&gt;maven_archetype_custom&lt;/artifactId&gt; &lt;groupId&gt;cn.lirawx&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;maven_archetype_custom_model&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;cn.lirawx&lt;/groupId&gt; &lt;artifactId&gt;maven_archetype_custom_common&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; dao 层 &lt;parent&gt; &lt;artifactId&gt;maven_archetype_custom&lt;/artifactId&gt; &lt;groupId&gt;cn.lirawx&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;maven_archetype_custom_dao&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;cn.lirawx&lt;/groupId&gt; &lt;artifactId&gt;maven_archetype_custom_common&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cn.lirawx&lt;/groupId&gt; &lt;artifactId&gt;maven_archetype_custom_model&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; service 层 &lt;parent&gt; &lt;artifactId&gt;maven_archetype_custom&lt;/artifactId&gt; &lt;groupId&gt;cn.lirawx&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;maven_archetype_custom_service&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;cn.lirawx&lt;/groupId&gt; &lt;artifactId&gt;maven_archetype_custom_common&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cn.lirawx&lt;/groupId&gt; &lt;artifactId&gt;maven_archetype_custom_model&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cn.lirawx&lt;/groupId&gt; &lt;artifactId&gt;maven_archetype_custom_dao&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; controller 层 &lt;parent&gt; &lt;artifactId&gt;maven_archetype_custom&lt;/artifactId&gt; &lt;groupId&gt;cn.lirawx&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;maven_archetype_custom_controller&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;maven_archetype_custom_controller Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;cn.lirawx&lt;/groupId&gt; &lt;artifactId&gt;maven_archetype_custom_common&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cn.lirawx&lt;/groupId&gt; &lt;artifactId&gt;maven_archetype_custom_model&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cn.lirawx&lt;/groupId&gt; &lt;artifactId&gt;maven_archetype_custom_service&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; ${project.version} 是maven自带的属性，表示整个工程的version","tags":[{"name":"maven modules","slug":"maven-modules","permalink":"https://lirawx.me/tags/maven-modules/"}]},{"title":"maven profile切换","date":"2017-12-17T00:00:00.000Z","path":"2017/12/maven-profile.html","text":"当用maven管理工程后，线上线下环境的切换就变得很有必要了，灵活切换有助于项目的开发和测试。 环境 mac os 10.13.2 idea 2017.2 maven 3.5 maven 配置首先pom.xml 定义 两个profile ，这边一个开发环境dev一个生产环境 prod &lt;profiles&gt; &lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;properties&gt; &lt;profiles.active&gt;dev&lt;/profiles.active&gt; &lt;/properties&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;includes&gt; &lt;include&gt;**/**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;excludes&gt; &lt;exclude&gt;config/*&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;directory&gt;src/main/resources/config/$&#123;profiles.active&#125;/*&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;prod&lt;/id&gt; &lt;properties&gt; &lt;profiles.active&gt;prod&lt;/profiles.active&gt; &lt;/properties&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;includes&gt; &lt;include&gt;**/**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;excludes&gt; &lt;exclude&gt;config/*&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;directory&gt;src/main/resources/config/$&#123;profiles.active&#125;/*&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; &lt;/profile&gt; &lt;/profiles&gt; resouces 可以配置包含哪个文件或者去除包含哪个文件，然后可以更具激活不同的dev 来包含正确的resource文件或者目录 之后因为web.xml中要加载applicationContext.xml其中数据库文件需要更具不同的profile来选择，所以需要把${profiles.active}这个变量传递到web.xml中，pom.xml中build 标签下加入如下配置: &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;configuration&gt; &lt;warName&gt;$&#123;project.artifactId&#125;&lt;/warName&gt; &lt;!-- 激活spring profile --&gt; &lt;webResources&gt; &lt;resource&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;directory&gt;src/main/webapp&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/web.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/webResources&gt; &lt;warSourceDirectory&gt;src/main/webapp&lt;/warSourceDirectory&gt; &lt;webXml&gt;src/main/webapp/WEB-INF/web.xml&lt;/webXml&gt; &lt;/configuration&gt; &lt;/plugin&gt; 之后在web.xml 中 加入profile.active 这个变量 &lt;context-param&gt; &lt;param-name&gt;profiles.active&lt;/param-name&gt; &lt;param-value&gt;$&#123;profiles.active&#125;&lt;/param-value&gt;&lt;/context-param&gt; 然后applicationContext.xml中就可以应用这个变量了。 &lt;!-- 引入属性文件 --&gt; &lt;bean id=\"propertyConfigurer\" class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\"&gt; &lt;property name=\"systemPropertiesModeName\" value=\"SYSTEM_PROPERTIES_MODE_OVERRIDE\" /&gt; &lt;property name=\"ignoreResourceNotFound\" value=\"true\" /&gt; &lt;property name=\"locations\"&gt; &lt;list&gt; &lt;value&gt;classpath:config/$&#123;profiles.active&#125;/config.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;","tags":[{"name":"maven profile","slug":"maven-profile","permalink":"https://lirawx.me/tags/maven-profile/"}]},{"title":"小程序初探","date":"2017-12-02T00:00:00.000Z","path":"2017/12/wxapp.html","text":"最近研究了一下小程序的开发工具的应用。主要是通过腾讯云上传测试代码和正式代码，主要是集成了很多工具，比较方便。 程序截图 功能介绍功能比较简单，基于脚手架wafer2-quickstart-nodejs抽空业余时间写的一些代码，主要是新闻数据获取，我用node js 爬取的驱动之家的新闻新闻地址为➡️ 这个地址的新闻每天都会更新。很实用，不多也不少，每天差不多40条左右，没什么广告，业内热门新闻都有，有时候还有steam游戏打折推荐，很不错。 主要实现WEUI 文档font awesome 引入moment js 时间格式化promise 风格 API 封装。 几个主要的功能代码贴一下。sql.js 工具类代码，通用var mysql = require(&apos;mysql&apos;)var config = require(&apos;../config&apos;)const moment = require(&apos;moment&apos;)var pool = mysql.createPool(&#123; host: config.mysql.host, user: config.mysql.user, password: config.mysql.pass, database: config.mysql.db&#125;)var query = function (sql, val) &#123; return new Promise((resolve, reject) =&gt; &#123; pool.getConnection((err, connection) =&gt; &#123; if (err) &#123; return resolve(err) &#125; else &#123; connection.query(sql, val, (err, rows) =&gt; &#123; if (err) &#123; reject(err) &#125; else &#123; resolve(rows) &#125; connection.release() &#125;) &#125; &#125;) &#125;)&#125;let insertData = function (n) &#123; let _sql = `INSERT INTO tb_driver_news(id, title, auther, pulish_time, href, imgs_url, content, contentHTML, createAt, updateAt) VALUES (null, &apos;$&#123;n.title&#125;&apos;, &apos;$&#123;n.auther&#125;&apos;, &apos;$&#123;n.publishtime&#125;&apos;, &apos;$&#123;n.href&#125;&apos;, &apos;$&#123;n.imgsUrl&#125;&apos;, &apos;$&#123;n.content&#125;&apos;,&apos;$&#123;n.contentHTML&#125;&apos;, NOW(), NOW());` return query(_sql)&#125;let selectData = function (t) &#123; let re = /^[1-9]\\d&#123;3&#125;-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])$/ if (!re.test(t) || t === undefined || t === null) &#123; t = moment().format(&apos;Y-M-D&apos;) &#125; let _sql = `SELECT * FROM tb_driver_news WHERE DATE_FORMAT(createAt,&apos;%Y-%m-%d&apos;) = &apos;$&#123;t&#125;&apos;;` return query(_sql)&#125;module.exports = &#123; insertData, selectData&#125; util.js 客户端工具类 moment.js 直接官网下moment.min.js 就好了。const moment = require(&apos;moment.js&apos;);const getToday = () =&gt; &#123; return moment(new Date()).format(&apos;Y-M-D&apos;);&#125;const getWeek = date =&gt; &#123; let w = &apos;&apos;; switch (moment(date).format(&apos;E&apos;)) &#123; case &apos;1&apos;: w = &apos;一&apos;; break; case &apos;2&apos;: w = &apos;二&apos;; break; case &apos;3&apos;: w = &apos;三&apos;; break; case &apos;4&apos;: w = &apos;四&apos;; break; case &apos;5&apos;: w = &apos;五&apos;; break; case &apos;6&apos;: w = &apos;六&apos;; break; case &apos;7&apos;: w = &apos;七&apos;; break; &#125; return &apos;星期&apos;+w;&#125;const getYesterDay = () =&gt; &#123; return moment(new Date()).subtract(1, &apos;days&apos;).format(&apos;Y-M-D&apos;);&#125;const getDayBeforeYesterDay = () =&gt; &#123; return moment(new Date()).subtract(2, &apos;days&apos;).format(&apos;Y-M-D&apos;);&#125;const formatTime = date =&gt; &#123; const year = date.getFullYear() const month = date.getMonth() + 1 const day = date.getDate() const hour = date.getHours() const minute = date.getMinutes() const second = date.getSeconds() return [year, month, day].map(formatNumber).join(&apos;/&apos;) + &apos; &apos; + [hour, minute, second].map(formatNumber).join(&apos;:&apos;)&#125;const formatNumber = n =&gt; &#123; n = n.toString() return n[1] ? n : &apos;0&apos; + n&#125;// 显示繁忙提示var showBusy = text =&gt; wx.showToast(&#123; title: text, icon: &apos;loading&apos;, duration: 10000&#125;)// 显示成功提示var showSuccess = text =&gt; wx.showToast(&#123; title: text, icon: &apos;success&apos;&#125;)// 显示失败提示var showModel = (title, content) =&gt; &#123; wx.hideToast(); wx.showModal(&#123; title, content: JSON.stringify(content), showCancel: false &#125;)&#125;module.exports = &#123; formatTime, getToday, getWeek, getYesterDay, getDayBeforeYesterDay, showBusy, showSuccess, showModel &#125; app.wxss里面包含了fontawesome 的图标应用 实现原理就是吧字体文件ttf 转成 base64 格式的代码然后引用就好了我贴一部分具体的拿fontawesome.css替换就好了 下载地址app.wxss@font-face &#123; font-family: &apos;fa&apos;; src: url(data:font/truetype;charset=utf-8;base64,AAEAAAANAIAAAwBQRkZUTXLOMIUAAlXMAAAAHEdERUYAJwKrAAJVrAAAAB5PUy8yiDJ6IwAAAVgAAABgY21hcJ0vdNQAAAw4AAADAmdhc3D//wADAAJVpAAAAAhnbHlmHejPwQAAGdQAAh3kaGVhZAbB4eAAAADcAAAANmhoZWEO .........JkmAAAAAMtPPDAAAAAA01pbLg==) format(&apos;truetype&apos;); font-weight: normal; font-style: normal;&#125;.fa &#123; font-family: &quot;fa&quot; !important; font-size: 16px; -webkit-font-smoothing: antialiased; -webkit-text-stroke-width: 0.2px;&#125;/* makes the font 33% larger relative to the icon container */.fa-lg &#123; font-size: 1.33333333em; line-height: 0.75em; vertical-align: -15%;&#125;.fa-2x &#123; font-size: 2em;&#125;.fa-3x &#123; font-size: 3em;&#125;.fa-4x &#123; font-size: 4em;&#125;.fa-5x &#123; font-size: 5em;&#125;","tags":[{"name":"小程序","slug":"小程序","permalink":"https://lirawx.me/tags/小程序/"}]},{"title":"react webpack2 配置","date":"2017-12-02T00:00:00.000Z","path":"2017/12/11.html","text":"主要分三种实现 webpack 模块管理 webpack 加入文件改动监听，自动编译刷新浏览器 实现热替换 （MHR） 环境 yarn 1.3.2 详细api使用请戳👇 node v8.9.1 webpack2 react sublimet text 3 截图 代码地址链接地址➡️ webpack 模块管理webpack.dev.js const path = require(&apos;path&apos;)const root = __dirnamemodule.exports = &#123; // 入口文件 entry: path.resolve(root, &apos;src/main.js&apos;), // 出口文件 output: &#123; filename: &apos;bundle.js&apos;, path: path.resolve(root, &apos;dist&apos;) &#125;, // loaders module: &#123; rules: [ &#123;test: /\\.jsx?$/, use: [&apos;babel-loader&apos;], exclude: /node_modules/&#125; ] &#125;&#125; .babelrc &#123; &quot;presets&quot;: [ [&quot;es2015&quot;, &#123;&quot;modules&quot;: false&#125;], // webpack 2 本身已支持es6 module &quot;react&quot; ]&#125; 包依赖安装 yarn add react react-domyarn add webpack babel-cli babel-loader babel-preset-es2015 babel-preset-react --dev 另外可以加入 html-webpack-plugin根据teplate.html生成index.htmljs 文件会自动引入模板文件。 最后的 webpack 配置 如下： const path = require(&apos;path&apos;)// 引入html-webpack-pluginconst HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)const root = __dirnamemodule.exports = &#123; // 入口文件 entry: path.resolve(root, &apos;src/main.js&apos;), // 出口文件 output: &#123; filename: &apos;bundle.js&apos;, path: path.resolve(root, &apos;dist&apos;) &#125;, // loaders module: &#123; rules: [ &#123;test: /\\.jsx?$/, use: [&apos;babel-loader&apos;], exclude: /node_modules/&#125; ] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; title: &apos;React Demo&apos;, template: path.resolve(root, &apos;template.html&apos;) &#125;) ]&#125; 加入文件改动监听，自动编译刷新浏览器需要用到 webpack-dev-server 模块管理 安装 yarn add webpack-dev-server --dev webpack.dev.js 更改为 const path = require(&apos;path&apos;)// 引入html-webpack-pluginconst HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)const root = __dirnamemodule.exports = &#123; // 入口文件 entry: [ &apos;webpack-dev-server/client&apos;, path.resolve(root, &apos;src/main.js&apos;) ], output: &#123; filename: &apos;bundle.js&apos;, path: path.resolve(root, &apos;dist&apos;), publicPath: &apos;/&apos; &#125;, // loaders module: &#123; rules: [ &#123;test: /\\.jsx?$/, use: [&apos;babel-loader&apos;], exclude: /node_modules/&#125; ] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; title: &apos;React Demo&apos;, template: path.resolve(root, &apos;template.html&apos;) &#125;) ], devServer: &#123; contentBase: path.resolve(root, &apos;dist&apos;), publicPath: &apos;/&apos;, port: 8080, historyApiFallback: true &#125;&#125; package.json 中的scripts 改为 &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server --config webpack.dev.js&quot;&#125; 实现热替换 （MHR）上面已经实现了改动自动刷新服务器，但是，有时只需要局部更改相应数据，不需要整体更新，这时就需要热替换更新相应的组件。 这里用到了 react-hot-loader 安装 yarn add react-hot-loader --dev webpack.dev.js 如下： const path = require(&apos;path&apos;)const webpack = require(&apos;webpack&apos;)// 引入html-webpack-pluginconst HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)const root = __dirnamemodule.exports = &#123; // 入口文件 entry: [ &apos;react-hot-loader/patch&apos;, // 激活HMR &apos;webpack-dev-server/client&apos;, &apos;webpack/hot/only-dev-server&apos;, path.resolve(root, &apos;src/main.js&apos;) ], output: &#123; filename: &apos;bundle.js&apos;, path: path.resolve(root, &apos;dist&apos;), publicPath: &apos;/&apos; &#125;, // loaders module: &#123; rules: [ &#123;test: /\\.jsx?$/, use: [&apos;babel-loader&apos;], exclude: /node_modules/&#125; ] &#125;, devServer: &#123; hot: true, // 激活服务器的HMR contentBase: path.resolve(root, &apos;dist&apos;), publicPath: &apos;/&apos;, port: 8080, historyApiFallback: true &#125;, plugins: [ new HtmlWebpackPlugin(&#123; title: &apos;React Demo&apos;, template: path.resolve(root, &apos;template.html&apos;) &#125;), new webpack.HotModuleReplacementPlugin(), // 热替换插件 new webpack.NamedModulesPlugin() // 执行热替换时打印模块名字 ]&#125; 假如 热替换组件为 App ，在main.js 中加入相关热替换代码： import React from &apos;react&apos;import ReactDOM from &apos;react-dom&apos;import &#123; AppContainer&#125; from &apos;react-hot-loader&apos;import App from &apos;./App&apos;const render = (App) =&gt; &#123; ReactDOM.render( &lt;AppContainer&gt; &lt;App /&gt; &lt;/AppContainer&gt;, document.getElementById(&apos;app&apos;) )&#125;render(App)if (module.hot) &#123; module.hot.accept(&apos;./App&apos;, () =&gt; render(App))&#125;","tags":[{"name":"react webpack2","slug":"react-webpack2","permalink":"https://lirawx.me/tags/react-webpack2/"}]},{"title":"Spring MVC java config","date":"2017-11-11T10:01:22.000Z","path":"2017/11/spirngmvc-java-config.html","text":"spring MVC java config编程环境java 1.8tomcat 8spring 4.3.12.RELEASEmybatis 3.4.0mybatis-spring 1.3.0 web 配置web.xml 配置&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; java config public class WebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123; @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; return new Class&lt;?&gt;[] &#123; RootConfig.class &#125;; &#125; @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; // 制定配置类 return new Class&lt;?&gt;[] &#123; WebConfig.class &#125;; &#125; @Override protected String[] getServletMappings() &#123; // 讲DispatcherServlet 映射到“/” return new String[] &#123; \"/\" &#125;; &#125; @Override protected Filter[] getServletFilters() &#123; CharacterEncodingFilter characterEncodingFilter = new CharacterEncodingFilter(); characterEncodingFilter.setEncoding(\"UTF-8\"); characterEncodingFilter.setForceEncoding(true);// //shiro// DelegatingFilterProxy delegatingFilterProxy = new DelegatingFilterProxy();// delegatingFilterProxy.setBeanName(\"shiroFilter\"); return new Filter[] &#123; characterEncodingFilter&#125;; &#125; @Override protected void customizeRegistration(ServletRegistration.Dynamic registration) &#123; registration.setInitParameter(\"throwExceptionIfNoHandlerFound\", \"true\"); &#125;&#125; spring 配置xml&lt;!-- 引入属性文件 --&gt; &lt;bean id=\"propertyConfigurer\" class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\"&gt; &lt;property name=\"systemPropertiesModeName\" value=\"SYSTEM_PROPERTIES_MODE_OVERRIDE\" /&gt; &lt;property name=\"ignoreResourceNotFound\" value=\"true\" /&gt; &lt;property name=\"locations\"&gt; &lt;list&gt; &lt;value&gt;classpath:config/config.properties&lt;/value&gt; &lt;value&gt;classpath:config/shiro-config.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;import resource=\"spring/spring-mybatis.xml\"/&gt; java config@Configuration@ComponentScan(basePackages = &#123; \"com\" &#125;, excludeFilters = &#123; @Filter(type = FilterType.ANNOTATION, value = EnableWebMvc.class) &#125;)@PropertySource(value = \"classpath:config.properties\", encoding = \"utf-8\")@EnableAspectJAutoProxy(proxyTargetClass = true)@Import(&#123; MybatisConfig.class &#125;)public class RootConfig &#123;&#125; web MVCxml&lt;mvc:annotation-driven&gt; &lt;!-- json 处理 ie下载提示 --&gt; &lt;mvc:message-converters register-defaults=\"true\"&gt; &lt;ref bean=\"stringHttpMessageConverter\" /&gt; &lt;ref bean=\"fastJsonHttpMessageConverter\" /&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; &lt;!-- 自动扫描(自动注入) --&gt; &lt;context:component-scan base-package=\"com\" /&gt; &lt;!-- cache-period=\"315360000\" --&gt; &lt;mvc:resources mapping=\"/images/**\" location=\"/images/\" /&gt; &lt;mvc:resources mapping=\"/imgs/**\" location=\"/imgs/\" /&gt; &lt;mvc:resources mapping=\"/attachment/**\" location=\"/attachment/\" /&gt; &lt;mvc:resources mapping=\"/css/**\" location=\"/css/\" /&gt; &lt;mvc:resources mapping=\"/js/**\" location=\"/js/\" /&gt; &lt;!-- 自动扫描 标签 --&gt; &lt;bean name=\"springContextUtil\" class=\"com.common.commonutil.runtime.SpringContextUtil\" scope=\"singleton\"&gt;&lt;/bean&gt; &lt;!-- 这个一定得有，注意了，如果其他配置也有需要这个，已经配置了，那不必了 --&gt; &lt;!-- json 处理 ie下载提示 --&gt; &lt;bean id=\"stringHttpMessageConverter\" class=\"org.springframework.http.converter.StringHttpMessageConverter\"&gt; &lt;constructor-arg value=\"UTF-8\" index=\"0\"&gt;&lt;/constructor-arg&gt; &lt;property name=\"supportedMediaTypes\"&gt; &lt;list&gt; &lt;value&gt;text/plain;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; java config/** * web 配置 替代springmvc xml servlet * @author Administrator * */@Configuration@EnableWebMvc@Import(&#123;AspectConfig.class&#125;)@SuppressWarnings(\"deprecation\")public class WebConfig extends WebMvcConfigurerAdapter implements ApplicationContextAware&#123; /** * jsp html view */// @Bean// public ViewResolver viewResolver()&#123;// //jsp html view模板// InternalResourceViewResolver resolver = new InternalResourceViewResolver();// resolver.setPrefix(\"/admin/\");// resolver.setSuffix(\".html\");// resolver.setExposeContextBeansAsAttributes(true);// return resolver;// &#125; //static resources @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry.addResourceHandler(\"/css/**\").addResourceLocations(\"/css/\"); registry.addResourceHandler(\"/img/**\").addResourceLocations(\"/img/\"); registry.addResourceHandler(\"/js/**\").addResourceLocations(\"/js/\"); &#125; @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer)&#123; configurer.enable(); &#125; private ApplicationContext applicationContext; public void setApplicationContext(ApplicationContext applicationContext) &#123; this.applicationContext = applicationContext; &#125;/** * 单一 thymeleafview * @return */ @Bean public ViewResolver viewResolver() &#123; ThymeleafViewResolver resolver = new ThymeleafViewResolver(); resolver.setTemplateEngine(templateEngine()); resolver.setCharacterEncoding(\"UTF-8\"); return resolver; &#125; /** * 多种视图并存 * * @return */// public ContentNegotiatingViewResolver contentNegotiatingViewResolver()&#123;// ContentNegotiatingViewResolver cnv = new ContentNegotiatingViewResolver();// // Thymeleaf// List&lt;ViewResolver&gt; vrs = new ArrayList&lt;ViewResolver&gt;();// ThymeleafViewResolver thymelearfview = new ThymeleafViewResolver();// thymelearfview.setTemplateEngine(templateEngine());// thymelearfview.setCharacterEncoding(\"UTF-8\");// String [] strs = new String[]&#123;\"thy/*\"&#125;;// thymelearfview.setViewNames(strs);// thymelearfview.setOrder(2);// //jsp 视图// InternalResourceViewResolver resolver = new InternalResourceViewResolver();// resolver.setPrefix(\"WEB-INF/\");// resolver.setViewNames(\"jsp/*\");// resolver.setExposeContextBeansAsAttributes(true);// resolver.setOrder(1);// vrs.add(thymelearfview);//// vrs.add(resolver);// cnv.setViewResolvers(vrs);// return cnv;// &#125; @Bean public TemplateEngine templateEngine() &#123; SpringTemplateEngine engine = new SpringTemplateEngine(); engine.setEnableSpringELCompiler(true); engine.setTemplateResolver(templateResolver()); return engine; &#125; private ITemplateResolver templateResolver() &#123; SpringResourceTemplateResolver resolver = new SpringResourceTemplateResolver(); resolver.setApplicationContext(applicationContext); resolver.setPrefix(\"/WEB-INF/thy/\"); resolver.setSuffix(\".html\"); resolver.setTemplateMode(TemplateMode.HTML); return resolver; &#125; /** * velocity * @return */// @Bean// public ViewResolver viewResolver() &#123;//// VelocityLayoutViewResolver bean = new VelocityLayoutViewResolver();// bean.setCache(true);// bean.setPrefix(\"/WEB-INF/views/\");// bean.setLayoutUrl(\"/WEB-INF/layouts/layout.vm\");// bean.setSuffix(\".vm\");// return bean;// &#125;//// @Bean// public VelocityConfigurer velocityConfig() &#123;// VelocityConfigurer velocityConfigurer = new VelocityConfigurer();// velocityConfigurer.setResourceLoaderPath(\"/\");// return velocityConfigurer;// &#125; //定义spring文件上传编码 @Bean public CommonsMultipartResolver multipartResolver() &#123; CommonsMultipartResolver multipartResolver = new CommonsMultipartResolver(); multipartResolver.setDefaultEncoding(\"UTF-8\"); return multipartResolver; &#125; //解析json返回数据 @Bean public StringHttpMessageConverter stringHttpMessageConverter()&#123; StringHttpMessageConverter shmc = new StringHttpMessageConverter(); shmc.setSupportedMediaTypes(Arrays.asList(new MediaType(\"text\", \"plain\", Charset.forName(\"UTF-8\")))); return shmc; &#125; @Bean public HttpMessageConverter&lt;?&gt; fastJsonHttpMessageConverter4()&#123; Feature[] features =&#123;Feature.AllowArbitraryCommas, Feature.AllowUnQuotedFieldNames, Feature.DisableCircularReferenceDetect&#125;; FastJsonHttpMessageConverter4 fjtmc4 = new FastJsonHttpMessageConverter4(); fjtmc4.setSupportedMediaTypes(Arrays.asList(new MediaType(\"text\", \"html\", Charset.forName(\"UTF-8\")))); fjtmc4.setSupportedMediaTypes(Arrays.asList(new MediaType(\"application\", \"json\", Charset.forName(\"UTF-8\")))); FastJsonConfig fjc = new FastJsonConfig(); fjc.setFeatures(features); fjc.setDateFormat(\"yyyy-MM-dd HH:mm:ss\"); fjtmc4.setFastJsonConfig(fjc); return (HttpMessageConverter&lt;?&gt;) fjtmc4; &#125; //json处理 解决ie下载提示 @Override public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; converters.add(stringHttpMessageConverter()); converters.add(fastJsonHttpMessageConverter4()); super.configureMessageConverters(converters); &#125;&#125; mybatis&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configurationPUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;settings&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"false\" /&gt; &lt;setting name=\"logImpl\" value=\"LOG4J\" /&gt; &lt;/settings&gt; &lt;!-- mybatis分页拦截器 --&gt; &lt;plugins&gt; &lt;plugin interceptor=\"com.common.commonutil.pagehelper.PageInterceptor\"&gt;&lt;/plugin&gt; &lt;/plugins&gt;&lt;/configuration&gt; java config@PropertySource(value = \"classpath:config.properties\", encoding = \"utf-8\")@Configurationpublic class MybatisConfig&#123; private Environment environment; @Autowired public void setEnvironment(Environment environment) &#123; this.environment = environment; &#125; @Bean public static PropertySourcesPlaceholderConfigurer propertyConfigInDev() &#123; return new PropertySourcesPlaceholderConfigurer(); &#125; @Bean(name=&#123;\"writeDataSource\"&#125;) public DruidDataSource writeDataSource(Environment env) &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(env.getProperty(\"db.write.driver\")); dataSource.setUrl(env.getProperty(\"db.write.url\")); dataSource.setUsername(env.getProperty(\"db.write.username\")); dataSource.setPassword(env.getProperty(\"db.write.password\")); dataSource.setInitialSize(0); dataSource.setMaxActive(20); dataSource.setMinIdle(0); dataSource.setMaxWait(0); try &#123; dataSource.setFilters(\"stat,log4j,wall\"); &#125; catch (SQLException e) &#123; LoggerUtils.error(getClass(), e.getMessage()); // e.printStackTrace(); &#125; return dataSource; &#125; @Bean(name=&#123;\"readDataSource\"&#125;) public DruidDataSource readDataSource(Environment env) &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(env.getProperty(\"db.read.driver\")); dataSource.setUrl(env.getProperty(\"db.read.url\")); dataSource.setUsername(env.getProperty(\"db.read.username\")); dataSource.setPassword(env.getProperty(\"db.read.password\")); dataSource.setInitialSize(0); dataSource.setMaxActive(20); dataSource.setMinIdle(0); dataSource.setMaxWait(0); try &#123; dataSource.setFilters(\"stat,log4j,wall\"); &#125; catch (SQLException e) &#123; LoggerUtils.error(getClass(), e.getMessage()); // e.printStackTrace(); &#125; return dataSource; &#125; @Bean(name = \"dataSource\") public DynamicDataSource dataSource(@Qualifier(\"readDataSource\") DruidDataSource readDataSource ,@Qualifier(\"writeDataSource\") DruidDataSource writeDataSource) &#123; DynamicDataSource dataSource = new DynamicDataSource(); dataSource.setWriteDataSource(writeDataSource); dataSource.setReadDataSource(readDataSource); return dataSource; &#125; @Bean public SqlSessionFactoryBean sqlSessionFactory(@Qualifier(\"dataSource\") DynamicDataSource dataSource) &#123; SqlSessionFactoryBean sqlSessionFactory = new SqlSessionFactoryBean(); sqlSessionFactory.setDataSource(dataSource); try &#123; PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver(); sqlSessionFactory.setMapperLocations(resolver.getResources(\"classpath*:/mappers/**/*.xml\")); sqlSessionFactory.setFailFast(true); &#125; catch (IOException e) &#123; LoggerUtils.error(getClass(), \"sqlsession\" + e.getMessage()); // e.printStackTrace(); &#125; return sqlSessionFactory; &#125; @Bean public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) &#123; return new SqlSessionTemplate(sqlSessionFactory); &#125; @Bean public MapperScannerConfigurer scannerConfigurer() &#123; MapperScannerConfigurer configurer = new MapperScannerConfigurer(); configurer.setBasePackage(\"com.**.**.mapper\"); return configurer; &#125; @Bean public DataSourceTransactionManager transactionManager(@Qualifier(\"dataSource\") DynamicDataSource dataSource) &#123; DataSourceTransactionManager tsm = new DataSourceTransactionManager(); tsm.setDataSource(dataSource); return tsm; &#125; /** * mybatis 分页插件配置 * @return */ @Bean public PageHelper pageHelper() &#123; LoggerUtils.debug(getClass(), \"MyBatisConfiguration.pageHelper()\"); PageHelper pageHelper = new PageHelper(); Properties p = new Properties(); p.setProperty(\"offsetAsPageNum\", \"true\"); p.setProperty(\"rowBoundsWithCount\", \"true\"); p.setProperty(\"reasonable\", \"true\"); pageHelper.setProperties(p); return pageHelper; &#125; @Bean public DynamicDataSourcePlugin dynamicDataSourcePlugin()&#123; return new DynamicDataSourcePlugin(); &#125;","tags":[{"name":"spring MVC java config","slug":"spring-MVC-java-config","permalink":"https://lirawx.me/tags/spring-MVC-java-config/"}]},{"title":"vue vuex vue-router 项目搭建","date":"2017-11-01T00:00:00.000Z","path":"2017/11/vue-vuex-vue-router.html","text":"环境 node v6.11.2 vue v2.5.2 vue-router v3.0.1 vuex v3.0.1 wepack v3.6.0… 项目描述基于cnode的api 初步搭建vue全家桶的单页应用. 项目结构 主要实现 vue-router的单页导航 主要基于&lt;router-link to=\"\"....&gt; 和$router.push 实现路由的导航 vuex 存储用户登陆信息 vuex配合sessionStorage 存储用户信息,方便管理. ajax请求封装 ajax运用 axios promise 封装. 处理错误信息. 运行截图 github 地址cnode","tags":[{"name":"vue vuex vue-router","slug":"vue-vuex-vue-router","permalink":"https://lirawx.me/tags/vue-vuex-vue-router/"}]},{"title":"ES5 学习笔记","date":"2017-10-22T10:01:22.000Z","path":"2017/10/22/ES5(01).html","text":"Template Strings模板语言魔法糖 // Basic literal string creation`This is a pretty little template string.`// Multiline strings`In ES5 this is not legal.`// Interpolate variable bindingsvar name = \"Bob\", time = \"today\";`Hello $&#123;name&#125;, how are you $&#123;time&#125;?`// Unescaped template stringsString.raw`In ES5 \"\\n\" is a line-feed.` Promises异步编程库 function timeout(duration = 0) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, duration); &#125;)&#125;var p = timeout(1000).then(() =&gt; &#123; return timeout(2000);&#125;).then(() =&gt; &#123; throw new Error(\"hmm\");&#125;).catch(err =&gt; &#123; return Promise.all([timeout(100), timeout(200)]);&#125;) Modules模块化 // lib/math.jsexport function sum(x, y) &#123; return x + y;&#125;export var pi = 3.141593;// app.jsimport * as math from \"lib/math\";console.log(\"2π = \" + math.sum(math.pi, math.pi));","tags":[{"name":"es5 javascript","slug":"es5-javascript","permalink":"https://lirawx.me/tags/es5-javascript/"}]},{"title":"mysql 日期零错误处理","date":"2017-10-13T10:01:22.000Z","path":"2017/10/13/2017-10-13-msyql-zero.html","text":"情景简介当我们从低版本数据库向高版本的数据库转入数据时经常性的会遇到不能为零的错误提示比如5.6 到 5.7. 5.7 默认启用了strict mode,不支持‘0000-00-00：00:00:00’的日期类型的插入添加. 解决方法 1.java 或者其他语言链接时加参数 连接数据库转化为对象出错的解决办法为在数据库连接后面加上参数zeroDateTimeBehavior=convertToNull 这样如果碰到 ‘0000-00-00：00:00:00’的日期类型时，将会转化为null值. 例如: db.jdbcurl=jdbc:mysql://192.168.1.52:3306/db?characterEncoding=UTF-8&amp;zeroDateTimeBehavior=convertToNull 2.针对数据插入数据‘0000-00-00：00:00:00’ 数据本身不接受的解决办法为 1、首先查询出数据库现有的模式 select @@sql_mode; 2、把NO_ZERO_IN_DATE,NO_ZERO_DATE去掉，然后重新设置 SET GLOBAL sql_mode = &apos;ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&apos;","tags":[{"name":"mysql","slug":"mysql","permalink":"https://lirawx.me/tags/mysql/"}]},{"title":"svn 命令行的使用","date":"2017-10-12T10:01:22.000Z","path":"2017/10/12/2017-10-12-svn.html","text":"简介svn 是公司比较正式和熟练的版本控制软件系统.所以熟练使用svn是必要的,win下的话tortiseSVN基本就够了,跟eclipse插件Subversion也很搭.虽然很卡,凑合用把.同时作为一个程序员,不免要在linux下操作svn,本文是svn客户端的使用. 环境centos 7 安装yum install -y subversion 常用命令svn import常用于第一次提交 svn import Armatrue http://192.168.0.249/svn/ninjiaSourceCode/trunk/Armatrue --username=xiaohuang --password=123456 -m &quot;import new project&quot; svn checkoutsvn checkout path（path是服务器上的目录）例如：svn checkout svn://192.168.1.1/pro/domain简写：svn co svn commitsvn commit -m “LogMessage“ [-N] [–no-unlock] PATH (如果选择了保持锁，就使用–no-unlock开关)例如： svn commit -m “add test file for my test“ test.php 简写： svn ci svn clean up可以解除lock状态 svn update更新服务器版本 svn ignore若想创建了一个文件夹，并且把它加入版本控制，但忽略文件夹中的所有文件的内容： svn mkdir spoolsvn propset svn:ignore &apos;*&apos; spoolsvn ci -m &apos;Adding &quot;spool&quot; and ignoring its contents.&apos; 若想创建一个文件夹，但不加入版本控制，即忽略这个文件夹： mkdir spoolsvn propset svn:ignore &apos;spool&apos; .svn ci -m &apos;Ignoring a directory called &quot;spool&quot;.&apos; 若已经创建了文件夹，并加入了版本控制，现在想忽略这个文件夹，但要保持文件夹的内容： svn export spool spool-tmpsvn rm spoolsvn ci -m &apos;Removing inadvertently added directory &quot;spool&quot;.&apos;mv spool-tmp spoolsvn propset svn:ignore &apos;spool&apos; .svn ci -m &apos;Ignoring a directory called &quot;spool&quot;.&apos; svn添加所有新添加的文件svn st | grep &apos;^\\?&apos; | tr &apos;^\\?&apos; &apos; &apos; | sed &apos;s/[ ]*//&apos; | sed &apos;s/[ ]/\\\\ /g&apos; | xargs svn add 或者 svn st | awk &apos;&#123;if ( $1 == &quot;?&quot;) &#123; print $2&#125;&#125;&apos; | xargs svn add","tags":[{"name":"svn","slug":"svn","permalink":"https://lirawx.me/tags/svn/"}]},{"title":"travis ci 持续集成","date":"2017-10-01T16:42:18.000Z","path":"2017/10/01/2017-10-01-travis ci 持续集成.html","text":"事故起因我想再github pages 上发布hexo博客.然后自己又很懒,不想每次都再hexo -g; hexo -d等命令.然后又想再issues上写博客,真的很方便.虽然别人可以自由无线评论,但是世界本来就是开放的,这样也无可厚非. 实现原理travis 可以又nodejs的环境.所有我就打算用nodejs脚本,根据github的api,获取到issues.然后手动下载到./source/_posts目录下.然后通过一系列命令,发布到gh-pages上. 具体实现下载issues的主要js代码.request(options, function (error, response, body) &#123; if (!error &amp;&amp; response.statusCode == 200) &#123; var data = JSON.parse(body); for (iss in data)&#123; if(data[iss].state==&apos;open&apos;)&#123; var article = &apos;&apos;; article+=&apos;---\\n&apos;; article+=&apos;layout: post\\n&apos;; article+=&apos;tags: &apos;+getTags(data[iss].labels)+&apos;\\n&apos;; article+=&apos;title: &apos;+data[iss].title+&apos;\\n&apos;; article+=&apos;date: &apos;+data[iss].created_at+&apos;\\n&apos;; article+=&apos;---\\n\\n&apos;; article+=data[iss].body; var fN = getFileName(data[iss].created_at,data[iss].title); var filePath =calFilePath(data[iss].created_at,fN); if(!fsExistsSync(filePath))&#123; mkdirsSync(filePath); var out = fs.createWriteStream(filePath+fN,&#123;encoding:&apos;utf-8&apos;,&apos;flag&apos;: &apos;a&apos;&#125;); out.write(article); out.end(); console.log(fN+&apos;----- 已经写入&apos;); &#125;else if(!fsExistsSync(filePath+fN))&#123; var outs = fs.createWriteStream(filePath+fN,&#123;encoding:&apos;utf-8&apos;,&apos;flag&apos;: &apos;a&apos;&#125;); outs.write(article); outs.end(); console.log(fN+&apos;----- 已经写入&apos;); &#125;else&#123; console.log(fN+&apos;----- 已经存在&apos;); &#125; &#125; &#125; &#125;&#125;); 其中request的option 如下 var options = &#123; url: &apos;https://api.github.com/repos/lirawx/mirror/issues&apos;, headers: &#123; &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.79 Safari/537.36&apos;, &apos;Host&apos;:&apos;api.github.com&apos;, &apos;DNT&apos;:&apos;1&apos;, &apos;If-None-Match&apos;:&apos;W/&quot;074817d16634c58050520f5c85690abf&quot;&apos;, &apos;Upgrade-Insecure-Requests&apos;:&apos;1&apos;, &apos;Cache-Control&apos;:&apos;0&apos; &#125;&#125;; 可以参考,具体请前往https://developer.github.com/v3/repos/ travis ci 配置文件language: node_jsnode_js: stable# S: Build Lifecycleinstall: - npm install#before_script: # - npm install -g gulp#node genmd.jsscript: - node genmd.js - hexo gafter_script: - cd ./public - git init - git config user.name &quot;xxxx&quot; - git config user.email &quot;xxxx@xxxx.xxxx&quot; - git add . - git commit -a -m &quot;Update posts&quot; - git push --force --quiet &quot;https://$&#123;GH_TOKEN&#125;@$&#123;GH_REF&#125;&quot; master:xxxxx - cd .. - git init - git config user.name &quot;xxxxx&quot; - git config user.email &quot;xxxx@xxxx.com&quot; - git add . - git commit -a -m &quot;Update source&quot; - git push --force --quiet &quot;https://$&#123;GH_TOKEN&#125;@$&#123;GH_REF&#125;&quot; master:xxxxx# E: Build LifeCyclebranches: only: - xxxxxenv: global: - GH_REF: github.com/xxxx/xxxx.git 注意我是一个git仓库,两个不同的分支,一个source分支, 一个master分支,source方源代码,master放gh-pages.","tags":[{"name":"gh-pages git nodejs Travis CI","slug":"gh-pages-git-nodejs-Travis-CI","permalink":"https://lirawx.me/tags/gh-pages-git-nodejs-Travis-CI/"}]},{"title":"centos 下php拓展的安装","date":"2017-10-01T10:01:22.000Z","path":"2017/10/php-extension.html","text":"环境配置php 安装目录 /usr/local/phpphp 源码目录 /home/xxx/php-5.6.22OS centos 7 phpize 编译安装拓展phpize 需要进入php源码 cd /home/xxx/php-5.6.22/ext/openssl 然后运行/usr/local/php/bin/phpize 此时会生成configure文件 然后执行安装配置./configure --with-php-config=/usr/local/php/bin/php-config --with-openssl 这边注意php-config位置路径 最后makemake install 验证是否成功php -m","tags":[{"name":"centos php openssl","slug":"centos-php-openssl","permalink":"https://lirawx.me/tags/centos-php-openssl/"}]},{"title":"记阿里云上线php项目","date":"2017-10-01T10:01:22.000Z","path":"2017/10/01.html","text":"搭建环境阿里云ESC2G 4Mcentos 7 搭建lamp这里使用脚本编译安装 安装LNMP执行：wget -c http://soft.vpser.net/lnmp/lnmp1.3-full.tar.gz &amp;&amp; tar zxf lnmp1.3-full.tar.gz &amp;&amp; cd lnmp1.3-full &amp;&amp; ./install.sh lamp 默认安装lnmp可不写，如需要安装LNMPA或LAMP，将./install.sh 后面的参数替换为lnmpa或lnmp即可。 安装选项因项目需要其中安装选项: 1.设置mysql密码 安装InnoDB 最好安装 3.Mysql 版本选择5.6 4.php选择5.6.22 5.Memory Allocator,我没有安装 6.Administrator Email 选填 7.apache 选2.2 然后脚本会自动运行. 运行结果如果显示 Nginx: OK，MySQL: OK，PHP: OK那么就成功了.最后脚本默认会修改防火墙,我这边貌似会有问题.我自己把它的删掉了,替换成我自己的. /etc/sysconfig/iptables如下:INPUT DROP [5:1411]:FORWARD ACCEPT [0:0]:OUTPUT ACCEPT [72:10550]-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT-A INPUT -i lo -j ACCEPT-A INPUT -p tcp -m tcp --dport 22 -j ACCEPT-A INPUT -p tcp -m tcp --dport 80 -j ACCEPT-A INPUT -p tcp -m tcp --dport 3306 -j ACCEPT-A INPUT -p icmp -m icmp --icmp-type 8 -j ACCEPT-A INPUT -m state --state ESTABLISHED -j ACCEPT-A INPUT -p tcp -m tcp --dport 6379 -j ACCEPT-A INPUT -p tcp -m tcp --dport 3690 -j ACCEPT 最后的最后这个最重要的一步,我就是这一步没有重视,导致我重新装了一遍.头的大了. 1.项目需要安装一些php拓展 将目录权限改为wwwchown www:www -R /path/to/dir 对网站目录进行权限设置","tags":[{"name":"centos lamp cms","slug":"centos-lamp-cms","permalink":"https://lirawx.me/tags/centos-lamp-cms/"}]},{"title":"java SSM框架的搭建","date":"2017-08-05T13:27:50.000Z","path":"2017/08/05/2017-08-05-java SSM框架的搭建.html","text":"目录结构:├─src│ │ applicationContext.xml│ │ jdbc.properties│ │ springmvc.xml│ │ sqlMapConfig.xml│ │ │ ├─controller│ │ UserController.java│ │ │ ├─mapper│ │ UserMapper.java│ │ │ ├─pojo│ │ User.java│ │ UserMapper.xml│ │ │ └─service│ UserService.java│ UserServiceImpl.java│ └─WebContent │ index.jsp │ ├─META-INF │ MANIFEST.MF │ └─WEB-INF │ userList.jsp │ web.xml │ └─lib aopalliance-1.0.jar asm-3.3.1.jar c3p0-0.9.0.jar cglib-2.2.2.jar com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar commons-fileupload-1.2.2.jar commons-io-2.0.1.jar commons-logging-1.1.1.jar ehcache-core-2.6.5.jar javassist-3.17.1-GA.jar jstl-1.2.jar junit-4.9.jar log4j-1.2.17.jar mybatis-3.2.2.jar mybatis-ehcache-1.0.2.jar mybatis-spring-1.2.0.jar mysql-connector-java-5.1.28-bin.jar ojdbc6-11.1.0.7.0.jar slf4j-api-1.7.5.jar slf4j-log4j12-1.7.5.jar spring-aop-3.2.3.RELEASE.jar spring-aspects-3.2.3.RELEASE.jar spring-beans-3.2.3.RELEASE.jar spring-context-3.2.3.RELEASE.jar spring-context-support-3.2.3.RELEASE.jar spring-core-3.2.3.RELEASE.jar spring-expression-3.2.3.RELEASE.jar spring-jdbc-3.2.3.RELEASE.jar spring-test-3.2.3.RELEASE.jar spring-tx-3.2.3.RELEASE.jar spring-web-3.2.3.RELEASE.jar spring-webmvc-3.2.3.RELEASE.jar 主要配置文件为: sqlMapConfig.xml mybatis配置 springmvc.xml springMVC配置 applicationContext.xml spring容器配置 jdbc.properties 数据相关配置 当然为了调试方便,可以加入log4j配置,输出debug信息log4j.properties log4j.rootLogger=DEBUG, Console#Consolelog4j.appender.Console=org.apache.log4j.ConsoleAppenderlog4j.appender.Console.layout=org.apache.log4j.PatternLayoutlog4j.appender.Console.layout.ConversionPattern=%d [%t] %-5p [%c] - %m%nlog4j.logger.java.sql.ResultSet=INFOlog4j.logger.org.apache=INFOlog4j.logger.java.sql.Connection=DEBUGlog4j.logger.java.sql.Statement=DEBUGlog4j.logger.java.sql.PreparedStatement=DEBUG","tags":[{"name":"Mybatis Spring SpringMVC SSM","slug":"Mybatis-Spring-SpringMVC-SSM","permalink":"https://lirawx.me/tags/Mybatis-Spring-SpringMVC-SSM/"}]},{"title":"Ubuntu使用dnsmasq作本地DNS缓存","date":"2017-07-23T02:06:56.000Z","path":"2017/07/23/2017-07-23-Ubuntu使用dnsmasq作本地DNS缓存.html","text":"使用dnsmasq解决dns劫持，dns污染等问题 安装sudo apt-get install dnsmasq 配置修改/etc/resolv.conf文件sudo vim /etc/resolv.conf 将原有的内容全部注释，然后在第一行写上nameserver 127.0.0.1 在/etc目录下新建resolv.dnsmasq文件#localnameserver 127.0.0.1#pbulic+nameserver 119.29.29.29#v2exnameserver 178.79.131.110#alibabanameserver 223.5.5.5#onednsnameserver 112.124.47.27#dnspod dns+nameserver 182.254.116.116#114nameserver 114.114.114.114#google2nameserver 8.8.4.4 编辑“/etc/dnsmasq.conf”文件sudo gedit /etc/dnsmasq.conf 将resolv-file=放开注释resolv-file=/etc/resolv.dnsmasq 编辑 /etc/dhcp/dhclient.confsudo vim /etc/dhcp3/dhclient.conf 找到下面这一项 #prepend domain-name-servers 127.0.0.1将前面的“#”删除。这么做的目的是为了在使用自动连接时，能在/etc/resolv.conf文件的第一行添加上“nameserver 127.0.0.1”，这样，dns缓存依然有效。 编辑 etc/default/dnsmasqsudo vim /etc/default/dnsmasq 找到IGNORE_RESOLVCONF=yes，这一条要删除注释，删掉#号 重启服务sudo service dnsmasq restart 测试结果:dig google.com 两次返回结果的时间不一样，第二次一般是0ms；多试几个网址，证明成功了。 测试环境ubuntu 16.04.Raspberry Pi 2 B+","tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://lirawx.me/tags/ubuntu/"}]},{"title":"初爱","date":"2017-07-05T05:13:30.000Z","path":"2017/07/05/2017-07-05-初爱.html","text":"阶前初见，也似重逢。 粉罗裙，青丝绾， 眉眼情浓， 羞脸粉红生。 长街长，短亭短， 细语呢哝娇做嗔， 膝枕春风稍歇。 梦呓酒醒空屏， 飞雨沾湿罗衣。 2016-04-20","tags":[{"name":"2B青年 poem 文艺","slug":"2B青年-poem-文艺","permalink":"https://lirawx.me/tags/2B青年-poem-文艺/"}]},{"title":"关山月","date":"2017-07-05T05:12:16.000Z","path":"2017/07/05/2017-07-05-关山月.html","text":"去年此门中， 庭榭旧时， 春光三月老， 人面何处？ 一时蝶儿舞， 尽付深情， 挽袖荷花香， 半塘婷婷， 信步闲庭晚， 鸣婵炎炎， 将心与你心， 盈盈笑语， 几多情许卿？ 怎堪回首， 别时敬亭山， 《关山月》同。 2016-03-13","tags":[{"name":"2B青年 poem 文艺","slug":"2B青年-poem-文艺","permalink":"https://lirawx.me/tags/2B青年-poem-文艺/"}]},{"title":"雪中歌","date":"2017-07-05T05:11:05.000Z","path":"2017/07/05/2017-07-05-雪中歌.html","text":"雪一场，梦呓回，听歌几时，欲听还休，欲听还休，再从头，列表循环，又一年，人在，情在，有歌有诗，有美酒，一切都是最好的安排。 2016-01-14","tags":[{"name":"2B青年 poem 文艺","slug":"2B青年-poem-文艺","permalink":"https://lirawx.me/tags/2B青年-poem-文艺/"}]},{"title":"对未来的思考","date":"2017-07-05T05:10:32.000Z","path":"2017/07/05/2017-07-05-对未来的思考.html","text":"怪我多喝一包咖啡，到现在都没有睡着，想了很多，很少有这时候独自思考这么多了，或许不曾孤独如此良久。我再想以后我到底会怎么样，有什么爱好，有什么工作，又怎么样过好自己的生活，说不定单身一直，也说不定已经携伊人的手了。仔细的回想了以前的以前，久到小学可能，一直喜欢笛子啊，之类的，特别中意武侠，手持一支笛子，背负一把长剑，帅气。可能是自己身为中国人深深的继承了中国古老的传统也不一定。或许我以后应该学着吹下笛子，小时候直到现在都不知道自己喜欢什么，会做什么，很多都是凭感觉，觉得挺好就挺好，太过随意了现在觉得。太过飘忽不定，我觉得起码现在我应该要确定以及肯定一下自己以后的发展道路了。或许是分手之后长长的空虚寂寞区间，让我也反思了许多。身在21世纪，我却许多次想摆脱这个浮华的世纪带快我的脚步，拒绝微信，拒绝qq，拒绝淘宝之类过激的举动，现在一一妥协，慢慢融入自己的生活，当然问题当然不是变与不变，与加速度一样，身在这个社会怎么可能逃过物理法则。我想说的是这些过快的浮华和过多的诱惑导致我如今不知道该如何是好，一路走来，磕磕绊绊，迷雾重重，会掩盖本来的面目。想来我已经谈了三次主要的恋爱，第一次记住了一个名字，第二次记住了一个qq号，第三次记住了一个电话号码，三次都不能释怀，三次让我也成长了不少。曾经看过读者，记得有一篇文章写，幸福需要等，不要急着去寻找。三次我都以为是上天给我的暗示，我成功的把握住了，期间我也体会到了什么事爱，爱一个人的感觉无论隔着多远，多久，心总是充满热量，激动愉悦，面对所爱的人，那一刻你觉得世界那么美好，美好到今生只为遇见你。然而第二个女友问我：当激情褪去，你还会爱她么？我竟然无言以对，或许只是头脑里激素的一阵悸动，分泌失调。我这样逃避自己和她。我意识到自己善变到了精神都不正常的地步，经常强迫自己还有别人跟自己头脑里的印象重合，每个人都必须和自己投影是一致的，不一致要修正，感觉自己就是上帝一样，谁都是有罪的，都必须向自己赎罪。所以我要告诉自己要保持谦卑，要保持好奇心，要懂得尊敬，要保持希望，要永远乐观，还要一直学习新的东西，最后最重要的要坚持下去。我觉得父母给我最好的教育就是没有限制我的可能性，我也表现的很懂事，当然现在远在家外，我也很少联系他们，但是我知道我是爱他们的，家庭给我最大的最好的就是要读书，我一直保持着对读书的渴望，不读书总会有一种莫名的愧疚感。我觉得这一生都无法改变这一习惯。这一切都来自我的家庭教育。上高中之前可以说是为父母他们读书，那么上大学必须要为自己读书了，大一我确定是为自己读书，尝试了很多不同的东西，然而还是被自己的原则全都否决了，退掉所有社团，推掉所有的责任，一个人独自的玩耍，导致大二被大学上了一年。大三我觉得我要吧大学上一遍才行。我想了想自己的计划，我想看书时必要的，其次还得练字，行书吧，楷书已经不适合我了。保留自己文艺气息，保持自己的审美。大学毕业不要马上工作，我想去外面走走，见见除开景区以外的世界。比如台湾，比如苏州，比如日本。可以打工换食宿在国内，其他的就只能攒钱了。我想以后要开一家不一样的书店，可以加上现代的科技，互联网之类的元素。先想到这里吧。 2015-10-25","tags":[{"name":"日记","slug":"日记","permalink":"https://lirawx.me/tags/日记/"}]},{"title":"谁说的青春无悔","date":"2017-07-05T05:09:48.000Z","path":"2017/07/05/2017-07-05-谁说的青春无悔.html","text":"谁说的青春无悔，我怎么天天都在回望昨日一往情深，不懂什么是爱，现在已经麻木了，何人还爱，何人敢爱，又有谁来爱我。口口声声不悔不回头，渐渐的丢失了底线，然而周围已经没有了可以将心托付的人了，以前可能还有，暧昧多于友谊，然而只能是友谊，不懂为什么她答应又拒绝，或许她比我懂得多，那时我竟然不懂，不明白，原因，太多话没有说明，太多情没有诉尽，太多人还不了债。想来这便是人生？我不懂，我也不知道我怎么去选择，我想让时间划过，但我又想阻延时间，却抓不住，时间在风中溜走。或许我便是矛盾的一生，我期待一个英雄驾着云彩，携我出周身荆棘缠绕，世界一片光明。 2015-10-20","tags":[{"name":"日记","slug":"日记","permalink":"https://lirawx.me/tags/日记/"}]},{"title":"江上有感","date":"2017-07-05T05:08:59.000Z","path":"2017/07/05/2017-07-05-江上有感.html","text":"江岸郎情，前朝栏杆，不能拍，河堤妾意，妖娆柳腰，不堪抚，余辉仍在，故人已远，不曾想，晚风轻抚，多情离别，不甚伤。","tags":[{"name":"2B青年 poem 文艺","slug":"2B青年-poem-文艺","permalink":"https://lirawx.me/tags/2B青年-poem-文艺/"}]},{"title":"生活，需要一些仪式感","date":"2017-07-05T05:07:31.000Z","path":"2017/07/05/2017-07-05-生活，需要一些仪式感.html","text":"最近读了一篇文章，题目是生活，需要一些仪式感我引用一下特有感觉的话： 我向来觉得生活是需要一些仪式感的，这跟矫情无关，而是关于你对生活的热爱，对幸福的敏感，乃至有时候它是一种结束，也是一种开始。 今天的中国人的生活方式似乎少了一些情趣，生活节奏越来越匆忙，生命中越来越缺乏仪式感，而没有仪式感，人生就不庄严，心就不安静。 人人都爱蒂凡尼的早餐，可是却鲜少有人扭头看看自己在生活里，仪式感有多么匮乏。 我仔细的将这些句子在口舌咽喉之间来回可以说是像牛一样反刍，一字一句，我虔诚的像基督徒一样，我认为之前我有罪，没有一丝一毫的仪式感，感到空虚，之前的生活突然觉得没有任何意义，我感到莫大的罪孽，我深深的忏悔，我告诫我自己，要给自己一点点的仪式感，如同刷牙洗脸一样将仪式终身进行下去。 我重拾咖啡，将咖啡放入马克杯，再倒入沸水，一切都是那样的充满敬意，神圣无犯，我知道，这是一种仪式，未来我每天都要进行的仪式。我的心在陶瓷勺搅拌之中随着咖啡粉末融化了，那一刻我从心底里觉得我得到了救赎。像极了肖生克越狱成功后的喜悦。 我不能劝导所有人都要喝咖啡，或者喝茶。我想说的是我同意作者的看法，我遵循仪式，我保持我对仪式的虔诚，坚定我的信仰，我以此来慰借我的罪恶灵魂，一杯咖啡喝完，世间那么的美好。","tags":[{"name":"日记 读书笔记","slug":"日记-读书笔记","permalink":"https://lirawx.me/tags/日记-读书笔记/"}]},{"title":"2015-09-08-反思","date":"2017-07-05T05:06:45.000Z","path":"2017/07/05/2017-07-05-2015-09-08-反思.html","text":"突然觉得有必要找一个地方写写，想想，说说，无关他人，只是自己，不悲伤，不欢喜，只是静静的谈谈自己。以前说过总有一个时候一个人会回过头来看看身后，身后的脚印也好，石头磕绊也好，必须有一个时辰拿来检讨自己。或许他人不知道，但是自己，自己的良善会知道。必须要承认自己的过错，比如很容易激动，听不下去别人的言语，尤其是自己不喜欢，不感兴趣，不符合自己的价值观，针对自己的等等。还比如自己现在的随意，满不在乎的样子，其实我也不知道自己以后会在意什么，但是，我觉得这个状态持续下去不太好。听别人的故事，会流着自己的泪，那么这个泪是否有一部分是为自己而流的呢。很多时候告诉自己不后悔，其实经常会回想自己与她人的点点滴滴。医生中总有那么一个人，会给你不一样的体验，终生难忘。尽管不是时时刻刻，但是几乎每天空下来的时候总会无端想起，不知道这是否是后悔的一种表现呢，可是依然要表现出不在乎的样子。放下就会好过许多，真的是这样的放下么？真的就这样么？","tags":[{"name":"日记","slug":"日记","permalink":"https://lirawx.me/tags/日记/"}]},{"title":"python之pyenv版本控制","date":"2017-07-05T05:05:46.000Z","path":"2017/07/05/2017-07-05-python之pyenv版本控制.html","text":"当需要多个python共存时，pyenv提供了解决知道 #####安装pyenv git clone git://github.com/yyuu/pyenv.git ~/.pyenvecho &apos;export PYENV_ROOT=&quot;$HOME/.pyenv&quot;&apos; &gt;&gt; ~/.bashrcecho &apos;export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;&apos; &gt;&gt; ~/.bashrcecho &apos;eval &quot;$(pyenv init -)&quot;&apos; &gt;&gt; ~/.bashrcexec $SHELL -l #####用pyenv安装python 查看可安装的版本 pyenv install --list #####安装指定版本(3.4.0为例) pyenv install 3.4.0 -v #####安装之后要对数据库进行更新 pyenv rehash #####设置全局python版本 pyenv global 3.4.0","tags":[{"name":"python","slug":"python","permalink":"https://lirawx.me/tags/python/"}]},{"title":"git 安装与使用","date":"2017-07-05T05:04:34.000Z","path":"2017/07/05/2017-07-05-git 安装与使用.html","text":"###一、git基本环境配置 1.首先去www.github.com上注册帐号 2.本机安装git. sudo apt-get install git 3.给本机注册SSH，请移步https://help.github.com/articles/generating-ssh-keys，注册SSH后就默认可以在本机上传代码之类，不用在输入用户名密码… 4.配置Git的配置文件，username和email git config –global user.name “your name” //配置用户名 git config –global user.email “your email” //配置email配置这个每次commit都会通过email去关联github账户 ###二、git基本命令 1.git clone 命令将远程的Git版本库在本地克隆一份，然后就可以用git对该目录下的文件进行版本控制。并且此时会默认生成一个文件夹，文件夹名字是远程仓库名字，cd进去之后，git remote -v发现存在远程仓库，其地址是clone的地址，名字是orgin。比如 (git clone git://github.com/1292765944/ACM.git) 或者 (git clone git@github.com:1292765944/ACM.git)但不要用https协议 2.git init 你可以在本地创建了一个工作目录，然后进入这个目录，使用’git init’命令进行初始化，那么git以后就会对该目录下的文件进行版本控制。 这个命令应用比较简单，先cd到目标文件夹，然后git init即可。 3.git remote 通过这个命令我们可以建立和远程仓库的联系。 比如 git remote add origin git@github.com:1292765944/ACM.git 我们就把git@github.com:1292765944/ACM.git这个远程仓库取了origin别名，以后我们再访问的时候可以直接使用别名。 git remote -v 查看远程仓库 git remote rm [name] 删除远程仓库 git pull [remoteName] [localBranchName]拉取远程仓库。比如git pull origin master git push [remoteName] [localBranchName]更新远程仓库，注意在更新之前要先pul。比如git push origin master 4.git add 该命令当前更改或者新增的文件加入到本地仓库中 git add 后面可以加文件名/目录，还有一中写法git add .会自动判断添加哪些文件然后把这个添加提交到本地的仓库 5.git rm 该命令删除本地仓库中的一些文件。git rm 后面可以直接接文件名，但要删除目录时，要加-r 6.git commit 提交你之前做的rm和add操作并必须要提交附加信息。比如 git commit -m “acm_template” ###三、使用git从本地上传github举例 第一步： 进入要所要上传文件的目录输入命令 “git init”第二步： 创建一个远程仓库origin，使用命令 “git remote add origin git@github.com:1292765944/ACM.git”，其中1292765944是你的GitHub的用户名，ACM是你要上传到GitHub的仓库第三步：比如你要添加一个文件xxx到本地仓库，使用命令 “git add xxx”，可以使用“git add .”自动判断添加哪些文件，然后把这个添加提交到本地的仓库，使用命令 ”git commit -m ”说明这次的提交“，最后把本地仓库origin提交到远程的GitHub仓库，使用命令 ”git push origin master“","tags":[{"name":"git","slug":"git","permalink":"https://lirawx.me/tags/git/"}]},{"title":"基于 Promise 的 HTTP 请求客户端，axios","date":"2017-07-05T05:03:27.000Z","path":"2017/07/05/2017-07-05-基于 Promise 的 HTTP 请求客户端，axios.html","text":"基于 Promise 的 HTTP 请求客户端，可同时在浏览器和 node.js 中使用 功能特性 在浏览器中发送 XMLHttpRequests 请求 在 node.js 中发送 http请求 支持 Promise API 拦截请求和响应 转换请求和响应数据 自动转换 JSON 数据 客户端支持保护安全免受 XSRF 攻击浏览器支持 安装使用 bower:$ bower install axios 使用 npm:$ npm install axios 例子发送一个 GET 请求// Make a request for a user with a given IDaxios.get(&apos;/user?ID=12345&apos;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (response) &#123; console.log(response); &#125;);// Optionally the request above could also be done asaxios.get(&apos;/user&apos;, &#123; params: &#123; ID: 12345 &#125; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (response) &#123; console.log(response); &#125;); 发送一个 POST 请求axios.post(&apos;/user&apos;, &#123; firstName: &apos;Fred&apos;, lastName: &apos;Flintstone&apos; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (response) &#123; console.log(response); &#125;); 发送多个并发请求function getUserAccount() &#123; return axios.get(&apos;/user/12345&apos;);&#125;function getUserPermissions() &#123; return axios.get(&apos;/user/12345/permissions&apos;);&#125;axios.all([getUserAccount(), getUserPermissions()]) .then(axios.spread(function (acct, perms) &#123; // Both requests are now complete &#125;));","tags":[{"name":"axios javascript nodejs promise","slug":"axios-javascript-nodejs-promise","permalink":"https://lirawx.me/tags/axios-javascript-nodejs-promise/"}]},{"title":"前端开发，从草根到英雄(总结)","date":"2017-07-05T05:02:13.000Z","path":"2017/07/05/2017-07-05-前端开发，从草根到英雄(总结).html","text":"文章信息：原文： zero to front-end hero From Zero to Front-end Hero (Part 2) 作者：@Jonathan Z. White 翻译： 前端开发，从草根到英雄（第一部分） 前端开发，从草根到英雄（第二部分） 译者：jieniu 总结HTML CSS基础练习工具 CodePen Dribbble 练习使用html，css，包裹google字体的api和google字体的css技巧，当然还有排版。要将注意力放在html，css在一起时如何工作的。然后再dribble这个网站上寻找灵感，在codepen上编写代码。 要点 语义标记 css命名约定 css重置 跨浏览器支持 css预处理器和后处理器 网格系统和响应式 最后要保持更新，从一个又一个例子中学习。 JavaScript基本知识语言 语法和类型 控制流河错误处理 循环和遍历 函数 交互文档对象模型（DOM） 什么是DOM？ 如何查询元素？ 如何添加事件监听者？ 如何合适的改变DOM节点属性？ 检查调试JavaScript 进阶知识语言 强化原型 作用域 闭包 事件循环 事件通知 请求、调用和绑定 回调和承诺 变量及函数挂起 Currying Imperative vs. DeclarativeJavaScript和DOM如何交互，有两种方法：imperative和declarative，一方面，declarative程序专注于what，另一方面，imperative程序专注于how。Jquery是imperative方法，然后才是Angular和React库declarative方法 Ajax新的浏览器请求标准是Fetch jQueryjQuery不是唯一的imperative DOM操作解决方案，PlainJS和You Might Not Need jQuery是两个很好的资源，他们会告诉你和jQuery一样的频繁使用的JavaScript函数。 ES5 vs. ES6有必要知道你今天看到的应用，要么使用ES5，要么使用ES6。ES5，ES6，ES2016，ES.Next: JavaScript版本到底怎么了和Dan Wahlins的ES6入门——下一代JavaScript是很好的ES6介绍。接着你可以在ES6功能列表查看ES5到ES6的变化。如果你还想了解更多，去Github代码库获得更多ES6功能信息。 JavaScript框架Angular，React + Flux，Ember，Aurelia，Vue，和Meteor。你不需要学习所有的框架，选一个学习即可，不要追赶框架的潮流，取而代之的是，你需要理解框架程序底下的原则和哲学。 架构模型MVC MVVM 与其让HTML保留应用状态，还不如用一个JavaScript对象——通常被称为Model——来存储状态。 设计模式 装饰者模式 工厂模式 单件模式 Revealing module 外观模式 观察者模式 AngularJSAngularJS是一个JavaScript MVC框架，有时也是一个MVVM框架，它由google维护，并在2010年初次发布时给JavaScript社区带来了一场风暴 React + FluxAngular很好解决了程序员在构建复杂系统时所面对的问题，另一个流行的工具是React，它是一个创建用户接口的库，你可以把它想象成MVC中的V。由于React只是一个库，所以它会经常伴随着一个框架Flux 风格指南JavaScript风格指南是一组代码规范，它会帮助你设计具有可读性和可维护性高的代码。 AirBnB的编码规范 常用的JavaScript原则 Node编码规范 MDN编码规范 编码基础我已经无法形容读好代码给我带来的帮助到底有多大，一旦当你想读新的好代码时，可以上Github上找 Lodash Underscore Babel Ghost NodeBB KeystoneJS 许多时候，人在做，天在看。","tags":[{"name":"css html javascript","slug":"css-html-javascript","permalink":"https://lirawx.me/tags/css-html-javascript/"}]},{"title":"Webpack 入门","date":"2017-07-05T05:00:27.000Z","path":"2017/07/05/2017-07-05-Webpack 入门.html","text":"Webpack 是一个前端资源加载/打包工具。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。 打包jsapp/runoob1.js 文件document.write(require(&quot;./runoob2.js&quot;)); webpack runoob1.js bundle.js webpack 根据模块的依赖关系进行静态分析，这些文件(模块)会被包含到 bundle.js 文件中。Webpack 会给每个模块分配一个唯一的 id 并通过这个 id 索引和访问模块。 在页面启动时，会先执行 runoob1.js 中的代码，其它模块会在运行 require 的时候再执行。 LOADERWebpack 本身只能处理 JavaScript 模块，如果要处理其他类型的文件，就需要使用 loader 进行转换。所以如果我们需要在应用中添加 css 文件，就需要使用到 css-loader 和 style-loader，他们做两件不同的事情，css-loader 会遍历 CSS 文件，然后找到 url() 表达式然后处理他们，style-loader 会把原来的 CSS 代码插入页面中的一个 style 标签中。 app/runoob1.js 文件require(&quot;!style!css!./style.css&quot;);document.write(require(&quot;./runoob2.js&quot;)); require CSS 文件的时候都要写 loader 前缀 !style!css!，当然我们可以根据模块类型（扩展名）来自动绑定需要的 loader。 将 runoob1.js 中的 require(“!style!css!./style.css”) 修改为 require(“./style.css”) ：app/runoob1.js 文件require(&quot;./style.css&quot;);document.write(require(&quot;./runoob2.js&quot;)); 然后执行：webpack runoob1.js bundle.js --module-bind &apos;css=style!css&apos; 配置文件我们可以将一些编译选项放在配置文件中，以便于统一管理：创建 webpack.config.js 文件，代码如下所示：app/webpack.config.js 文件module.exports = &#123; entry: &quot;./runoob1.js&quot;, output: &#123; path: __dirname, filename: &quot;bundle.js&quot; &#125;, module: &#123; loaders: [ &#123; test: /\\.css$/, loader: &quot;style!css&quot; &#125; ] &#125;&#125;; 接下来我们只需要执行 webpack 命令即可生成 bundle.js 文件。webpack 命令执行后，会默认载入当前目录的 webpack.config.js 文件。 插件插件在 webpack 的配置信息 plugins 选项中指定，用于完成一些 loader 不能完成的工。webpack 自带一些插件，你可以可以通过 cnpm 安装一些插件。使用内置插件需要通过以下命令来安装：cnpm install webpack –save-dev比如我们可以安装内置的 BannerPlugin 插件，用于在文件头部输出一些注释信息。修改 webpack.config.js，代码如下：app/webpack.config.js 文件var webpack=require(&apos;webpack&apos;);module.exports = &#123; entry: &quot;./runoob1.js&quot;, output: &#123; path: __dirname, filename: &quot;bundle.js&quot; &#125;, module: &#123; loaders: [ &#123; test: /\\.css$/, loader: &quot;style!css&quot; &#125; ] &#125;, plugins:[ new webpack.BannerPlugin(&apos;菜鸟教程 webpack 实例&apos;) ]&#125;; 然后运行 webpack，打开 bundle.js，可以看到文件头部出现了我们指定的注释信息。 开发环境当项目逐渐变大，webpack 的编译时间会变长，可以通过参数让编译的输出内容带有进度和颜色。$webpack --progress --colors 如果不想每次修改模块后都重新编译，那么可以启动监听模式。开启监听模式后，没有变化的模块会在编译后缓存到内存中，而不会每次都被重新编译，所以监听模式的整体速度是很快的。webpack --progress --colors --watch 当然，我们可以使用 webpack-dev-server 开发服务，这样我们就能通过 localhost:8080 启动一个 express 静态资源 web 服务器，并且会以监听模式自动运行 webpack，在浏览器打开 http://localhost:8080/ 或 http://localhost:8080/webpack-dev-server/ 可以浏览项目中的页面和编译后的资源输出，并且通过一个 socket.io 服务实时监听它们的变化并自动刷新页面。# 安装cnpm install webpack-dev-server -g# 运行webpack-dev-server --progress --colors","tags":[{"name":"Webpack","slug":"Webpack","permalink":"https://lirawx.me/tags/Webpack/"}]},{"title":"vue全面介绍--全家桶（vue笔记一）","date":"2017-07-05T04:58:48.000Z","path":"2017/07/05/2017-07-05-vue全面介绍--全家桶（vue笔记一）.html","text":"简介 “简单却不失优雅，小巧而不乏大匠”。Vue.js 是一个JavaScriptMVVM库，是一套构建用户界面的渐进式框架。它是以数据驱动和组件化的思想构建的，采用自底向上增量开发的设计。相比于Angular.js，Vue.js提供了更加简洁、更易于理解的API，使得我们能够快速地上手并使用Vue.js；同时比起 React + Redux 相对复杂的架构，Vue.js 更加轻量级也更加容易上手，是初创项目的首选前端框架。Vue 的核心库只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。并且作者是华人的关系，Vue拥有着对华人开发者最友好的api文档和官方教程。 vue、React、Angular1对比在Angular1中，在scope作用域中每一次数据变化，会触发watcher的重新计算，angular对常用的dom事件，xhr事件等做了封装， 在里面触发进入angular的digest流程。在digest流程里面，会从rootscope开始遍历， 检查所有的watcher。并且，如果一些 watcher 触发另一个更新，脏检查循环（digest cycle）可能要运行多次。Vue则没有这个问题，因为它使用基于依赖追踪的观察系统并且异步队列更新，数据的变化都是独立处罚的，除非数据之间有明确的依赖关系。vue官方宣称vue的渲染性能优于react。为了有理有据让人信服，vue开发团队建立了一个简单的对比性能的项目（https://github.com/chrisvfritz/vue-render-performance-comparisons），它负责渲染10000个列表项100次。Vue官方将每一个参照项目都分别运行 20 次并取最好的结果结果如下图： 由此可见，Vue的性能是远好于Angular1，并且稍微优于React的。 社区拓展对比Angular1的背后是Google，所以社区基础是不需要担心的，从Tutorial到StackOverflow的问题数量都可以反映出生态系统很完整。Vue和React都有强大的社区支持。React有状态管理库Flux、ReduxVue，相应的，Vue有vuex。Vue 和 React 都提供了强大的路由库来应对大型应用。然而Vue的路由库和状态管理库都是由官方维护支持的。React 则是选择把这些问题交给社区维护，因此创建了一个更分散的生态系统。但相对的，React 的生态系统相比 Vue 更加繁荣。此外，Vue 提供了Vue-cli 脚手架，包括了Webpack，Browserify，甚至路由库，能让你非常容易地构建项目。 学习陡峭度对比在指令与组件方面，Vue中将指令和组件分得更清晰。指令只封装 DOM 操作，而组件代表一个自给自足的独立单元，有自己的视图和数据逻辑。在 Angular1 中两者有不少相混的地方。在API与框架设计方面，angular1都比vue要复杂的多。就个人感觉而言，angular1和React的学习曲线会相对陡峭一些，而vue的编码方式会更趋近于前端开发者的编程习惯。因为vue的作者是中国人，vue的官方网站、教程和api肯定是最完善、最易懂的。此外，每次大版本的发布，都会伴随着详尽的迁移说明文档，包含了很多详尽的阐述以及许多迁移的例子，甚至还有迁移工具。 vue的缺点Vue就这么好，难道没有缺点吗？当然有，vue虽然在16年非常火爆，但是相比于angular和react，不论是成熟度还是社区活跃度都还不是对手。此外，Vue明确声明了自己放弃了对IE8的支持。再看看现在的招聘网站上，有多少写了需要有angular经验，而又有多少写了需要vue经验，就可见vue的影响力相比于angular和react还差的很远。 vue全家桶及项目架构Vue有著名的全家桶系列，包含了vue-router（http://router.vuejs.org），vuex（http://vuex.vuejs.org）， vue-resource（https://github.com/pagekit/vue-resource）。再加上构建工具vue-cli，就是一个完整的vue项目的核心构成。 vue-router路由推荐使用npm工具来安装vue-routernpm install vue-router通过import导入并定义Vue模块、vue-router模块和需要使用的组件，在本例中，分别是Goods、Ratings和Seller组件。最后，如果在一个模块化工程中使用它，必须要通过 Vue.use() 明确地安装路由功能。import Vue from’vue’importRouter from’vue-router’ import Goods from ‘@/components/goods/goods’;import Ratings from ‘@/components/ratings/ratings’;import Seller from ‘@/components/seller/seller’; Vue.use(Router); // 需要import Vue和Router，不然会报错undefined通过const router= new VueRouter（）来定义一个路由，并传入对应的配置，包括路径path和组件components。 vuex状态管理Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。如前面所提到的，Vuex 已经集成到 Vue 的官方调试工具vue Devtools，可以轻松的查看项目中的Vuex状态变化情况。假设有这样一个场景：我们的项目规模比较大，有多个父组件，每个父组件同时又包含多个子组件。如何保持对所有时间的追踪将变得很困难。到底哪个事件是哪个组件派发的，哪个组件该监听哪个事件？父组件将变得和子组件耦合越来越严重，因为它需要明确的派发和监听子组件的某些事件。项目逻辑分散在各个组件当中，很容易导致逻辑的混乱，不利于我们项目的维护。这就是 Vuex 用来解决的问题。 Vuex 的四个核心概念分别是：The state tree：Vuex 使用单一状态树，用一个对象就包含了全部的应用层级状态。至此它便作为一个『唯一数据源(SSOT)』而存在。这也意味着，每个应用将仅仅包含一个 store 实例。单状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。Getters：用来从 store 获取 Vue 组件数据。Mutators：事件处理器用来驱动状态的变化。Actions：可以给组件使用的函数，以此用来驱动事件处理器 mutationsVuex和简单的全局对象是不同的，当Vuex从store中读取状态值的时候，若状态发生了变化，那么相应的组件也会高效的更新。并且，改变store中状态的唯一途径就是提交commit mutations。这样便于我们跟踪每一次状态的变化。只要发生了状态的变化，一定伴随着mutation的提交。 vue-resource介绍Vue-resource有体积小，支持IE9以上的浏览器，支持promise特性的特点。同样推荐使用npm来安装Vue-resource。$ npm install vue-resource在安装并引入vue-resource后，可以基于全局的Vue对象使用http，也可以基于某个Vue实例使用http。在发送请求后，使用then方法来处理响应结果，then方法有两个参数，第一个参数是响应成功时的回调函数，第二个参数是响应失败时的回调函数。vue-resource的请求API是按照REST风格设计的，它提供了7种请求API：· get(url,[options])· head(url,[options])· delete(url,[options])· jsonp(url,[options])· post(url,[body], [options])· put(url, [body],[options])· patch(url,[body], [options]) vue工程目录结构 components/文件夹用来存放Vue 组件。个人建议，把每一个组件中使用到的image图片放置到对应的组件子文件目录下，便于统一的管理Node_modules/npm安装的该项目的依赖库vuex/文件夹存放的是和 Vuex store 相关的东西（state对象，actions，mutations)router/文件夹存放的是跟vue-router相关的路由配置项build/文件是 webpack 的打包编译配置文件static/文件夹存放一些静态的、较少变动的image或者css文件config/文件夹存放的是一些配置项，比如服务器访问的端口配置等dist/该文件夹一开始是不存在，在我们的项目经过 build 之后才会产出App.vue根组件，所有的子组件都将在这里被引用index.html整个项目的入口文件，将会引用我们的根组件 App.vuemain.js入口文件的 js 逻辑，在webpack 打包之后将被注入到 index.html 中 Vue核心功能计算属性假设有如下的购物车结算场景，用户选中商品的总金额是根据商品数量、选中商品种类数和商品单价来变化的。然而，数量、选中种类数量和单价这几个对象都是根据用户选择而动态变化的，如果在前端模版中为了计算最终商品总额，放入这几个动态变化的变量（商品数量、商品单价、选中商品种类），会让这个逻辑变得复杂难以维护。在这种情况下，模版便不再简洁清晰。Vue给出了此种场景的解决方案，在任何复杂的逻辑，vue都推荐使用计算属性。 computed vs method也许会有疑问，这个计算属性和定义一个method方法不是差不多么？这两者最大的区别是计算属性是基于它的依赖进行缓存的。计算属性只有在它的相关依赖发生变化时才会重新计算求值。在本例中，只有当选择商品的价格price和数量count发生变化时，这个计算属性totalPrice才会重新计算新的值。这就意味着，只要totalPrice这个值没有发生变化，多次访问该计算属性会立即返回之前的计算结果，而不必再次执行计算。 模版语法Vue.js 使用了基于 HTML 的模版语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模板都是合法的 HTML ，所以能被遵循规范的浏览器和 HTML 解析器解析。Vue的模版语法包括了使用双大括号插入文本、使用v-html插入纯HTML内容、使用v-bind插入对象、类似angular的v-if、v-show、v-for指令、以及过滤器等等。 组件化组件（Component）是 Vue.js 最强大的功能。组件可以封装可重用的代码，通过传入对象的不同，实现组件的复用。举一个简单的组建例子，我们首先编写一个star组件，它就是一个普通的star.vue文件。它的作用就是简单实现了一个五角星。如何在其他的vue文件中使用这个star组件呢？如下图所示，首先通过import引入star组件对象，并在想使用star组件的vue文件中声明注册star组件。现在就可以愉快的通过标签来在该vue文件中任意地方使用star组件了。在你想展示一个五角星的地方，使用一个star标签，就可以轻松完成这个功能。组件实例的作用域是孤立的。这意味着不能在子组件的模板内直接引用父组件的数据。要让子组件使用父组件的数据，我们需要通过子组件的props选项。如本例所示，子组件star要显式的使用props选项声明它期待获得的数据。在这里就是指的“size”和“score”两个变量。我们可以通过父级给子组件star传入大小和数值这两个对象，来实现对子组件的定制化。 过渡效果Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果，可以用简单的几行代码实现酷炫的过渡效果。Vue 提供了 transition 的封装组件，在使用v-if、v-show等方法使得transition内部dom元素发生变化时，可以给任何元素和组件添加 entering/leaving 过渡。当v-show中内容发生变化时，transition组件中的元素会发生状态的改变，在应用了transition封装后，Vue会自动识别目标元素是否应用了CSS过渡效果动画，如果有，会在合适的时机添加 entering/leaving的class来实现该过渡效果。下图所示是一个简单的过渡效果的例子，需要将想实现过渡效果的元素放在transition标签中包裹，通过name=“slide-fade”来声明过渡效果名称，并在对应的vue文件中添加过渡效果的css样式，这样就可以简单的完成该元素的过渡效果。 总结根据不完全统计，包括饿了么、稀土掘金、苏宁易购、美团、天猫、荔枝FM、房多多、Laravel、htmlBurger等国内外知名大公司都在使用vue进行新项目的开发和旧项目的前端重构工作。此外，vue + vuex+ vue-resource + vue-router + webpack + es6 + less的项目架构成为了越来越多大公司的第一选择。","tags":[{"name":"vue","slug":"vue","permalink":"https://lirawx.me/tags/vue/"}]},{"title":"姜文的一步之遥","date":"2017-07-05T04:58:08.000Z","path":"2017/07/05/2017-07-05-姜文的一步之遥.html","text":"一直以来对姜文的电影有种从心底里的欢喜，这个不同于其他国人导演的拍片风格，很是吸引人。从让子弹飞到一步之遥，都是民国风，个人对民国也有着文青的特殊向往，那个军阀混战的年代，人民开始追求时尚，追求自由，追求知识，科学等等，一切皆有可能的年代。 姜文谱写了一步之遥，借此讽今，开篇从泡沫出场，预示着本片的电影基调，深刻的批判了当下中国电影的泡沫，终将破灭。To be or not to be. 这便是这部电影的伟大之处，偏要在上映两周年的今天才能读懂的深意。 主角马走日，性格鲜明。电影中买通不成，便冲动行凶。如果马走日，真的想杀王天王，那他可以事先谋划，这并不难。但，他却选择在众目睽睽下，挥拳上台“殴打”对方。这足以体现马走日的孩子气，幼稚的可笑，无论老少都是孩子，用孩子的眼光看待人事。 为解一时之气，宁愿坐牢宁愿被枪毙。 理由很简单，仅为了死去的完颜英的颜面。 傻不傻？ 李安说过，周星驰拍的，都是小孩子的东西。 那么《一步之遥》，我给它的定义，就是一部“成人童话”。 它的主题有两个： 讽刺自命成熟者、讽刺自命成熟的社会。 是的，以一个小孩子的视角。 《一步之遥》表面上是部民国题材电影。 但实际上，它一直都在假借历史，讽刺假大空的、诛心吃人的社会。 青卢和白狐，为了争夺花国总统，费尽心思编排出百老汇级别的精彩表演。 我有一个文青朋友，当年她和我说，只看这段歌舞，就已经值回电影票价了。 《一步之遥》的结局，极不符合普通国产片中惯用的套路。 从头到尾，死掉的只有马走日、完颜英，以及半死不活的武六。 其余的人，看客依旧是看客，军阀依旧是军阀，伪艺术家依旧是伪艺术家。 他们依旧挥舞着武器，只不过有的武器是枪，有的武器是目光，有的武器是镜头。 以上灵感来自毒舌电影。","tags":[{"name":"电影","slug":"电影","permalink":"https://lirawx.me/tags/电影/"}]},{"title":"CoffeeScript 基础知识","date":"2017-07-05T04:57:25.000Z","path":"2017/07/05/2017-07-05-CoffeeScript 基础知识.html","text":"CoffeeScript 是一门编译到 JavaScript 的小巧语言. 在 Java 般笨拙的外表下, JavaScript 其实有着一颗华丽的心脏. CoffeeScript 尝试用简洁的方式展示 JavaScript 优秀的部分. CoffeeScript 的指导原则是: “她仅仅是 JavaScript“. 代码一一对应地编译到 JS, 不会在编译过程中进行解释. 已有的 JavaScript 类库可以无缝地和 CoffeeScript 搭配使用, 反之亦然. 编译后的代码是可读的, 且经过美化, 能在所有 JavaScript 环境中运行, 并且应该和对应手写的 JavaScript 一样快或者更快. 安装CoffeeScript 编译器本身是 CoffeeScript 写的, 使用了 Jison parser generator. 命令行版本的 coffee 是一个实用的 Node.js 工具. 不过编译器并不依赖 Node, 而是能运行于任何 JavaScript 执行环境, 比如说在浏览器里(看上边的”试一试 CoffeeScript”). 安装前你需要最新稳定版 Node.js, 和 npm (Node Package Manager). 借助 npm 可以安装 CoffeeScript:npm install -g coffee-script 语言手册一些基础, CoffeeScript 使用显式的空白来区分代码块. 你不需要使用分号 ; 来关闭表达式, 在一行的结尾换行就可以了(尽管分号依然可以用来把多行的表达式简写到一行里). 不需要再用花括号来 { } 包裹代码快, 在 函数, if 表达式, switch, 和 try/catch 当中使用缩进. 传入参数的时候, 你不需要再使用圆括号来表明函数被执行. 隐式的函数调用的作用范围一直到行尾或者一个块级表达式.console.log sys.inspect object → console.log(sys.inspect(object)); 函数函数通过一组可选的圆括号包裹的参数, 一个箭头, 一个函数体来定义. 一个空的函数像是这样: -&gt; coffeeScript square = (x) -&gt; x * xcube = (x) -&gt; square(x) * x JavaScriptvar cube, square;square = function(x) &#123; return x * x;&#125;;cube = function(x) &#123; return square(x) * x;&#125;; 对象和数组CoffeeScript 中对象和数组的字面量看起来很像在 JavaScript 中的写法. 如果单个属性被写在自己的一行里, 那么逗号是可以省略的. 和 YAML 类似, 对象可以用缩进替代花括号来声明. coffeeScriptsong = [&quot;do&quot;, &quot;re&quot;, &quot;mi&quot;, &quot;fa&quot;, &quot;so&quot;]singers = &#123;Jagger: &quot;Rock&quot;, Elvis: &quot;Roll&quot;&#125;bitlist = [ 1, 0, 1 0, 0, 1 1, 1, 0]kids = brother: name: &quot;Max&quot; age: 11 sister: name: &quot;Ida&quot; age: 9 JavaScriptvar bitlist, kids, singers, song;song = [&quot;do&quot;, &quot;re&quot;, &quot;mi&quot;, &quot;fa&quot;, &quot;so&quot;];singers = &#123; Jagger: &quot;Rock&quot;, Elvis: &quot;Roll&quot;&#125;;bitlist = [1, 0, 1, 0, 0, 1, 1, 1, 0];kids = &#123; brother: &#123; name: &quot;Max&quot;, age: 11 &#125;, sister: &#123; name: &quot;Ida&quot;, age: 9 &#125;&#125;; 词法作用域和变量安全CoffeeScript 编译器会考虑所有变量, 保证每个变量都在词法域里适当地被定义 — 你永远不需要自己去写 var. CoffeeScriptouter = 1changeNumbers = -&gt; inner = -1 outer = 10inner = changeNumbers() JavaScriptvar changeNumbers, inner, outer;outer = 1;changeNumbers = function() &#123; var inner; inner = -1; return outer = 10;&#125;;inner = changeNumbers(); 注意所有变量的定义都被推到相关的顶层作用域, 也就是第一次出现的位置. outer 在内层的函数里没有被重新定义, 因为它已经存在于作用域当中了. 同时, 内层函数里的 inner 不应该改变外部的同名的变量, 所以在这里有自己的声明. 循环和推导式你可以使用CoffeeScript将大多数的循环写成基于数组、对象或范围的推导式(comprehensions)。 推导式替代（编译为）for循环，并且可以使用可选的子句和数组索引值。 不同于for循环，数组的推导式是表达式，可以被返回和赋值。 CoffeeScript# 吃午饭.eat food for food in [&apos;toast&apos;, &apos;cheese&apos;, &apos;wine&apos;]# 精致的五道菜.courses = [&apos;greens&apos;, &apos;caviar&apos;, &apos;truffles&apos;, &apos;roast&apos;, &apos;cake&apos;]menu i + 1, dish for dish, i in courses# 注重健康的一餐.foods = [&apos;broccoli&apos;, &apos;spinach&apos;, &apos;chocolate&apos;]eat food for food in foods when food isnt &apos;chocolate&apos; JavaScriptvar courses, dish, food, foods, i, _i, _j, _k, _len, _len1, _len2, _ref;_ref = [&apos;toast&apos;, &apos;cheese&apos;, &apos;wine&apos;];for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) &#123; food = _ref[_i]; eat(food);&#125;courses = [&apos;greens&apos;, &apos;caviar&apos;, &apos;truffles&apos;, &apos;roast&apos;, &apos;cake&apos;];for (i = _j = 0, _len1 = courses.length; _j &lt; _len1; i = ++_j) &#123; dish = courses[i]; menu(i + 1, dish);&#125;foods = [&apos;broccoli&apos;, &apos;spinach&apos;, &apos;chocolate&apos;];for (_k = 0, _len2 = foods.length; _k &lt; _len2; _k++) &#123; food = foods[_k]; if (food !== &apos;chocolate&apos;) &#123; eat(food); &#125;&#125; 操作符和 aliase由于操作符 == 常常带来不准确的约束, 不容易达到效果, 而且跟其他语言当中意思不一致, CoffeeScript 会把 == 编译为 ===, 把 != 变异为 !==. 此外, is 编译为 ===, 而 isnt 编译为 !==. not 可以作为 ! 的 alias 使用. 逻辑操作方面, and 编译为 &amp;&amp;, 而 or 编译为 ||. 在 while, if/else, switch/when 的语句当中, then 可以被用来分隔判断条件跟表达式, 这样就不用强制写换行或者分号了. 就像 YAML, on 和 yes 跟 true 是一样的, 而 off 和 no 是布尔值 false. unless 可以认为是 if 相反的版本. this.property 简短的写法可以用 @property. 可以用 in 判断数据在数组中是否出现, 而 of 可以探测 JavaScript 对象的属性是否存在. 为了简化数学表达式, ** 可以用来表示乘方, // 表示整除, %% 提供数学的模运算(译注: true mathematical modulo?). 完整的列表: CoffeeScript JavaScriptis ===isnt !==not !and &amp;&amp;or ||true, yes, on truefalse, no, off false@, this thisof inin no JS equivalenta ** b Math.pow(a, b)a // b Math.floor(a / b)a %% b (a % b + b) % b","tags":[{"name":"coffeeScript","slug":"coffeeScript","permalink":"https://lirawx.me/tags/coffeeScript/"}]},{"title":"Ubuntu安装BTSync","date":"2017-07-05T04:56:56.000Z","path":"2017/07/05/2017-07-05-Ubuntu安装BTSync.html","text":"BTSync是多台电脑之间同步文件的利器，很好用。 在Ubuntu上安装BTSync的步骤： 添加btsync官方的Repository以下命令新建一个 /etc/apt/sources.list.d/btsync.list 文件。 sudo sh -c &apos;echo &quot;deb http://linux-packages.getsync.com/btsync/deb btsync non-free&quot; &gt; /etc/apt/sources.list.d/btsync.list&apos; 安装BTSync的Public key 使Ubuntu信任此BTSync提供的Repository。 wget -qO - http://linux-packages.getsync.com/btsync/key.asc | sudo apt-key add - 安装接下来就能用apt-get安装BTSync了，需要先update一下。 sudo apt-get updatesudo apt-get install btsync 创建用于同步的目录安装默认创建了一个btsync用户，可以创建一个新目录并授权给btsync用户，以后同步的内容就放在这个目录下。 sudo mkdir /home/btsyncsudo chown btsync /home/btsync 使BTSync自动启动默认启动服务的用户是btsyncsudo systemctl enable btsync 除了enable，systemctl命令还可以带disable、start、stop、status等参数。 通过web设置BTSync在本地用浏览器访问localhost:8888即可。 如果是VPS或Ubuntu server等没有图形界面的系统，可以编辑BTSync的配置文件。 sudo vi /etc/btsync/config.json 找到下面内容： &quot;webui&quot; :&#123; &quot;listen&quot; : &quot;127.0.0.1:8888&quot; //&quot;listen&quot; : &quot;0.0.0.0:8888&quot;, 外网访问 &quot;login&quot; : &quot;yourusername&quot;, &quot;password&quot; : &quot;yourpassword&quot;&#125; 将 “127.0.0.1:8888” 修改为 “0.0.0.0:8888” ，保存退出。重启BTSync。然后就能用其他机器的浏览器访问 “Ubuntu_IP:8888” 来设置BTSync。","tags":[{"name":"linux ubuntu","slug":"linux-ubuntu","permalink":"https://lirawx.me/tags/linux-ubuntu/"}]},{"title":"Oracle 与 MySql 区别(笔记)","date":"2017-07-05T04:55:41.000Z","path":"2017/07/05/2017-07-05-Oracle 与 MySql 区别(笔记).html","text":"一、并发性并发性是oltp数据库最重要的特性，但并发涉及到资源的获取、共享与锁定。 mysql:mysql以表级锁为主，对资源锁定的粒度很大，如果一个session对一个表加锁时间过长，会让其他session无法更新此表中的数据。虽然InnoDB引擎的表可以用行级锁，但这个行级锁的机制依赖于表的索引，如果表没有索引，或者sql语句没有使用索引，那么仍然使用表级锁。oracle:oracle使用行级锁，对资源锁定的粒度要小很多，只是锁定sql需要的资源，并且加锁是在数据库中的数据行上，不依赖与索引。所以oracle对并发性的支持要好很多。 二、一致性oracle:oracle支持serializable的隔离级别，可以实现最高级别的读一致性。每个session提交后其他session才能看到提交的更改。oracle通过在undo表空间中构造多版本数据块来实现读一致性，每个session查询时，如果对应的数据块发生变化，oracle会在undo表空间中为这个session构造它查询时的旧的数据块。 mysql:mysql没有类似oracle的构造多版本数据块的机制，只支持read commited的隔离级别。一个session读取数据时，其他session不能更改数据，但可以在表最后插入数据。session更新数据时，要加上排它锁，其他session无法访问数据。 三、事务oracle很早就完全支持事务。 mysql在innodb存储引擎的行级锁的情况下才支持事务。 四、数据持久性oracle保证提交的数据均可恢复，因为oracle把提交的sql操作线写入了在线联机日志文件中，保持到了磁盘上，如果出现数据库或主机异常重启，重启后oracle可以考联机在线日志恢复客户提交的数据。mysql:默认提交sql语句，但如果更新过程中出现db或主机重启的问题，也许会丢失数据。 五、提交方式oracle默认不自动提交，需要用户手动提交。mysql默认是自动提交。 六、逻辑备份oracle逻辑备份时不锁定数据，且备份的数据是一致的。 mysql逻辑备份时要锁定数据，才能保证备份的数据是一致的，影响业务正常的dml使用。 七、热备份oracle有成熟的热备工具rman，热备时，不影响用户使用数据库。即使备份的数据库不一致，也可以在恢复时通过归档日志和联机重做日志进行一致的回复。mysql:myisam的引擎，用mysql自带的mysqlhostcopy热备时，需要给表加读锁，影响dml操作。innodb的引擎，它会备份innodb的表和索引，但是不会备份.frm文件。用ibbackup备份时，会有一个日志文件记录备份期间的数据变化，因此可以不用锁表，不影响其他用户使用数据库。但此工具是收费的。innobackup是结合ibbackup使用的一个脚本，他会协助对.frm文件的备份。 八、sql语句的扩展和灵活性mysql对sql语句有很多非常实用而方便的扩展，比如limit功能，insert可以一次插入多行数据，select某些管理数据可以不加from。oracle在这方面感觉更加稳重传统一些。 九、复制oracle:既有推或拉式的传统数据复制，也有dataguard的双机或多机容灾机制，主库出现问题是，可以自动切换备库到主库，但配置管理较复杂。mysql:复制服务器配置简单，但主库出问题时，丛库有可能丢失一定的数据。且需要手工切换丛库到主库。 十、性能诊断oracle有各种成熟的性能诊断调优工具，能实现很多自动分析、诊断功能。比如awr、addm、sqltrace、tkproof等mysql的诊断调优方法较少，主要有慢查询日志。 十一、权限与安全mysql的用户与主机有关，感觉没有什么意义，另外更容易被仿冒主机及ip有可乘之机。oracle的权限与安全概念比较传统，中规中矩。 十二、分区表和分区索引oracle的分区表和分区索引功能很成熟，可以提高用户访问db的体验。mysql的分区表还不太成熟稳定。 十三、管理工具oracle有多种成熟的命令行、图形界面、web管理工具，还有很多第三方的管理工具，管理极其方便高效。mysql管理工具较少，在linux下的管理工具的安装有时要安装额外的包（phpmyadmin， etc)，有一定复杂性。","tags":[{"name":"java","slug":"java","permalink":"https://lirawx.me/tags/java/"}]},{"title":"java基础知识笔记（2）","date":"2017-07-05T04:55:02.000Z","path":"2017/07/05/2017-07-05-java基础知识笔记（2）.html","text":"接口(interface) 接口不能用于实例化对象 接口没有构造函数 接口的所有方法必须是抽象方法 接口不能包括成员变量，除 static final 修饰外 接口不能被类继承，只能被类实现 接口可以多重继承 接口的方法只能是 public abstract 修饰，变量只能public static final修饰 集合框架 接口： 代表集合的抽象数据类型 实现(类)：集合接口的具体实现 算法:实现集合接口的对象里的方法，执行一些相关计算 set 和list的区别 set接口实例存储无序且不重复数据 list存储有序且数据可重复 set效率低下，删除插入效率高 list和数组一样可以动态增长，查找效率高 面向对象方法的重写规则 参数列表必须完全与被重写方法的相同； 返回类型必须完全与被重写方法的返回类型相同； 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。 父类的成员方法只能被它的子类重写。 声明为final的方法不能被重写。 声明为static的方法不能被重写，但是能够被再次声明。 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。 子类和父类不在同一个包中，那么子类只能够重写父类的声明- - 为public和protected的非final方法。 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。 构造方法不能被重写。 如果不能继承一个方法，则不能重写这个方法。 重载(Overload)重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。最常用的地方就是构造器的重载。重载规则 被重载的方法必须改变参数列表(参数个数或类型或顺序不一样)； 被重载的方法可以改变返回类型； 被重载的方法可以改变访问修饰符； 被重载的方法可以声明新的或更广的检查异常； 方法能够在同一个类中或者在一个子类中被重载。 无法以返回值类型作为重载函数的区分标准。 多态存在的三个必要条件 继承 重写 父类引用指向子类对象 抽象类总结规定 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。 构造方法，类方法（用static修饰的方法）不能声明为抽象方法。 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。 封装在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。要访问该类的代码和数据，必须通过严格的接口控制。封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。封装的优点 良好的封装能够减少耦合。 类内部的结构可以自由修改。 可以对成员变量进行更精确的控制。 隐藏信息，实现细节。","tags":[{"name":"java","slug":"java","permalink":"https://lirawx.me/tags/java/"}]},{"title":"java基础知识笔记（1）","date":"2017-07-05T04:54:25.000Z","path":"2017/07/05/2017-07-05-java基础知识笔记（1）.html","text":"首先确定以下概念： 对象：对象是一个类的实例 类：类是一个模块，它描述一类对象的行为和状态 方法：方法就是行为，逻辑运算，数据修改，所有动作都是在方法中完成的 实例变量：每个对象都有独特的实例变量，用于保存对象的状态。 类型变量 局部变量 ： 声明和初始化都在方法中 成员变量： 定义在类中，方法体外 类变量： static 修饰 数据类型 内置数据类型: byte(-2^7 ~ 2^7-1) short(-2^15 ~ 2^15-1) int(-2^31 ~ 2^31-1) log(-2^63 ~ 2^63-1) float(0.0f 32位) double(0.0d 64位) boolean char(\\u0000 ~ \\uffff) 引用类型： 引用类型指向一个对象，指向对象的变量就是引用变量。如site Site site = new Site(&quot;http://lirawx.cn&quot;); 自动类型转换 转换顺序byte,short,char -&gt; int -&gt; long -&gt; float -&gt; double 不能对boolean转换 不能把对象转成不相关的类 容量大的转换成小的，转换过程总会溢出或损失精度int i = 128; byte b = (byte)i; byte最大127，会溢出 浮点数到整数，会舍弃小数，不是简单的四舍五入(int)12.7 == 12 (int)-25.89f == -45 修饰符访问修饰符 当前类 同一包内 子孙类 其他内 public 可以访问 可以访问 可以访问 可以访问 protected 可以访问 可以访问 可以访问 - default 可以访问 可以访问 - - private 可以访问 - - - 不使用任何关键字：对同一包内可见，接口变量隐式的声明为 public static final，接口里的方法默认情况访问权限为public。 非访问修饰符 static：独立于对象的静态变量，类变量，切静态变量只有一份拷贝 final：修饰的类不能继承，修饰的方法不能被继承类重新定义，变量不可修改 abstract：创建抽象类和抽象方法 synchronized/volatile： 用于线程 transient : 修饰短暂属性","tags":[{"name":"java","slug":"java","permalink":"https://lirawx.me/tags/java/"}]},{"title":"2017-05-19-总结","date":"2017-07-05T04:53:26.000Z","path":"2017/07/05/2017-07-05-2017-05-19-总结.html","text":"不是你上了大学，而是你被大学上了 首先写这篇总结的原因，从5月初开始我投了大量的简历，然而其结果都是被干掉，我归结出几个原因： 大学太过平庸 大学里我一直宅在宿舍里，至少是大一到到大二都是这样，自己刚刚接触到大学这个庞大的团体，每天都有新的事物吸引着我的注意力，而我始终都没有明确自己的理想与目标，我一直以为同学都差不多，其实差很多，当我在召唤师峡谷里欲仙欲死的时候有的同学在看专业书籍准备考研，有的在准备面试暑期实习生，有的甚至在看雅思，托付，等等一些高大上的书籍，准备考证。而我或者我们这一类人都嗤之以鼻，很不屑，”大学不是来玩的么“，这句话高中老师肯定多对我们说过，很遗憾，我们上课知识点没记住，却记住了这个最坑爹的一句话。我只想说你玩得起吗？你爸是李刚？你家族很庞大？你已经身家过亿？ 缺乏自主性和计划性 大学每天除了上课，就是在宿舍上网或者打游戏，这是常态，但是我很遗憾的告诉你，人生不是这么过的，一旦你陷入了享乐主义的恶性循环你会发现你的人生一团糟。你刚刚起床，考研的同学已经吃好早饭，到自习室或者图书馆自习了，而当你在床上玩着手机，自以为生活就是该这么悠闲，大学真好玩的时候，自学做技术的人已经完成了项目的一个模块了。当你中午起床的时候，你觉得一天才刚刚开始，然后你打开电脑，发现很无聊，点开了LOL，然后和队友互怼，你觉得很生气，然后你继续下一把，发现这把还行，。。。。。。n局后，唉，怎么天都黑了，然后你继续躺上床，捧着KINDLE，装着文艺，看着玄幻爽文，我去，猪脚帅的跟我一样，放技能都是恐怖如斯！。。。。N day 过去，你混着日子过完春夏秋冬，突然就毕业了，人家要么考清华北大，而你只能家里蹲，要么就是拿到大厂的OFFER，而你却说不急，我慢慢找（找你妹啊！！）。 缺乏清醒的自我认识 每个人考到大学，都觉得自己很牛逼，把电脑装饰linux，然后进入字符界面， sudo apt get install cmatrix ，运行之后，哇，这不是黑客帝国吗，我好牛逼，然后就没有然后了，一点也没有深入理解其中运行原理。这样的例子还有很多，每个人都觉得自己了不起，吧自己的身段放的老高，忘了自己应届生的身份，找工作的时候，发现好难，校招的题目都做不出来，去社招面试，结果一点项目经验都没有，over，一遍一遍始终都摆不正自己的身份，没有什么是应该的，你不会就是不会，没有什么可以狡辩的，copy再多，自己也写不出一行代码，悲哀。 缺乏对职业的认识 职业是什么，说白了就是你将来用来养家糊口的工具手段，当一个人温饱都成问题的时候，哪有什么职业可言，你必须要计划自己将来5到10年你想做什么，而不是等着老师给你布置 “找工作”的作业，职业是使命，你得为之付出青春和汗水，而不能丝毫怀疑，同时你还要学习，不断的学习，职业随着时间的延长，会不断进化发展，会需要很多的技能，你没有掌握就会被时代遗弃，简单来说你会丢掉饭碗。所以你要努力的保护自己的饭碗。当然有了职业，并不是说你所有的心思都必须放在它上面，你得学会分清主次，工作的时候要认真负责，休息的时候可以和同事交流分享经验，与人相处也是职业成功的必备要素。同时你还有有减轻自己工作压力的方法，比如打篮球，钓鱼，打保龄球等等之类的休闲活动。劳逸结合才能走得更远更舒畅。 学校培养人才和社会需要严重脱节 21世纪，科技发展迅速，职业素养要求越来越高，学校里的课程只能教授一些基本的知识，无法实际应用于社会生产，导致了很大一部分同学很被动，也很悲哀，被夹在当中，很无奈，没法找到理想的工作，也没有健全自己的道德素养体系，缺乏对自我的认识，没有自主性。种种原因导致了现阶段的一系列问题。 以上是个人浅见，或者说牢骚，慎重翻阅！！","tags":[{"name":"日记","slug":"日记","permalink":"https://lirawx.me/tags/日记/"}]},{"title":"热爱工作热爱生活","date":"2017-07-05T04:00:29.000Z","path":"2017/07/05/2017-07-05-热爱工作热爱生活.html","text":"概要每个人在开始工作初期，树立远大理想，追求一个卓越的人生。但最终，人追求的是快乐。现阶段的社会，过于急功近利，大多数的人都淹没在了欲望的海洋里，最终忘记了最初的梦想，沦为平庸。当然有的人会认为有很多钱才能快乐，被别人认可也会感到快乐，但是如果一直重复着平庸琐碎的工作，你一定不会快乐。所以我们要追求快乐，在追求快乐的过程中，或许你的荷包会越来越鼓，你的名声越来越大，但请不要忘记，这只是追求快乐的过程中所带来的附加产品。我提供两个建议： 不要害怕失败 制定自己的计划 软件是一门生意软件是一门生意，程序员是一个生意人。把职业想象成一个产品的生命周期，主要有四个方面用于职业发展。 选择市场在市场的选择上，有很多要考虑的因素，比如技术的稳定性，技术的发展前景，还有技术人员的供需关系，当你确定之后你要努力的了解你工作的公司所处的行业，只有你熟悉你所在行业，才能更好的完成产品。同时你也要努力发展自身，你不需要成为一名专家，你得成为一名通才，你必须理解程序运行的过程，编译原理，还要预计会出现什么问题，解决这个问题需要什么样的技术？然后是否值得花费时间去接触和学习，对自己未来有什么帮助。一个产品发布的同时，要学会分享，分享给同事，经理等等。。 投资要做一个机会主义者，抓住身边的机会，努力提高自己，拓展自己的知识面，接触不同的行业，明白每个行业的盈利模式，学习软件开发的步骤。这个过程可能会需要一个老师，这个老师不是传统意义上的老师，他只是这一个行业的标杆，你向他看齐学习这个行业的一切。最后只要不断的练习，练习，练习。 执行执行是对自己行为的一种定义，简单来说要低调。你必须要有一颗雄心，但不必路人皆。你可以适当从一些字里行间或交谈间了解到经理或者客户需要什么样的功能，然后如果可以就去完成它，说不定将来经理会提出开发这个功能，而你已经做完了。同时要给自己制定计划，每天都要写日志，每周都有总结，每个月都有目标，每年都会规划好发展道路。最后你必须专注现在的工作，因为这让你离未来的目标更近，同时每天都要思考怎么把手头的工作做好。 要明白自己的价值所在，每天都可以问自己我今天创造了多少价值。价值的多少跟时间没有什么太大的关联，每天8小时激情燃烧，就已经最大限度的创造价值了，时间再长也只是浪费自己宝贵的时间而已。在工作中必须保持紧迫感，因为没有人是无可替代的，当你的创造出的产值远远小于公司对你的投资，你就要走人了。当然紧迫不是慌乱，要纵览全局，把握自己的位置，每天都要取得一定的进步。取得进步的有效方法是失败和模仿。好的艺术家会抄袭，而巨匠会偷–毕加索，寻求现有的解决方案来解决自己问题这不可耻，但你必须深刻理解解决方案的原理，并从中学习积累到相关经验。 推销 。。。不仅仅是迎合首先我们来讲一个古老的心理学问题：如果森林里的一棵大树倒下了，却没有人听到它倒下的声音，那么它倒下的时候到底有没有发出声响？正确答案是：“谁会在意这个？” 树倒下可能会制造出了声响，但并没有人听到它倒下的声音，那么树倒下去制造声响的这一事实是无关紧要的。 工作也一样，如果你非常出色，但没有人知道，那你真的优秀吗?谁会在意？ 而且人与人之间的评价都是主观的，公司里的绩效考评也是主观的，别人都不知道你，怎么可能会给你高的评价，所以沟通能力很重要，程序员关门敲代码的时代造就过去式了，这个社会，程序员必须要具备一定的沟通能力，写作能力，因为程序员会与经理，客户，同事等等一些人有交流的必要。要成为一个卓越的人。卓越是什么意思，卓越就是值得被关注。你得在别人心里留下好的印象，才能说你优秀甚至卓越。 保持技术领先现在这个社会发展很快，技术更新，淘汰也很快，需要时刻保持警惕，说不定第二天就失去了工作，要与时俱进。关注一些技术达人，学习他们所关注的一些技术，每天都进步一点。 同时要学会绘制一张职业蓝图，包括自己所经历过的职业，所学过的技能。罗列出职业发展时间表。 职业发展道路中，树立远大目标，但在实现过程中，需要根据实际情况不断进行更正，从实践中学习，不断改变自己的目标。同时要学着独立，不依赖于他人去解决问题。","tags":[{"name":"日记","slug":"日记","permalink":"https://lirawx.me/tags/日记/"}]},{"title":"Ubuntu安装BTSync","date":"2017-05-25T00:00:00.000Z","path":"2015/linux/ubuntu-btsync.html","text":"BTSync是多台电脑之间同步文件的利器，很好用。 在Ubuntu上安装BTSync的步骤： 添加btsync官方的Repository以下命令新建一个 /etc/apt/sources.list.d/btsync.list 文件。 sudo sh -c &apos;echo &quot;deb http://linux-packages.getsync.com/btsync/deb btsync non-free&quot; &gt; /etc/apt/sources.list.d/btsync.list&apos; 安装BTSync的Public key 使Ubuntu信任此BTSync提供的Repository。 wget -qO - http://linux-packages.getsync.com/btsync/key.asc | sudo apt-key add - 安装接下来就能用apt-get安装BTSync了，需要先update一下。 sudo apt-get updatesudo apt-get install btsync 创建用于同步的目录安装默认创建了一个btsync用户，可以创建一个新目录并授权给btsync用户，以后同步的内容就放在这个目录下。 sudo mkdir /home/btsyncsudo chown btsync /home/btsync 使BTSync自动启动默认启动服务的用户是btsyncsudo systemctl enable btsync 除了enable，systemctl命令还可以带disable、start、stop、status等参数。 通过web设置BTSync在本地用浏览器访问localhost:8888即可。 如果是VPS或Ubuntu server等没有图形界面的系统，可以编辑BTSync的配置文件。 sudo vi /etc/btsync/config.json 找到下面内容： &quot;webui&quot; :&#123; &quot;listen&quot; : &quot;127.0.0.1:8888&quot; //&quot;listen&quot; : &quot;0.0.0.0:8888&quot;, 外网访问 &quot;login&quot; : &quot;yourusername&quot;, &quot;password&quot; : &quot;yourpassword&quot;&#125; 将 “127.0.0.1:8888” 修改为 “0.0.0.0:8888” ，保存退出。重启BTSync。然后就能用其他机器的浏览器访问 “Ubuntu_IP:8888” 来设置BTSync。","tags":[{"name":"btsync ubuntu","slug":"btsync-ubuntu","permalink":"https://lirawx.me/tags/btsync-ubuntu/"}]},{"title":"程序员职业规划","date":"2017-05-21T00:00:00.000Z","path":"2016/engineer/careerPlanning.html","text":"热爱工作热爱生活 概要每个人在开始工作初期，树立远大理想，追求一个卓越的人生。但最终，人追求的是快乐。现阶段的社会，过于急功近利，大多数的人都淹没在了欲望的海洋里，最终忘记了最初的梦想，沦为平庸。当然有的人会认为有很多钱才能快乐，被别人认可也会感到快乐，但是如果一直重复着平庸琐碎的工作，你一定不会快乐。所以我们要追求快乐，在追求快乐的过程中，或许你的荷包会越来越鼓，你的名声越来越大，但请不要忘记，这只是追求快乐的过程中所带来的附加产品。我提供两个建议： 不要害怕失败 制定自己的计划 软件是一门生意软件是一门生意，程序员是一个生意人。把职业想象成一个产品的生命周期，主要有四个方面用于职业发展。 选择市场在市场的选择上，有很多要考虑的因素，比如技术的稳定性，技术的发展前景，还有技术人员的供需关系，当你确定之后你要努力的了解你工作的公司所处的行业，只有你熟悉你所在行业，才能更好的完成产品。同时你也要努力发展自身，你不需要成为一名专家，你得成为一名通才，你必须理解程序运行的过程，编译原理，还要预计会出现什么问题，解决这个问题需要什么样的技术？然后是否值得花费时间去接触和学习，对自己未来有什么帮助。一个产品发布的同时，要学会分享，分享给同事，经理等等。。 投资要做一个机会主义者，抓住身边的机会，努力提高自己，拓展自己的知识面，接触不同的行业，明白每个行业的盈利模式，学习软件开发的步骤。这个过程可能会需要一个老师，这个老师不是传统意义上的老师，他只是这一个行业的标杆，你向他看齐学习这个行业的一切。最后只要不断的练习，练习，练习。 执行执行是对自己行为的一种定义，简单来说要低调。你必须要有一颗雄心，但不必路人皆。你可以适当从一些字里行间或交谈间了解到经理或者客户需要什么样的功能，然后如果可以就去完成它，说不定将来经理会提出开发这个功能，而你已经做完了。同时要给自己制定计划，每天都要写日志，每周都有总结，每个月都有目标，每年都会规划好发展道路。最后你必须专注现在的工作，因为这让你离未来的目标更近，同时每天都要思考怎么把手头的工作做好。 要明白自己的价值所在，每天都可以问自己我今天创造了多少价值。价值的多少跟时间没有什么太大的关联，每天8小时激情燃烧，就已经最大限度的创造价值了，时间再长也只是浪费自己宝贵的时间而已。在工作中必须保持紧迫感，因为没有人是无可替代的，当你的创造出的产值远远小于公司对你的投资，你就要走人了。当然紧迫不是慌乱，要纵览全局，把握自己的位置，每天都要取得一定的进步。取得进步的有效方法是失败和模仿。好的艺术家会抄袭，而巨匠会偷–毕加索，寻求现有的解决方案来解决自己问题这不可耻，但你必须深刻理解解决方案的原理，并从中学习积累到相关经验。 推销 。。。不仅仅是迎合首先我们来讲一个古老的心理学问题：如果森林里的一棵大树倒下了，却没有人听到它倒下的声音，那么它倒下的时候到底有没有发出声响？正确答案是：“谁会在意这个？” 树倒下可能会制造出了声响，但并没有人听到它倒下的声音，那么树倒下去制造声响的这一事实是无关紧要的。 工作也一样，如果你非常出色，但没有人知道，那你真的优秀吗?谁会在意？ 而且人与人之间的评价都是主观的，公司里的绩效考评也是主观的，别人都不知道你，怎么可能会给你高的评价，所以沟通能力很重要，程序员关门敲代码的时代造就过去式了，这个社会，程序员必须要具备一定的沟通能力，写作能力，因为程序员会与经理，客户，同事等等一些人有交流的必要。要成为一个卓越的人。卓越是什么意思，卓越就是值得被关注。你得在别人心里留下好的印象，才能说你优秀甚至卓越。 保持技术领先现在这个社会发展很快，技术更新，淘汰也很快，需要时刻保持警惕，说不定第二天就失去了工作，要与时俱进。关注一些技术达人，学习他们所关注的一些技术，每天都进步一点。 同时要学会绘制一张职业蓝图，包括自己所经历过的职业，所学过的技能。罗列出职业发展时间表。 职业发展道路中，树立远大目标，但在实现过程中，需要根据实际情况不断进行更正，从实践中学习，不断改变自己的目标。同时要学着独立，不依赖于他人去解决问题。","tags":[{"name":"career engineer","slug":"career-engineer","permalink":"https://lirawx.me/tags/career-engineer/"}]},{"title":"java基础知识笔记（1）","date":"2017-05-20T00:00:00.000Z","path":"2016/diary/2017/05/20/java基础知识笔记(1).html","text":"首先确定以下概念： 对象：对象是一个类的实例 类：类是一个模块，它描述一类对象的行为和状态 方法：方法就是行为，逻辑运算，数据修改，所有动作都是在方法中完成的 实例变量：每个对象都有独特的实例变量，用于保存对象的状态。 类型变量 局部变量 ： 声明和初始化都在方法中 成员变量： 定义在类中，方法体外 类变量： static 修饰 数据类型 内置数据类型: byte(-2^7 ~ 2^7-1) short(-2^15 ~ 2^15-1) int(-2^31 ~ 2^31-1) log(-2^63 ~ 2^63-1) float(0.0f 32位) double(0.0d 64位) boolean char(\\u0000 ~ \\uffff) 引用类型： 引用类型指向一个对象，指向对象的变量就是引用变量。如site Site site = new Site(&quot;http://lirawx.cn&quot;); 自动类型转换 转换顺序byte,short,char -&gt; int -&gt; long -&gt; float -&gt; double 不能对boolean转换 不能把对象转成不相关的类 容量大的转换成小的，转换过程总会溢出或损失精度int i = 128; byte b = (byte)i; byte最大127，会溢出 浮点数到整数，会舍弃小数，不是简单的四舍五入(int)12.7 == 12 (int)-25.89f == -45 修饰符访问修饰符 当前类 同一包内 子孙类 其他内 public 可以访问 可以访问 可以访问 可以访问 protected 可以访问 可以访问 可以访问 - default 可以访问 可以访问 - - private 可以访问 - - - 不使用任何关键字：对同一包内可见，接口变量隐式的声明为 public static final，接口里的方法默认情况访问权限为public。 非访问修饰符 static：独立于对象的静态变量，类变量，切静态变量只有一份拷贝 final：修饰的类不能继承，修饰的方法不能被继承类重新定义，变量不可修改 abstract：创建抽象类和抽象方法 synchronized/volatile： 用于线程 transient : 修饰短暂属性","tags":[{"name":"java","slug":"java","permalink":"https://lirawx.me/tags/java/"}]},{"title":"Oracle 与 MySql 区别(笔记)","date":"2017-05-20T00:00:00.000Z","path":"2016/diary/2017/05/20/Oracle 与 MySql 区别.html","text":"一、并发性并发性是oltp数据库最重要的特性，但并发涉及到资源的获取、共享与锁定。 mysql:mysql以表级锁为主，对资源锁定的粒度很大，如果一个session对一个表加锁时间过长，会让其他session无法更新此表中的数据。虽然InnoDB引擎的表可以用行级锁，但这个行级锁的机制依赖于表的索引，如果表没有索引，或者sql语句没有使用索引，那么仍然使用表级锁。oracle:oracle使用行级锁，对资源锁定的粒度要小很多，只是锁定sql需要的资源，并且加锁是在数据库中的数据行上，不依赖与索引。所以oracle对并发性的支持要好很多。 二、一致性oracle:oracle支持serializable的隔离级别，可以实现最高级别的读一致性。每个session提交后其他session才能看到提交的更改。oracle通过在undo表空间中构造多版本数据块来实现读一致性，每个session查询时，如果对应的数据块发生变化，oracle会在undo表空间中为这个session构造它查询时的旧的数据块。 mysql:mysql没有类似oracle的构造多版本数据块的机制，只支持read commited的隔离级别。一个session读取数据时，其他session不能更改数据，但可以在表最后插入数据。session更新数据时，要加上排它锁，其他session无法访问数据。 三、事务oracle很早就完全支持事务。 mysql在innodb存储引擎的行级锁的情况下才支持事务。 四、数据持久性oracle保证提交的数据均可恢复，因为oracle把提交的sql操作线写入了在线联机日志文件中，保持到了磁盘上，如果出现数据库或主机异常重启，重启后oracle可以考联机在线日志恢复客户提交的数据。mysql:默认提交sql语句，但如果更新过程中出现db或主机重启的问题，也许会丢失数据。 五、提交方式oracle默认不自动提交，需要用户手动提交。mysql默认是自动提交。 六、逻辑备份oracle逻辑备份时不锁定数据，且备份的数据是一致的。 mysql逻辑备份时要锁定数据，才能保证备份的数据是一致的，影响业务正常的dml使用。 七、热备份oracle有成熟的热备工具rman，热备时，不影响用户使用数据库。即使备份的数据库不一致，也可以在恢复时通过归档日志和联机重做日志进行一致的回复。mysql:myisam的引擎，用mysql自带的mysqlhostcopy热备时，需要给表加读锁，影响dml操作。innodb的引擎，它会备份innodb的表和索引，但是不会备份.frm文件。用ibbackup备份时，会有一个日志文件记录备份期间的数据变化，因此可以不用锁表，不影响其他用户使用数据库。但此工具是收费的。innobackup是结合ibbackup使用的一个脚本，他会协助对.frm文件的备份。 八、sql语句的扩展和灵活性mysql对sql语句有很多非常实用而方便的扩展，比如limit功能，insert可以一次插入多行数据，select某些管理数据可以不加from。oracle在这方面感觉更加稳重传统一些。 九、复制oracle:既有推或拉式的传统数据复制，也有dataguard的双机或多机容灾机制，主库出现问题是，可以自动切换备库到主库，但配置管理较复杂。mysql:复制服务器配置简单，但主库出问题时，丛库有可能丢失一定的数据。且需要手工切换丛库到主库。 十、性能诊断oracle有各种成熟的性能诊断调优工具，能实现很多自动分析、诊断功能。比如awr、addm、sqltrace、tkproof等mysql的诊断调优方法较少，主要有慢查询日志。 十一、权限与安全mysql的用户与主机有关，感觉没有什么意义，另外更容易被仿冒主机及ip有可乘之机。oracle的权限与安全概念比较传统，中规中矩。 十二、分区表和分区索引oracle的分区表和分区索引功能很成熟，可以提高用户访问db的体验。mysql的分区表还不太成熟稳定。 十三、管理工具oracle有多种成熟的命令行、图形界面、web管理工具，还有很多第三方的管理工具，管理极其方便高效。mysql管理工具较少，在linux下的管理工具的安装有时要安装额外的包（phpmyadmin， etc)，有一定复杂性。","tags":[{"name":"Oracle MySql","slug":"Oracle-MySql","permalink":"https://lirawx.me/tags/Oracle-MySql/"}]},{"title":"java基础知识笔记（2）","date":"2017-05-20T00:00:00.000Z","path":"2016/diary/2017/05/20/java基础知识笔记(2).html","text":"接口(interface) 接口不能用于实例化对象 接口没有构造函数 接口的所有方法必须是抽象方法 接口不能包括成员变量，除 static final 修饰外 接口不能被类继承，只能被类实现 接口可以多重继承 接口的方法只能是 public abstract 修饰，变量只能public static final修饰 集合框架 接口： 代表集合的抽象数据类型 实现(类)：集合接口的具体实现 算法:实现集合接口的对象里的方法，执行一些相关计算 set 和list的区别 set接口实例存储无序且不重复数据 list存储有序且数据可重复 set效率低下，删除插入效率高 list和数组一样可以动态增长，查找效率高 面向对象方法的重写规则 参数列表必须完全与被重写方法的相同； 返回类型必须完全与被重写方法的返回类型相同； 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。 父类的成员方法只能被它的子类重写。 声明为final的方法不能被重写。 声明为static的方法不能被重写，但是能够被再次声明。 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。 子类和父类不在同一个包中，那么子类只能够重写父类的声明- - 为public和protected的非final方法。 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。 构造方法不能被重写。 如果不能继承一个方法，则不能重写这个方法。 重载(Overload)重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。最常用的地方就是构造器的重载。重载规则 被重载的方法必须改变参数列表(参数个数或类型或顺序不一样)； 被重载的方法可以改变返回类型； 被重载的方法可以改变访问修饰符； 被重载的方法可以声明新的或更广的检查异常； 方法能够在同一个类中或者在一个子类中被重载。 无法以返回值类型作为重载函数的区分标准。 多态存在的三个必要条件 继承 重写 父类引用指向子类对象 抽象类总结规定 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。 构造方法，类方法（用static修饰的方法）不能声明为抽象方法。 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。 封装在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。要访问该类的代码和数据，必须通过严格的接口控制。封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。封装的优点 良好的封装能够减少耦合。 类内部的结构可以自由修改。 可以对成员变量进行更精确的控制。 隐藏信息，实现细节。","tags":[{"name":"java","slug":"java","permalink":"https://lirawx.me/tags/java/"}]},{"title":"大四这一年","date":"2017-05-19T00:00:00.000Z","path":"2016/diary/2017/05/19/总结.html","text":"不是你上了大学，而是你被大学上了 首先写这篇总结的原因，从5月初开始我投了大量的简历，然而其结果都是被干掉，我归结出几个原因： 大学太过平庸 大学里我一直宅在宿舍里，至少是大一到到大二都是这样，自己刚刚接触到大学这个庞大的团体，每天都有新的事物吸引着我的注意力，而我始终都没有明确自己的理想与目标，我一直以为同学都差不多，其实差很多，当我在召唤师峡谷里欲仙欲死的时候有的同学在看专业书籍准备考研，有的在准备面试暑期实习生，有的甚至在看雅思，托付，等等一些高大上的书籍，准备考证。而我或者我们这一类人都嗤之以鼻，很不屑，”大学不是来玩的么“，这句话高中老师肯定多对我们说过，很遗憾，我们上课知识点没记住，却记住了这个最坑爹的一句话。我只想说你玩得起吗？你爸是李刚？你家族很庞大？你已经身家过亿？ 缺乏自主性和计划性 大学每天除了上课，就是在宿舍上网或者打游戏，这是常态，但是我很遗憾的告诉你，人生不是这么过的，一旦你陷入了享乐主义的恶性循环你会发现你的人生一团糟。你刚刚起床，考研的同学已经吃好早饭，到自习室或者图书馆自习了，而当你在床上玩着手机，自以为生活就是该这么悠闲，大学真好玩的时候，自学做技术的人已经完成了项目的一个模块了。当你中午起床的时候，你觉得一天才刚刚开始，然后你打开电脑，发现很无聊，点开了LOL，然后和队友互怼，你觉得很生气，然后你继续下一把，发现这把还行，。。。。。。n局后，唉，怎么天都黑了，然后你继续躺上床，捧着KINDLE，装着文艺，看着玄幻爽文，我去，猪脚帅的跟我一样，放技能都是恐怖如斯！。。。。N day 过去，你混着日子过完春夏秋冬，突然就毕业了，人家要么考清华北大，而你只能家里蹲，要么就是拿到大厂的OFFER，而你却说不急，我慢慢找（找你妹啊！！）。 缺乏清醒的自我认识 每个人考到大学，都觉得自己很牛逼，把电脑装饰linux，然后进入字符界面， sudo apt get install cmatrix ，运行之后，哇，这不是黑客帝国吗，我好牛逼，然后就没有然后了，一点也没有深入理解其中运行原理。这样的例子还有很多，每个人都觉得自己了不起，吧自己的身段放的老高，忘了自己应届生的身份，找工作的时候，发现好难，校招的题目都做不出来，去社招面试，结果一点项目经验都没有，over，一遍一遍始终都摆不正自己的身份，没有什么是应该的，你不会就是不会，没有什么可以狡辩的，copy再多，自己也写不出一行代码，悲哀。 缺乏对职业的认识 职业是什么，说白了就是你将来用来养家糊口的工具手段，当一个人温饱都成问题的时候，哪有什么职业可言，你必须要计划自己将来5到10年你想做什么，而不是等着老师给你布置 “找工作”的作业，职业是使命，你得为之付出青春和汗水，而不能丝毫怀疑，同时你还要学习，不断的学习，职业随着时间的延长，会不断进化发展，会需要很多的技能，你没有掌握就会被时代遗弃，简单来说你会丢掉饭碗。所以你要努力的保护自己的饭碗。当然有了职业，并不是说你所有的心思都必须放在它上面，你得学会分清主次，工作的时候要认真负责，休息的时候可以和同事交流分享经验，与人相处也是职业成功的必备要素。同时你还有有减轻自己工作压力的方法，比如打篮球，钓鱼，打保龄球等等之类的休闲活动。劳逸结合才能走得更远更舒畅。 学校培养人才和社会需要严重脱节 21世纪，科技发展迅速，职业素养要求越来越高，学校里的课程只能教授一些基本的知识，无法实际应用于社会生产，导致了很大一部分同学很被动，也很悲哀，被夹在当中，很无奈，没法找到理想的工作，也没有健全自己的道德素养体系，缺乏对自我的认识，没有自主性。种种原因导致了现阶段的一系列问题。 以上是个人浅见，或者说牢骚，慎重翻阅！！","tags":[{"name":"总结","slug":"总结","permalink":"https://lirawx.me/tags/总结/"}]},{"title":"CoffeeScript 基础知识","date":"2017-05-16T00:00:00.000Z","path":"2016/javascript/2017-05-15-coffescript.html","text":"CoffeeScript 是一门编译到 JavaScript 的小巧语言. 在 Java 般笨拙的外表下, JavaScript 其实有着一颗华丽的心脏. CoffeeScript 尝试用简洁的方式展示 JavaScript 优秀的部分. CoffeeScript 的指导原则是: “她仅仅是 JavaScript“. 代码一一对应地编译到 JS, 不会在编译过程中进行解释. 已有的 JavaScript 类库可以无缝地和 CoffeeScript 搭配使用, 反之亦然. 编译后的代码是可读的, 且经过美化, 能在所有 JavaScript 环境中运行, 并且应该和对应手写的 JavaScript 一样快或者更快. 安装CoffeeScript 编译器本身是 CoffeeScript 写的, 使用了 Jison parser generator. 命令行版本的 coffee 是一个实用的 Node.js 工具. 不过编译器并不依赖 Node, 而是能运行于任何 JavaScript 执行环境, 比如说在浏览器里(看上边的”试一试 CoffeeScript”). 安装前你需要最新稳定版 Node.js, 和 npm (Node Package Manager). 借助 npm 可以安装 CoffeeScript:npm install -g coffee-script 语言手册一些基础, CoffeeScript 使用显式的空白来区分代码块. 你不需要使用分号 ; 来关闭表达式, 在一行的结尾换行就可以了(尽管分号依然可以用来把多行的表达式简写到一行里). 不需要再用花括号来 { } 包裹代码快, 在 函数, if 表达式, switch, 和 try/catch 当中使用缩进. 传入参数的时候, 你不需要再使用圆括号来表明函数被执行. 隐式的函数调用的作用范围一直到行尾或者一个块级表达式.console.log sys.inspect object → console.log(sys.inspect(object)); 函数函数通过一组可选的圆括号包裹的参数, 一个箭头, 一个函数体来定义. 一个空的函数像是这样: -&gt; coffeeScript square = (x) -&gt; x * xcube = (x) -&gt; square(x) * x JavaScriptvar cube, square;square = function(x) &#123; return x * x;&#125;;cube = function(x) &#123; return square(x) * x;&#125;; 对象和数组CoffeeScript 中对象和数组的字面量看起来很像在 JavaScript 中的写法. 如果单个属性被写在自己的一行里, 那么逗号是可以省略的. 和 YAML 类似, 对象可以用缩进替代花括号来声明. coffeeScriptsong = [&quot;do&quot;, &quot;re&quot;, &quot;mi&quot;, &quot;fa&quot;, &quot;so&quot;]singers = &#123;Jagger: &quot;Rock&quot;, Elvis: &quot;Roll&quot;&#125;bitlist = [ 1, 0, 1 0, 0, 1 1, 1, 0]kids = brother: name: &quot;Max&quot; age: 11 sister: name: &quot;Ida&quot; age: 9 JavaScriptvar bitlist, kids, singers, song;song = [&quot;do&quot;, &quot;re&quot;, &quot;mi&quot;, &quot;fa&quot;, &quot;so&quot;];singers = &#123; Jagger: &quot;Rock&quot;, Elvis: &quot;Roll&quot;&#125;;bitlist = [1, 0, 1, 0, 0, 1, 1, 1, 0];kids = &#123; brother: &#123; name: &quot;Max&quot;, age: 11 &#125;, sister: &#123; name: &quot;Ida&quot;, age: 9 &#125;&#125;; 词法作用域和变量安全CoffeeScript 编译器会考虑所有变量, 保证每个变量都在词法域里适当地被定义 — 你永远不需要自己去写 var. CoffeeScriptouter = 1changeNumbers = -&gt; inner = -1 outer = 10inner = changeNumbers() JavaScriptvar changeNumbers, inner, outer;outer = 1;changeNumbers = function() &#123; var inner; inner = -1; return outer = 10;&#125;;inner = changeNumbers(); 注意所有变量的定义都被推到相关的顶层作用域, 也就是第一次出现的位置. outer 在内层的函数里没有被重新定义, 因为它已经存在于作用域当中了. 同时, 内层函数里的 inner 不应该改变外部的同名的变量, 所以在这里有自己的声明. 循环和推导式你可以使用CoffeeScript将大多数的循环写成基于数组、对象或范围的推导式(comprehensions)。 推导式替代（编译为）for循环，并且可以使用可选的子句和数组索引值。 不同于for循环，数组的推导式是表达式，可以被返回和赋值。 CoffeeScript# 吃午饭.eat food for food in [&apos;toast&apos;, &apos;cheese&apos;, &apos;wine&apos;]# 精致的五道菜.courses = [&apos;greens&apos;, &apos;caviar&apos;, &apos;truffles&apos;, &apos;roast&apos;, &apos;cake&apos;]menu i + 1, dish for dish, i in courses# 注重健康的一餐.foods = [&apos;broccoli&apos;, &apos;spinach&apos;, &apos;chocolate&apos;]eat food for food in foods when food isnt &apos;chocolate&apos; JavaScriptvar courses, dish, food, foods, i, _i, _j, _k, _len, _len1, _len2, _ref;_ref = [&apos;toast&apos;, &apos;cheese&apos;, &apos;wine&apos;];for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) &#123; food = _ref[_i]; eat(food);&#125;courses = [&apos;greens&apos;, &apos;caviar&apos;, &apos;truffles&apos;, &apos;roast&apos;, &apos;cake&apos;];for (i = _j = 0, _len1 = courses.length; _j &lt; _len1; i = ++_j) &#123; dish = courses[i]; menu(i + 1, dish);&#125;foods = [&apos;broccoli&apos;, &apos;spinach&apos;, &apos;chocolate&apos;];for (_k = 0, _len2 = foods.length; _k &lt; _len2; _k++) &#123; food = foods[_k]; if (food !== &apos;chocolate&apos;) &#123; eat(food); &#125;&#125; 操作符和 aliase由于操作符 == 常常带来不准确的约束, 不容易达到效果, 而且跟其他语言当中意思不一致, CoffeeScript 会把 == 编译为 ===, 把 != 变异为 !==. 此外, is 编译为 ===, 而 isnt 编译为 !==. not 可以作为 ! 的 alias 使用. 逻辑操作方面, and 编译为 &amp;&amp;, 而 or 编译为 ||. 在 while, if/else, switch/when 的语句当中, then 可以被用来分隔判断条件跟表达式, 这样就不用强制写换行或者分号了. 就像 YAML, on 和 yes 跟 true 是一样的, 而 off 和 no 是布尔值 false. unless 可以认为是 if 相反的版本. this.property 简短的写法可以用 @property. 可以用 in 判断数据在数组中是否出现, 而 of 可以探测 JavaScript 对象的属性是否存在. 为了简化数学表达式, ** 可以用来表示乘方, // 表示整除, %% 提供数学的模运算(译注: true mathematical modulo?). 完整的列表: CoffeeScript JavaScriptis ===isnt !==not !and &amp;&amp;or ||true, yes, on truefalse, no, off false@, this thisof inin no JS equivalenta ** b Math.pow(a, b)a // b Math.floor(a / b)a %% b (a % b + b) % b","tags":[{"name":"coffeeScript","slug":"coffeeScript","permalink":"https://lirawx.me/tags/coffeeScript/"}]},{"title":"axios","date":"2017-05-15T00:00:00.000Z","path":"2015/web/2017-05-15-axios.html","text":"基于 Promise 的 HTTP 请求客户端，可同时在浏览器和 node.js 中使用 功能特性 在浏览器中发送 XMLHttpRequests 请求 在 node.js 中发送 http请求 支持 Promise API 拦截请求和响应 转换请求和响应数据 自动转换 JSON 数据 客户端支持保护安全免受 XSRF 攻击浏览器支持 安装使用 bower:$ bower install axios 使用 npm:$ npm install axios 例子发送一个 GET 请求// Make a request for a user with a given IDaxios.get(&apos;/user?ID=12345&apos;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (response) &#123; console.log(response); &#125;);// Optionally the request above could also be done asaxios.get(&apos;/user&apos;, &#123; params: &#123; ID: 12345 &#125; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (response) &#123; console.log(response); &#125;); 发送一个 POST 请求axios.post(&apos;/user&apos;, &#123; firstName: &apos;Fred&apos;, lastName: &apos;Flintstone&apos; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (response) &#123; console.log(response); &#125;); 发送多个并发请求function getUserAccount() &#123; return axios.get(&apos;/user/12345&apos;);&#125;function getUserPermissions() &#123; return axios.get(&apos;/user/12345/permissions&apos;);&#125;axios.all([getUserAccount(), getUserPermissions()]) .then(axios.spread(function (acct, perms) &#123; // Both requests are now complete &#125;));","tags":[{"name":"axios promise","slug":"axios-promise","permalink":"https://lirawx.me/tags/axios-promise/"}]},{"title":"javascript导航特效（程序代码）","date":"2017-04-28T00:00:00.000Z","path":"2015/js/2017-04-28.html","text":"思路：当鼠标移动到某个li上的时候，就要改变云所在的位置，当鼠标离开的时候，云回到原来的位置，当鼠标点击的时候，云固定在当前的位置,而位置的获取，就是利用offsetLeft. &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; *&#123;margin: 0; padding: 0;&#125; ul&#123; list-style: none; &#125; body&#123;background-color: #000;&#125; .nav&#123; width: 800px; height: 42px; background: url(img/rss.png) no-repeat right center #fff; margin: 100px auto; border-radius: 5px; position: relative; &#125; .cloud&#123; width: 83px; height: 42px; position: absolute; top: 0; left: 0; background: url(img/cloud.gif) no-repeat; &#125; .nav ul&#123; position: absolute; top: 0; left: 0; &#125; .nav li&#123; float: left; width: 83px; height: 42px; line-height: 42px; text-align: center; color: #000; cursor: pointer; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;nav&quot; id=&quot;nav&quot;&gt; &lt;span class=&quot;cloud&quot; id=&quot;cloud&quot;&gt;&lt;/span&gt; &lt;ul&gt; &lt;li&gt;首页&lt;/li&gt; &lt;li&gt;贵州&lt;/li&gt; &lt;li&gt;深圳&lt;/li&gt; &lt;li&gt;重庆&lt;/li&gt; &lt;li&gt;北京&lt;/li&gt; &lt;li&gt;杭州&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; &lt;script&gt; /** * 思路：当鼠标移动到某个li上的时候，就要改变云所在的位置，当鼠标离开的时候，云回到原来的位置，当鼠标点击的时候，云固定在当前的位置 * 而位置的获取，就是利用offsetLeft */ var cloud = document.getElementById(&quot;cloud&quot;);//获取云 var lis = document.getElementById(&quot;nav&quot;).children[1].children; for (var i=0;i&lt;lis.length;i++) &#123; //鼠标进去区域事件 lis[i].onmouseover = function()&#123; target = this.offsetLeft; &#125; //鼠标离开事件 lis[i].onmouseout =function()&#123; target = current; &#125; //单击事件 lis[i].onclick = function()&#123; current = this.offsetLeft; &#125; &#125; //缓动公式 var leader = 0; var target = 0;//移动的目标位置 var current = 0;//用于存放点击的位置 setInterval(function()&#123; leader = leader + (target - leader) /10; cloud.style.left = leader + &quot;px&quot;; &#125;,10) &lt;/script&gt;","tags":[{"name":"js","slug":"js","permalink":"https://lirawx.me/tags/js/"}]},{"title":"javascript滑动条（程序代码）","date":"2017-04-28T00:00:00.000Z","path":"2015/js/2017-04-28-scrollpercent.html","text":"拖拽效果的实现，主要是利用，鼠标按下不起来的事件中加入鼠标的移动事件来实现，所以当鼠标按下的时候，记录位置，然后移动鼠标，改变位置，window.getSelection ? window.getSelection().removeAllRanges() : document.selection.empty();代码的作用清楚所选的内容然后当鼠标弹起的时候，不做操作. &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; * &#123;margin:0;padding:0;&#125; .scroll &#123; width: 400px; height: 8px; background-color: #ccc; margin: 100px; position: relative; &#125; .bar &#123; width: 10px; height: 22px; background-color: #369; position: absolute; top: -7px; left: 0; cursor: pointer; &#125; .mask &#123; width: 0; height: 100%; background-color: #369; position: absolute; top: 0; left: 0; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;scroll&quot; id=&quot;scrollBar&quot;&gt; &lt;div class=&quot;bar&quot;&gt;&lt;/div&gt; &lt;div class=&quot;mask&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;demo&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; &lt;script&gt; /** * 拖拽效果的实现，主要是利用，鼠标按下不起来的事件中加入鼠标的移动事件来实现， * 所以当鼠标按下的时候，记录位置，然后移动鼠标，改变位置， * window.getSelection ? window.getSelection().removeAllRanges() : document.selection.empty();代码的作用清楚所选的内容 * 然后当鼠标弹起的时候，不做操作 */ var scrollBar = document.getElementById(&quot;scrollBar&quot;); var bar = scrollBar.children[0]; var mask = scrollBar.children[1]; var demo = document.getElementById(&quot;demo&quot;); /* document.onmousedown = function() &#123; alert(11); &#125;*/ bar.onmousedown = function(event) &#123; var event = event || window.event; var leftVal = event.clientX - this.offsetLeft; // alert(11); // 拖动一定写到 down 里面才可以 var that = this; document.onmousemove = function(event) &#123; var event = event || window.event; that.style.left = event.clientX - leftVal + &apos;px&apos;; //alert(that.style.left); var val = parseInt(that.style.left); if (val &lt; 0) &#123; that.style.left = 0; &#125; else if (val &gt; 390) &#123; that.style.left = &quot;390px&quot;; &#125; mask.style.width = that.style.left; // 遮罩盒子的宽度 //计算百分比 demo.innerHTML = &quot;已经走了:&quot; + parseInt(parseInt(that.style.left) / 390 * 100) + &quot;%&quot;; window.getSelection ? window.getSelection().removeAllRanges() : document.selection.empty(); &#125; document.onmouseup = function() &#123; document.onmousemove = null; // 弹起鼠标不做任何操作 &#125; &#125; &lt;/script&gt;","tags":[{"name":"js","slug":"js","permalink":"https://lirawx.me/tags/js/"}]},{"title":"javascript特效（知识点笔记）","date":"2017-04-28T00:00:00.000Z","path":"2015/js/2017-04-28-jsanimation.html","text":"javascript中常用坐标属性offset、scroll、clientoffset、scroll、client是js中获取元素尺寸的api的三大家族。 1、在文档（document）对象里面用：scrollWidth/Height:获取对象的滚动宽度(滚动条可以滚动的宽度，相当于整个页面的总宽度的样子–网页正文全宽) scrollLeft/Top:设置或获取位于对象左边界和窗口中目前可见内容的最左端之间的距离（页面利用滚动条滚动到右边时，隐藏在滚动条左边的页面宽度—页面被卷去左边） 2、在节点对象里面用：offsetLeft/Top:获取对象相对于版面（css里面没有进行定位，则offsetParent取值为根元素进行计算）或由 offsetParent 属性指定的父坐标的计算左侧位置（当有css定位时，当前对象相对与offsetParent元素的距离） offsetWidth/Height (width+padding+border)获取当前对象的宽度。style.width也是当前对象的宽度(width+padding+border)。区别：1)style.width返回值除了数字外还带有单位px；2)如对象的宽度设定值为百分比宽度,则无论页面变大还是变小，style.width都返回此百分比,而offsetWidth则返回在不同页面中对象的宽度值而不是百分比值；3)如果没有给 HTML 元素指定过 width样式，则 style.width 返回的是空字符串； offsetLeft :当前对象到其上级层左边的距离。不能对其进行赋值.设置对象到其上级层左边的距离请用style.left属性。style.left当前对象到其上级层左边的距离。区别：1)style.left返回值除了数字外还带有单位px；2)如对象到其上级层左边的距离设定值为百分比，style.left返回此百分比,而offsetLeft则返回到其上级层左边的距离的值；3)如果没有给 HTML 元素指定过 left样式，则 style.left返回的是空字符串； 注意：如果上级层为body，由于IE、FF对padding、margin的解释不一样所以要明确规定处理不是下列的区别就不成立了。IE1)如果Div的上级层是body，而div与body之间有个div，如body-&gt;div-&gt;divo；divo的offsetTop=div的padding+margin+boder；2）如果Div的上级层是body，如body&gt;divo；divo的offsetTop=div的padding+margin+boder； 这divo的offsetTop=divo的margin &gt;body.padding则为divo的margin，否则为body.padding谁大是谁？FF 上述两种情况：offsetTop=margin+padding ;(IE与FF中的body默认padding为10)在IE6.0 FF3.6.13 clientWidth/Height:获取对象可见内容的宽度，不包括滚动条，不包括边框；clientLeft/Top: 获取对象的border宽度 3、事件里面用的：event.clientX 相对文档的水平座标event.clientY 相对文档的垂直座标event.offsetX 相对容器的水平坐标event.offsetY 相对容器的垂直坐标 4、屏幕的：window.screenTop 网页正文部分上window.screenLfet 网页正文部分左window.screen.height 屏幕分辨律的高window.screen.left 屏幕分辨律的宽window.screen.availHeight 屏幕可用工作区的高度window.screen.availWidth 屏幕可用工作区的宽度document.documentElement.scrollTop 垂直方向滚动的值网页可见区域宽： document.body.clientWidth;网页可见区域高： document.body.clientHeight;网页可见区域宽： document.body.offsetWidth (包括边线的宽);网页可见区域高： document.body.offsetHeight (包括边线的宽);网页正文全文宽： document.body.scrollWidth;网页正文全文高： document.body.scrollHeight;网页被卷去的高： document.body.scrollTop;网页被卷去的左： document.body.scrollLeft;网页正文部分上： window.screenTop;网页正文部分左： window.screenLeft;屏幕分辨率的高： window.screen.height;屏幕分辨率的宽： window.screen.width;屏幕可用工作区高度： window.screen.availHeight;屏幕可用工作区宽度：window.screen.availWidth; 补充：","tags":[{"name":"js","slug":"js","permalink":"https://lirawx.me/tags/js/"}]},{"title":"javascript 幻灯片代码(含自动播放)","date":"2017-04-26T00:00:00.000Z","path":"2015/js/2017-04-26-slideshow.html","text":"HTML &lt;div class=&quot;slideshow-container&quot;&gt; &lt;div class=&quot;mySlides fade&quot;&gt; &lt;div class=&quot;numbertext&quot;&gt;1 / 3&lt;/div&gt; &lt;img src=&quot;https://c.runoob.com/wp-content/uploads/2017/01/img_mountains_wide.jpg&quot; style=&quot;width:100%&quot;&gt; &lt;div class=&quot;text&quot;&gt;文本 1&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;mySlides fade&quot;&gt; &lt;div class=&quot;numbertext&quot;&gt;2 / 3&lt;/div&gt; &lt;img src=&quot;https://c.runoob.com/wp-content/uploads/2017/01/img_fjords_wide.jpg&quot; style=&quot;width:100%&quot;&gt; &lt;div class=&quot;text&quot;&gt;文本 2&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;mySlides fade&quot;&gt; &lt;div class=&quot;numbertext&quot;&gt;3 / 3&lt;/div&gt; &lt;img src=&quot;https://c.runoob.com/wp-content/uploads/2017/01/img_nature_wide.jpg&quot; style=&quot;width:100%&quot;&gt; &lt;div class=&quot;text&quot;&gt;文本 3&lt;/div&gt; &lt;/div&gt; &lt;a class=&quot;prev&quot; onclick=&quot;plusSlides(-1)&quot;&gt;❮&lt;/a&gt; &lt;a class=&quot;next&quot; onclick=&quot;plusSlides(1)&quot;&gt;❯&lt;/a&gt;&lt;/div&gt;&lt;br&gt;&lt;div style=&quot;text-align:center&quot;&gt; &lt;span class=&quot;dot&quot; onclick=&quot;currentSlide(1)&quot;&gt;&lt;/span&gt; &lt;span class=&quot;dot&quot; onclick=&quot;currentSlide(2)&quot;&gt;&lt;/span&gt; &lt;span class=&quot;dot&quot; onclick=&quot;currentSlide(3)&quot;&gt;&lt;/span&gt;&lt;/div&gt; CSS* &#123;box-sizing:border-box&#125;body &#123;font-family: Verdana,sans-serif;&#125;.mySlides &#123;display:none&#125;/* 幻灯片容器 */.slideshow-container &#123; max-width: 1000px; position: relative; margin: auto;&#125;/* 下一张 &amp; 上一张 按钮 */.prev, .next &#123; cursor: pointer; position: absolute; top: 50%; width: auto; margin-top: -22px; padding: 16px; color: white; font-weight: bold; font-size: 18px; transition: 0.6s ease; border-radius: 0 3px 3px 0;&#125;/* 定位 &quot;下一张&quot; 按钮靠右 */.next &#123; right: 0; border-radius: 3px 0 0 3px;&#125;/* On hover, add a black background color with a little bit see-through */.prev:hover, .next:hover &#123; background-color: rgba(0,0,0,0.8);&#125;/* 标题文本 */.text &#123; color: #f2f2f2; font-size: 15px; padding: 8px 12px; position: absolute; bottom: 8px; width: 100%; text-align: center;&#125;/* 数字文本 (1/3 等) */.numbertext &#123; color: #f2f2f2; font-size: 12px; padding: 8px 12px; position: absolute; top: 0;&#125;/* 标记符号 */.dot &#123; cursor:pointer; height: 13px; width: 13px; margin: 0 2px; background-color: #bbb; border-radius: 50%; display: inline-block; transition: background-color 0.6s ease;&#125;.active, .dot:hover &#123; background-color: #717171;&#125;/* 淡出动画 */.fade &#123; -webkit-animation-name: fade; -webkit-animation-duration: 1.5s; animation-name: fade; animation-duration: 1.5s;&#125;@-webkit-keyframes fade &#123; from &#123;opacity: .4&#125; to &#123;opacity: 1&#125;&#125;@keyframes fade &#123; from &#123;opacity: .4&#125; to &#123;opacity: 1&#125;&#125; JSvar slideIndex = 1;showSlides(slideIndex);function plusSlides(n) &#123; showSlides(slideIndex += n);&#125;function currentSlide(n) &#123; showSlides(slideIndex = n);&#125;function showSlides(n) &#123; var i; var slides = document.getElementsByClassName(&quot;mySlides&quot;); var dots = document.getElementsByClassName(&quot;dot&quot;); if (n &gt; slides.length) &#123;slideIndex = 1&#125; if (n &lt; 1) &#123;slideIndex = slides.length&#125; for (i = 0; i &lt; slides.length; i++) &#123; slides[i].style.display = &quot;none&quot;; &#125; for (i = 0; i &lt; dots.length; i++) &#123; dots[i].className = dots[i].className.replace(&quot; active&quot;, &quot;&quot;); &#125; slides[slideIndex-1].style.display = &quot;block&quot;; dots[slideIndex-1].className += &quot; active&quot;;&#125; 自动播放var slideIndex = 0;showSlides();function showSlides() &#123; var i; var slides = document.getElementsByClassName(&quot;mySlides&quot;); for (i = 0; i &lt; slides.length; i++) &#123; slides[i].style.display = &quot;none&quot;; &#125; slideIndex++; if (slideIndex&gt; slides.length) &#123;slideIndex = 1&#125; slides[slideIndex-1].style.display = &quot;block&quot;; setTimeout(showSlides, 2000); // Change image every 2 seconds&#125;","tags":[{"name":"js","slug":"js","permalink":"https://lirawx.me/tags/js/"}]},{"title":"javascript数组去重","date":"2017-04-26T00:00:00.000Z","path":"2015/js/2017-04-26-arraryrplace.html","text":"思路：1.创建一个新的数组存放结果2.创建一个空对象3.for循环时，每次取出一个元素与对象进行对比，如果这个元素不重复，则把它存放到结果数组中，同时把这个元素的内容作为对象的一个属性，并赋值为1，存入到第2步建立的对象中。说明：至于如何对比，就是每次从原数组中取出一个元素，然后到对象中去访问这个属性，如果能访问到值，则说明重复。 代码Array.prototype.unique3 = function()&#123; var res = []; var json = &#123;&#125;; for(var i = 0; i &lt; this.length; i++)&#123; if(!json[this[i]])&#123; res.push(this[i]); json[this[i]] = 1; &#125; &#125; return res;&#125;var arr = [112,112,34,&apos;你好&apos;,112,112,34,&apos;你好&apos;,&apos;str&apos;,&apos;str1&apos;];alert(arr.unique3());","tags":[{"name":"js","slug":"js","permalink":"https://lirawx.me/tags/js/"}]},{"title":"js小时钟","date":"2017-04-23T00:00:00.000Z","path":"2015/js/2017-04-25-clock.html","text":"实现代码如下： function startTime()&#123;var today=new Date()var h=today.getHours()var m=today.getMinutes()var s=today.getSeconds()// add a zero in front of numbers&lt;10m=checkTime(m)s=checkTime(s)document.getElementById(&apos;txt&apos;).innerHTML=h+&quot;:&quot;+m+&quot;:&quot;+st=setTimeout(&apos;startTime()&apos;,500)&#125;function checkTime(i)&#123;if (i&lt;10) &#123;i=&quot;0&quot; + i&#125; return i&#125;","tags":[{"name":"js","slug":"js","permalink":"https://lirawx.me/tags/js/"}]},{"title":"vue全面介绍--全家桶（vue笔记一）","date":"2017-04-23T00:00:00.000Z","path":"2015/Vue/2017-04-27-vue.html","text":"简介 “简单却不失优雅，小巧而不乏大匠”。Vue.js 是一个JavaScriptMVVM库，是一套构建用户界面的渐进式框架。它是以数据驱动和组件化的思想构建的，采用自底向上增量开发的设计。相比于Angular.js，Vue.js提供了更加简洁、更易于理解的API，使得我们能够快速地上手并使用Vue.js；同时比起 React + Redux 相对复杂的架构，Vue.js 更加轻量级也更加容易上手，是初创项目的首选前端框架。Vue 的核心库只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。并且作者是华人的关系，Vue拥有着对华人开发者最友好的api文档和官方教程。 vue、React、Angular1对比在Angular1中，在scope作用域中每一次数据变化，会触发watcher的重新计算，angular对常用的dom事件，xhr事件等做了封装， 在里面触发进入angular的digest流程。在digest流程里面，会从rootscope开始遍历， 检查所有的watcher。并且，如果一些 watcher 触发另一个更新，脏检查循环（digest cycle）可能要运行多次。Vue则没有这个问题，因为它使用基于依赖追踪的观察系统并且异步队列更新，数据的变化都是独立处罚的，除非数据之间有明确的依赖关系。vue官方宣称vue的渲染性能优于react。为了有理有据让人信服，vue开发团队建立了一个简单的对比性能的项目（https://github.com/chrisvfritz/vue-render-performance-comparisons），它负责渲染10000个列表项100次。Vue官方将每一个参照项目都分别运行 20 次并取最好的结果结果如下图： 由此可见，Vue的性能是远好于Angular1，并且稍微优于React的。 社区拓展对比Angular1的背后是Google，所以社区基础是不需要担心的，从Tutorial到StackOverflow的问题数量都可以反映出生态系统很完整。Vue和React都有强大的社区支持。React有状态管理库Flux、ReduxVue，相应的，Vue有vuex。Vue 和 React 都提供了强大的路由库来应对大型应用。然而Vue的路由库和状态管理库都是由官方维护支持的。React 则是选择把这些问题交给社区维护，因此创建了一个更分散的生态系统。但相对的，React 的生态系统相比 Vue 更加繁荣。此外，Vue 提供了Vue-cli 脚手架，包括了Webpack，Browserify，甚至路由库，能让你非常容易地构建项目。 学习陡峭度对比在指令与组件方面，Vue中将指令和组件分得更清晰。指令只封装 DOM 操作，而组件代表一个自给自足的独立单元，有自己的视图和数据逻辑。在 Angular1 中两者有不少相混的地方。在API与框架设计方面，angular1都比vue要复杂的多。就个人感觉而言，angular1和React的学习曲线会相对陡峭一些，而vue的编码方式会更趋近于前端开发者的编程习惯。因为vue的作者是中国人，vue的官方网站、教程和api肯定是最完善、最易懂的。此外，每次大版本的发布，都会伴随着详尽的迁移说明文档，包含了很多详尽的阐述以及许多迁移的例子，甚至还有迁移工具。 vue的缺点Vue就这么好，难道没有缺点吗？当然有，vue虽然在16年非常火爆，但是相比于angular和react，不论是成熟度还是社区活跃度都还不是对手。此外，Vue明确声明了自己放弃了对IE8的支持。再看看现在的招聘网站上，有多少写了需要有angular经验，而又有多少写了需要vue经验，就可见vue的影响力相比于angular和react还差的很远。 vue全家桶及项目架构Vue有著名的全家桶系列，包含了vue-router（http://router.vuejs.org），vuex（http://vuex.vuejs.org）， vue-resource（https://github.com/pagekit/vue-resource）。再加上构建工具vue-cli，就是一个完整的vue项目的核心构成。 vue-router路由推荐使用npm工具来安装vue-routernpm install vue-router通过import导入并定义Vue模块、vue-router模块和需要使用的组件，在本例中，分别是Goods、Ratings和Seller组件。最后，如果在一个模块化工程中使用它，必须要通过 Vue.use() 明确地安装路由功能。import Vue from’vue’importRouter from’vue-router’ import Goods from ‘@/components/goods/goods’;import Ratings from ‘@/components/ratings/ratings’;import Seller from ‘@/components/seller/seller’; Vue.use(Router); // 需要import Vue和Router，不然会报错undefined通过const router= new VueRouter（）来定义一个路由，并传入对应的配置，包括路径path和组件components。 vuex状态管理Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。如前面所提到的，Vuex 已经集成到 Vue 的官方调试工具vue Devtools，可以轻松的查看项目中的Vuex状态变化情况。假设有这样一个场景：我们的项目规模比较大，有多个父组件，每个父组件同时又包含多个子组件。如何保持对所有时间的追踪将变得很困难。到底哪个事件是哪个组件派发的，哪个组件该监听哪个事件？父组件将变得和子组件耦合越来越严重，因为它需要明确的派发和监听子组件的某些事件。项目逻辑分散在各个组件当中，很容易导致逻辑的混乱，不利于我们项目的维护。这就是 Vuex 用来解决的问题。 Vuex 的四个核心概念分别是：The state tree：Vuex 使用单一状态树，用一个对象就包含了全部的应用层级状态。至此它便作为一个『唯一数据源(SSOT)』而存在。这也意味着，每个应用将仅仅包含一个 store 实例。单状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。Getters：用来从 store 获取 Vue 组件数据。Mutators：事件处理器用来驱动状态的变化。Actions：可以给组件使用的函数，以此用来驱动事件处理器 mutationsVuex和简单的全局对象是不同的，当Vuex从store中读取状态值的时候，若状态发生了变化，那么相应的组件也会高效的更新。并且，改变store中状态的唯一途径就是提交commit mutations。这样便于我们跟踪每一次状态的变化。只要发生了状态的变化，一定伴随着mutation的提交。 vue-resource介绍Vue-resource有体积小，支持IE9以上的浏览器，支持promise特性的特点。同样推荐使用npm来安装Vue-resource。$ npm install vue-resource在安装并引入vue-resource后，可以基于全局的Vue对象使用http，也可以基于某个Vue实例使用http。在发送请求后，使用then方法来处理响应结果，then方法有两个参数，第一个参数是响应成功时的回调函数，第二个参数是响应失败时的回调函数。vue-resource的请求API是按照REST风格设计的，它提供了7种请求API：· get(url,[options])· head(url,[options])· delete(url,[options])· jsonp(url,[options])· post(url,[body], [options])· put(url, [body],[options])· patch(url,[body], [options]) vue工程目录结构 components/文件夹用来存放Vue 组件。个人建议，把每一个组件中使用到的image图片放置到对应的组件子文件目录下，便于统一的管理Node_modules/npm安装的该项目的依赖库vuex/文件夹存放的是和 Vuex store 相关的东西（state对象，actions，mutations)router/文件夹存放的是跟vue-router相关的路由配置项build/文件是 webpack 的打包编译配置文件static/文件夹存放一些静态的、较少变动的image或者css文件config/文件夹存放的是一些配置项，比如服务器访问的端口配置等dist/该文件夹一开始是不存在，在我们的项目经过 build 之后才会产出App.vue根组件，所有的子组件都将在这里被引用index.html整个项目的入口文件，将会引用我们的根组件 App.vuemain.js入口文件的 js 逻辑，在webpack 打包之后将被注入到 index.html 中 Vue核心功能计算属性假设有如下的购物车结算场景，用户选中商品的总金额是根据商品数量、选中商品种类数和商品单价来变化的。然而，数量、选中种类数量和单价这几个对象都是根据用户选择而动态变化的，如果在前端模版中为了计算最终商品总额，放入这几个动态变化的变量（商品数量、商品单价、选中商品种类），会让这个逻辑变得复杂难以维护。在这种情况下，模版便不再简洁清晰。Vue给出了此种场景的解决方案，在任何复杂的逻辑，vue都推荐使用计算属性。 computed vs method也许会有疑问，这个计算属性和定义一个method方法不是差不多么？这两者最大的区别是计算属性是基于它的依赖进行缓存的。计算属性只有在它的相关依赖发生变化时才会重新计算求值。在本例中，只有当选择商品的价格price和数量count发生变化时，这个计算属性totalPrice才会重新计算新的值。这就意味着，只要totalPrice这个值没有发生变化，多次访问该计算属性会立即返回之前的计算结果，而不必再次执行计算。 模版语法Vue.js 使用了基于 HTML 的模版语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模板都是合法的 HTML ，所以能被遵循规范的浏览器和 HTML 解析器解析。Vue的模版语法包括了使用双大括号插入文本、使用v-html插入纯HTML内容、使用v-bind插入对象、类似angular的v-if、v-show、v-for指令、以及过滤器等等。 组件化组件（Component）是 Vue.js 最强大的功能。组件可以封装可重用的代码，通过传入对象的不同，实现组件的复用。举一个简单的组建例子，我们首先编写一个star组件，它就是一个普通的star.vue文件。它的作用就是简单实现了一个五角星。如何在其他的vue文件中使用这个star组件呢？如下图所示，首先通过import引入star组件对象，并在想使用star组件的vue文件中声明注册star组件。现在就可以愉快的通过标签来在该vue文件中任意地方使用star组件了。在你想展示一个五角星的地方，使用一个star标签，就可以轻松完成这个功能。组件实例的作用域是孤立的。这意味着不能在子组件的模板内直接引用父组件的数据。要让子组件使用父组件的数据，我们需要通过子组件的props选项。如本例所示，子组件star要显式的使用props选项声明它期待获得的数据。在这里就是指的“size”和“score”两个变量。我们可以通过父级给子组件star传入大小和数值这两个对象，来实现对子组件的定制化。 过渡效果Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果，可以用简单的几行代码实现酷炫的过渡效果。Vue 提供了 transition 的封装组件，在使用v-if、v-show等方法使得transition内部dom元素发生变化时，可以给任何元素和组件添加 entering/leaving 过渡。当v-show中内容发生变化时，transition组件中的元素会发生状态的改变，在应用了transition封装后，Vue会自动识别目标元素是否应用了CSS过渡效果动画，如果有，会在合适的时机添加 entering/leaving的class来实现该过渡效果。下图所示是一个简单的过渡效果的例子，需要将想实现过渡效果的元素放在transition标签中包裹，通过name=“slide-fade”来声明过渡效果名称，并在对应的vue文件中添加过渡效果的css样式，这样就可以简单的完成该元素的过渡效果。 总结根据不完全统计，包括饿了么、稀土掘金、苏宁易购、美团、天猫、荔枝FM、房多多、Laravel、htmlBurger等国内外知名大公司都在使用vue进行新项目的开发和旧项目的前端重构工作。此外，vue + vuex+ vue-resource + vue-router + webpack + es6 + less的项目架构成为了越来越多大公司的第一选择。","tags":[{"name":"vue","slug":"vue","permalink":"https://lirawx.me/tags/vue/"}]},{"title":"Webpack 入门","date":"2017-04-23T00:00:00.000Z","path":"2015/Vue/2017-04-24-vue_webpack.html","text":"Webpack 是一个前端资源加载/打包工具。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。 打包jsapp/runoob1.js 文件document.write(require(&quot;./runoob2.js&quot;)); webpack runoob1.js bundle.js webpack 根据模块的依赖关系进行静态分析，这些文件(模块)会被包含到 bundle.js 文件中。Webpack 会给每个模块分配一个唯一的 id 并通过这个 id 索引和访问模块。 在页面启动时，会先执行 runoob1.js 中的代码，其它模块会在运行 require 的时候再执行。 LOADERWebpack 本身只能处理 JavaScript 模块，如果要处理其他类型的文件，就需要使用 loader 进行转换。所以如果我们需要在应用中添加 css 文件，就需要使用到 css-loader 和 style-loader，他们做两件不同的事情，css-loader 会遍历 CSS 文件，然后找到 url() 表达式然后处理他们，style-loader 会把原来的 CSS 代码插入页面中的一个 style 标签中。 app/runoob1.js 文件require(&quot;!style!css!./style.css&quot;);document.write(require(&quot;./runoob2.js&quot;)); require CSS 文件的时候都要写 loader 前缀 !style!css!，当然我们可以根据模块类型（扩展名）来自动绑定需要的 loader。 将 runoob1.js 中的 require(“!style!css!./style.css”) 修改为 require(“./style.css”) ：app/runoob1.js 文件require(&quot;./style.css&quot;);document.write(require(&quot;./runoob2.js&quot;)); 然后执行：webpack runoob1.js bundle.js --module-bind &apos;css=style!css&apos; 配置文件我们可以将一些编译选项放在配置文件中，以便于统一管理：创建 webpack.config.js 文件，代码如下所示：app/webpack.config.js 文件module.exports = &#123; entry: &quot;./runoob1.js&quot;, output: &#123; path: __dirname, filename: &quot;bundle.js&quot; &#125;, module: &#123; loaders: [ &#123; test: /\\.css$/, loader: &quot;style!css&quot; &#125; ] &#125;&#125;; 接下来我们只需要执行 webpack 命令即可生成 bundle.js 文件。webpack 命令执行后，会默认载入当前目录的 webpack.config.js 文件。 插件插件在 webpack 的配置信息 plugins 选项中指定，用于完成一些 loader 不能完成的工。webpack 自带一些插件，你可以可以通过 cnpm 安装一些插件。使用内置插件需要通过以下命令来安装：cnpm install webpack –save-dev比如我们可以安装内置的 BannerPlugin 插件，用于在文件头部输出一些注释信息。修改 webpack.config.js，代码如下：app/webpack.config.js 文件var webpack=require(&apos;webpack&apos;);module.exports = &#123; entry: &quot;./runoob1.js&quot;, output: &#123; path: __dirname, filename: &quot;bundle.js&quot; &#125;, module: &#123; loaders: [ &#123; test: /\\.css$/, loader: &quot;style!css&quot; &#125; ] &#125;, plugins:[ new webpack.BannerPlugin(&apos;菜鸟教程 webpack 实例&apos;) ]&#125;; 然后运行 webpack，打开 bundle.js，可以看到文件头部出现了我们指定的注释信息。 开发环境当项目逐渐变大，webpack 的编译时间会变长，可以通过参数让编译的输出内容带有进度和颜色。$webpack --progress --colors 如果不想每次修改模块后都重新编译，那么可以启动监听模式。开启监听模式后，没有变化的模块会在编译后缓存到内存中，而不会每次都被重新编译，所以监听模式的整体速度是很快的。webpack --progress --colors --watch 当然，我们可以使用 webpack-dev-server 开发服务，这样我们就能通过 localhost:8080 启动一个 express 静态资源 web 服务器，并且会以监听模式自动运行 webpack，在浏览器打开 http://localhost:8080/ 或 http://localhost:8080/webpack-dev-server/ 可以浏览项目中的页面和编译后的资源输出，并且通过一个 socket.io 服务实时监听它们的变化并自动刷新页面。# 安装cnpm install webpack-dev-server -g# 运行webpack-dev-server --progress --colors","tags":[{"name":"vue","slug":"vue","permalink":"https://lirawx.me/tags/vue/"}]},{"title":"姜文的一步之遥","date":"2016-12-26T00:00:00.000Z","path":"2015/movie/2016-12-26-yibuzhiyao.html","text":"一直以来对姜文的电影有种从心底里的欢喜，这个不同于其他国人导演的拍片风格，很是吸引人。从让子弹飞到一步之遥，都是民国风，个人对民国也有着文青的特殊向往，那个军阀混战的年代，人民开始追求时尚，追求自由，追求知识，科学等等，一切皆有可能的年代。 姜文谱写了一步之遥，借此讽今，开篇从泡沫出场，预示着本片的电影基调，深刻的批判了当下中国电影的泡沫，终将破灭。To be or not to be. 这便是这部电影的伟大之处，偏要在上映两周年的今天才能读懂的深意。 主角马走日，性格鲜明。电影中买通不成，便冲动行凶。如果马走日，真的想杀王天王，那他可以事先谋划，这并不难。但，他却选择在众目睽睽下，挥拳上台“殴打”对方。这足以体现马走日的孩子气，幼稚的可笑，无论老少都是孩子，用孩子的眼光看待人事。 为解一时之气，宁愿坐牢宁愿被枪毙。 理由很简单，仅为了死去的完颜英的颜面。 傻不傻？ 李安说过，周星驰拍的，都是小孩子的东西。 那么《一步之遥》，我给它的定义，就是一部“成人童话”。 它的主题有两个： 讽刺自命成熟者、讽刺自命成熟的社会。 是的，以一个小孩子的视角。 《一步之遥》表面上是部民国题材电影。 但实际上，它一直都在假借历史，讽刺假大空的、诛心吃人的社会。 青卢和白狐，为了争夺花国总统，费尽心思编排出百老汇级别的精彩表演。 我有一个文青朋友，当年她和我说，只看这段歌舞，就已经值回电影票价了。 《一步之遥》的结局，极不符合普通国产片中惯用的套路。 从头到尾，死掉的只有马走日、完颜英，以及半死不活的武六。 其余的人，看客依旧是看客，军阀依旧是军阀，伪艺术家依旧是伪艺术家。 他们依旧挥舞着武器，只不过有的武器是枪，有的武器是目光，有的武器是镜头。 以上灵感来自毒舌电影。","tags":[{"name":"姜文  一步之遥  电影","slug":"姜文-一步之遥-电影","permalink":"https://lirawx.me/tags/姜文-一步之遥-电影/"}]},{"title":"NO Jquery","date":"2016-11-23T00:00:00.000Z","path":"2015/web/2016-11-23-nojquery.html","text":"JavaScript Functions and HelpersVanilla JS utilities for writing powerful web applications without jQuery. Selecting// select all div tags + link tags with the class &quot;info&quot;var matches = document.querySelectorAll(&quot;div, a.info&quot;);// select all text input fieldsvar matches = document.querySelectorAll(&quot;input[type=&apos;text&apos;]&quot;);var match = document.querySelector(&apos;div.foo&apos;);// equals for the matched elementvar match = document.querySelectorAll(&apos;div.foo&apos;)[0];// select a list of matching elements, context is optionalfunction $(selector, context) &#123; return (context || document).querySelectorAll(selector);&#125;// select the first match only, context is optionalfunction $1(selector, context) &#123; return (context || document).querySelector(selector);&#125;// how to use// select all &apos;.bar&apos; elements inside all &apos;.foo&apos; containersvar matches = $(&apos;.foo .bar&apos;);// context examplevar container = $1(&apos;.foo&apos;);// select &apos;.bar&apos; elements inside this one containervar matches = $(&apos;.bar&apos;, container); var list = document.getElementsByClassName(‘foo’); var list = document.getElementsByTagName(‘a’); var el = document.getElementById(‘foo’); TraversingMatch element selectorCheck the current elements against a CSS selector. To check whether a given element matches a CSS selector, modern browsers support the matches() or matchesSelector() DOM method. Here’s a polyfill for other browsers: // matches polyfillthis.Element &amp;&amp; function(ElementPrototype) &#123; ElementPrototype.matches = ElementPrototype.matches || ElementPrototype.matchesSelector || ElementPrototype.webkitMatchesSelector || ElementPrototype.msMatchesSelector || function(selector) &#123; var node = this, nodes = (node.parentNode || node.document).querySelectorAll(selector), i = -1; while (nodes[++i] &amp;&amp; nodes[i] != node); return !!nodes[i]; &#125;&#125;(Element.prototype); Now you can call matches() on any DOM element: var el = document.querySelector(&apos;span&apos;);console.log(el.matches(&apos;.foo&apos;)); Get parent element nodevar el = document.querySelector(&apos;div&apos;);var parent = el.parentNode; Select the children of an elementvar el = document.querySelector(&apos;div&apos;);var children = el.childNodes, number_of_children = children.length;for (var i=0; i&lt;number_of_children; i++) console.log(children[i].innerHTML); ManipulationCreate a DOM elementvar el = document.createElement(&apos;div&apos;);el.innerHTML = &apos;&lt;p&gt;Hello World!&lt;/p&gt;&apos;;var textnode = document.createTextNode(&apos;Hello World!&apos;);el.appendChild(textnode);document.body.appendChild(el); Replace a DOM element// select the element that will be replacedvar el = document.querySelector(&apos;div&apos;);// &lt;a href=&quot;/javascript/manipulation/creating-a-dom-element-51/&quot;&gt;create a new element&lt;/a&gt; that will take the place of &quot;el&quot;var newEl = document.createElement(&apos;p&apos;);newEl.innerHTML = &apos;&lt;b&gt;Hello World!&lt;/b&gt;&apos;;// replace el with newELel.parentNode.replaceChild(newEl, el); Removing an elementvar el = document.querySelector(&apos;div&apos;);el.parentNode.removeChild(el); Iterating over a list of selected elements var divs = document.querySelectorAll(&apos;div&apos;), len = divs.length;for (var i=0; i&lt;len; i++) &#123; divs[i].style.color = &quot;green&quot;;&#125;Finally, you can use this little trick, that is similar to jQuery&apos;s $.each() method:var divs = document.querySelectorAll(&apos;div&apos;);[].forEach.call(divs, function(item) &#123; item.style.color = &quot;green&quot;;&#125;); AttributesAdding, removing, and testing for classesfunction hasClass(el, className) &#123; return el.classList ? el.classList.contains(className) : new RegExp(&apos;\\\\b&apos;+ className+&apos;\\\\b&apos;).test(el.className);&#125;function addClass(el, className) &#123; if (el.classList) el.classList.add(className); else if (!hasClass(el, className)) el.className += &apos; &apos; + className;&#125;function removeClass(el, className) &#123; if (el.classList) el.classList.remove(className); else el.className = el.className.replace(new RegExp(&apos;\\\\b&apos;+ className+&apos;\\\\b&apos;, &apos;g&apos;), &apos;&apos;);&#125; Setting, getting, and removing data attributesvar el = document.querySelector(&apos;div&apos;);el.setAttribute(&apos;data-foo&apos;, &apos;Hello World!&apos;);var el = document.querySelector(&apos;img&apos;);console.log(el.getAttribute(&apos;data-foo&apos;));el.removeAttribute(&apos;data-foo&apos;); Getting, setting, and removing attributes// set the alt attribute of an elementvar el = document.querySelector(&apos;img&apos;);el.setAttribute(&apos;alt&apos;, &apos;Hello World!&apos;);el.removeAttribute(&apos;alt&apos;);v togglefunction toggle(el) &#123; hasClass(el, &apos;is_hidden&apos;) ? removeClass(el, &apos;is_hidden&apos;) : addClass(el, &apos;is_hidden&apos;);&#125; StylesSet and get CSS styles of elementsThe getComputedStyle() method (IE &lt; 9: currentStyle property) corresponds to the rendered on-page style of an element after all stylesheets were applied. It can be accessed as follows: var el = document.querySelector(&apos;div&apos;);// getComputedStyle for modern browsers, currentStyle for IEvar style = window.getComputedStyle ? getComputedStyle(el, null) : el.currentStyle;// reading propertiesconsole.log(el.backgroundColor);// reading properties containing hyphensconsole.log(el[&apos;-webkit-text-size-adjust&apos;]);var el = document.querySelector(&apos;div&apos;);el.style.backgroundColor = &apos;green&apos;;el.style.display = &apos;none&apos;;el.style[&apos;border-radius&apos;] = &apos;5px&apos;; Multiple styles can be set at once by use of the cssText property: el.style.cssText += &apos;background: green, display: none;&apos;; However, this method is rather slow and therefore it’s better to use instead a little helper for setting multiple styles by an object of key/value pairs: function css(el, styles) &#123; for (var property in styles) el.style[property] = styles[property];&#125;// examplevar el = document.querySelector(&apos;div&apos;);css(el, &#123; background: &apos;green&apos;, display: &apos;none&apos;, &apos;border-radius&apos;: &apos;5px&apos; &#125;); Get and set scroll position of an elementGetting the scroll position of the document in px. var scrollLeft = window.pageXOffset || document.documentElement.scrollLeft, scrollTop = window.pageYOffset || document.documentElement.scrollTop; Setting the document scroll position of the document in px: document.documentElement.scrollTop = document.body.scrollTop = 1000;document.documentElement.scrollLeft = document.body.scrollLeft = 500; AjaxJSONP Ajax requestsJSONP allows asynchronous loading of data, even from servers in a different domain. // define a callback function, which accepts the returned JSON data as its only argumentfunction response(data) &#123; // JSON data in form of a JavaScript object console.log(data);&#125;// create a script tag with the external request URL// include &quot;response&quot; as value of the GET param &quot;callback&quot; in the URLvar script = document.createElement(&apos;script&apos;);script.src = &apos;https://foo.bar/api/?callback=response&apos;;document.body.appendChild(script); Load a script file asynchronouslyHow to load a JavaScript file asynchronously from the server and automatically execute it. var script = document.createElement(&apos;script&apos;), scripts = document.getElementsByTagName(&apos;script&apos;)[0];script.src = url;scripts.parentNode.insertBefore(script, scripts); it’s recommended to use a standard script tag with the async (and defer) attribute included: //&lt;script src=&quot;https://platform.twitter.com/widgets.js&quot; async defer&gt;&lt;/script&gt; Send Ajax GET and POST requestsThe following helper function allows sending an Ajax request via GET method - an equivalent to jQuery’s $.get(). Its url argument must contain the full request path including all GET parameters: function getAjax(url, success) &#123; var xhr = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;); xhr.open(&apos;GET&apos;, url); xhr.onreadystatechange = function() &#123; if (xhr.readyState&gt;3 &amp;&amp; xhr.status==200) success(xhr.responseText); &#125;; xhr.setRequestHeader(&apos;X-Requested-With&apos;, &apos;XMLHttpRequest&apos;); xhr.send(); return xhr;&#125;// example requestgetAjax(&apos;http://foo.bar/?p1=1&amp;p2=Hello+World&apos;, function(data)&#123; console.log(data); &#125;); If the server returns a JSON string, it needs to be parsed inside the callback function ($.getJSON in jQuery): getAjax(&apos;http://foo.bar/?p1=1&amp;p2=Hello+World&apos;, function(data)&#123; var json = JSON.parse(data); console.log(json);&#125;); Sending POST requests is quite similar ($.post() in jQuery). However, there are lots of options available - more than can be covered in one post. Here’s a useful helper function to get you started: function postAjax(url, data, success) &#123; var params = typeof data == &apos;string&apos; ? data : Object.keys(data).map( function(k)&#123; return encodeURIComponent(k) + &apos;=&apos; + encodeURIComponent(data[k]) &#125; ).join(&apos;&amp;&apos;); var xhr = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); xhr.open(&apos;POST&apos;, url); xhr.onreadystatechange = function() &#123; if (xhr.readyState&gt;3 &amp;&amp; xhr.status==200) &#123; success(xhr.responseText); &#125; &#125;; xhr.setRequestHeader(&apos;X-Requested-With&apos;, &apos;XMLHttpRequest&apos;); xhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos;); xhr.send(params); return xhr;&#125;// example requestpostAjax(&apos;http://foo.bar/&apos;, &apos;p1=1&amp;p2=Hello+World&apos;, function(data)&#123; console.log(data); &#125;);// example request with data objectpostAjax(&apos;http://foo.bar/&apos;, &#123; p1: 1, p2: &apos;Hello World&apos; &#125;, function(data)&#123; console.log(data); &#125;); Serialize form data into an arrayEncode a set of form elements as an array of names and values. function serializeArray(form) &#123; var field, l, s = []; if (typeof form == &apos;object&apos; &amp;&amp; form.nodeName == &quot;FORM&quot;) &#123; var len = form.elements.length; for (i=0; i&lt;len; i++) &#123; field = form.elements[i]; if (field.name &amp;&amp; !field.disabled &amp;&amp; field.type != &apos;file&apos; &amp;&amp; field.type != &apos;reset&apos; &amp;&amp; field.type != &apos;submit&apos; &amp;&amp; field.type != &apos;button&apos;) &#123; if (field.type == &apos;select-multiple&apos;) &#123; l = form.elements[i].options.length; for (j=0; j&lt;l; j++) &#123; if(field.options[j].selected) s[s.length] = &#123; name: field.name, value: field.options[j].value &#125;; &#125; &#125; else if ((field.type != &apos;checkbox&apos; &amp;&amp; field.type != &apos;radio&apos;) || field.checked) &#123; s[s.length] = &#123; name: field.name, value: field.value &#125;; &#125; &#125; &#125; &#125; return s;&#125; Serialize form data into a query stringEncode a set of form elements as a string for submission. function serialize(form) &#123; var field, l, s = []; if (typeof form == &apos;object&apos; &amp;&amp; form.nodeName == &quot;FORM&quot;) &#123; var len = form.elements.length; for (var i=0; i&lt;len; i++) &#123; field = form.elements[i]; if (field.name &amp;&amp; !field.disabled &amp;&amp; field.type != &apos;file&apos; &amp;&amp; field.type != &apos;reset&apos; &amp;&amp; field.type != &apos;submit&apos; &amp;&amp; field.type != &apos;button&apos;) &#123; if (field.type == &apos;select-multiple&apos;) &#123; l = form.elements[i].options.length; for (var j=0; j&lt;l; j++) &#123; if(field.options[j].selected) s[s.length] = encodeURIComponent(field.name) + &quot;=&quot; + encodeURIComponent(field.options[j].value); &#125; &#125; else if ((field.type != &apos;checkbox&apos; &amp;&amp; field.type != &apos;radio&apos;) || field.checked) &#123; s[s.length] = encodeURIComponent(field.name) + &quot;=&quot; + encodeURIComponent(field.value); &#125; &#125; &#125; &#125; return s.join(&apos;&amp;&apos;).replace(/%20/g, &apos;+&apos;);&#125; EventsPreventing the default action or bubbling of eventsHow to cancel an event or preventing it from bubbling up the DOM tree. function handler(e) &#123; // stop the immediate action of this event e.preventDefault(); // prevent the event fro bubbling up e.stopPropagation();&#125;// attach handler to the keydown event of the documentif (document.attachEvent) document.attachEvent(&apos;onkeydown&apos;, handler);else document.addEventListener(&apos;keydown&apos;, handler); Getting the keycode from keyboard eventsBinding an event handler to keyboard actions and retrieving the keycode that triggered the event. // event handler functionfunction handler(e) &#123; var key = window.event ? e.keyCode : e.which; console.log(key, e.shiftKey, e.altKey, e.ctrlKey);&#125;// attach handler to the keydown event of the documentif (document.attachEvent) document.attachEvent(&apos;onkeydown&apos;, handler);else document.addEventListener(&apos;keydown&apos;, handler); Getting the current mouse positionHow to get the current mouse position on mouse move or click. // event handler functionfunction handler(e) &#123; e = e || window.event; var pageX = e.pageX; var pageY = e.pageY; // IE 8 if (pageX === undefined) &#123; pageX = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft; pageY = e.clientY + document.body.scrollTop + document.documentElement.scrollTop; &#125; console.log(pageX, pageY);&#125;// attach handler to the click event of the documentif (document.attachEvent) document.attachEvent(&apos;onclick&apos;, handler);else document.addEventListener(&apos;click&apos;, handler); Running code when the document is readyA page can’t be manipulated safely until the document is “ready.” Here’s how to make sure code isn’t run prematurely. function run() &#123; // do something&#125;// in case the document is already renderedif (document.readyState!=&apos;loading&apos;) run();// modern browserselse if (document.addEventListener) document.addEventListener(&apos;DOMContentLoaded&apos;, run);// IE &lt;= 8else document.attachEvent(&apos;onreadystatechange&apos;, function()&#123; if (document.readyState==&apos;complete&apos;) run();&#125;); Trigger an eventHow to create and dispatch events. Corresponding functions to jQuery’s $.trigger(), $.click(), $.blur(), $.keyup(), $.mousedown(), etc. There are a few convenient methods for triggering an event on specific elements:var el = document.querySelector(&apos;input[type=&quot;text&quot;]&apos;);// for any elementel.click();// for inputs and textareasel.focus();el.blur();// for form elementsvar my_form = document.querySelector(&apos;form&apos;);my_form.submit();my_form.reset(); If you need to trigger other events, such as mousedown or keyup, use the following helper function: function triggerEvent(el, type)&#123; if (&apos;createEvent&apos; in document) &#123; // modern browsers, IE9+ var e = document.createEvent(&apos;HTMLEvents&apos;); e.initEvent(type, false, true); el.dispatchEvent(e); &#125; else &#123; // IE 8 var e = document.createEventObject(); e.eventType = type; el.fireEvent(&apos;on&apos;+e.eventType, e); &#125;&#125; Usage example: var el = document.querySelector(&apos;input[type=&quot;text&quot;]&apos;);triggerEvent(el, &apos;mousedown&apos;); EffectsAnimate an element propertyHow to do animations, such as fading, sliding, or just toggling visibility with JS and CSS3. Animations in JavaScript aren&apos;t difficult to accomplish. As an example, two functions that behave similar to jQuery&apos;s $.fadeIn() and $.fadeOut():// fade an element from the current state to full opacity in &quot;duration&quot; msfunction fadeOut(el, duration) &#123; var s = el.style, step = 25/(duration || 300); s.opacity = s.opacity || 1; (function fade() &#123; (s.opacity -= step) &lt; 0 ? s.display = &quot;none&quot; : setTimeout(fade, 25); &#125;)();&#125;// fade out an element from the current state to full transparency in &quot;duration&quot; ms// display is the display style the element is assigned after the animation is donefunction fadeIn(el, duration, display) &#123; var s = el.style, step = 25/(duration || 300); s.opacity = s.opacity || 0; s.display = display || &quot;block&quot;; (function fade() &#123; (s.opacity = parseFloat(s.opacity)+step) &gt; 1 ? s.opacity = 1 : setTimeout(fade, 25); &#125;)();&#125; Hide or show an elementfunction hide(el) &#123; el.style.display = &apos;none&apos;;&#125;function show(el, value) &#123; el.style.display = value;&#125;function toggle(el, value) &#123; var display = (window.getComputedStyle ? getComputedStyle(el, null) : el.currentStyle).display; if (display == &apos;none&apos;) el.style.display = value; else el.style.display = &apos;none&apos;;&#125; toogle() can be used to switch between visible and invisible. If you don’t want to or cannot pass in the target display value manually, it gets more complicated. The following helpers are basically vanilla JavaScript clones of jQuery’s $.show() and $.hide(). // get the default display style of an elementfunction defaultDisplay(tag) &#123; var iframe = document.createElement(&apos;iframe&apos;); iframe.setAttribute(&apos;frameborder&apos;, 0); iframe.setAttribute(&apos;width&apos;, 0); iframe.setAttribute(&apos;height&apos;, 0); document.documentElement.appendChild(iframe); var doc = (iframe.contentWindow || iframe.contentDocument).document; // IE support doc.write(); doc.close(); var testEl = doc.createElement(tag); doc.documentElement.appendChild(testEl); var display = (window.getComputedStyle ? getComputedStyle(testEl, null) : testEl.currentStyle).display iframe.parentNode.removeChild(iframe); return display;&#125;// actual show/hide function used by show() and hide() belowfunction showHide(el, show) &#123; var value = el.getAttribute(&apos;data-olddisplay&apos;), display = el.style.display, computedDisplay = (window.getComputedStyle ? getComputedStyle(el, null) : el.currentStyle).display; if (show) &#123; if (!value &amp;&amp; display === &apos;none&apos;) el.style.display = &apos;&apos;; if (el.style.display === &apos;&apos; &amp;&amp; (computedDisplay === &apos;none&apos;)) value = value || defaultDisplay(el.nodeName); &#125; else &#123; if (display &amp;&amp; display !== &apos;none&apos; || !(computedDisplay == &apos;none&apos;)) el.setAttribute(&apos;data-olddisplay&apos;, (computedDisplay == &apos;none&apos;) ? display : computedDisplay); &#125; if (!show || el.style.display === &apos;none&apos; || el.style.display === &apos;&apos;) el.style.display = show ? value || &apos;&apos; : &apos;none&apos;;&#125;// helper functionsfunction show(el) &#123; showHide(el, true); &#125;function hide(el) &#123; showHide(el); &#125; UtilitiesParsing a JSON stringTakes a well-formed JSON string and returns the resulting JavaScript value. var json = &apos;&#123; &quot;foo&quot;: true, &quot;bar&quot;: 1 &#125;&apos;, obj = JSON.parse(json);console.log(obj); Strip leading and trailing white-space from string Remove white-space characters from the beginning and end of a string. // IE 8if (!String.prototype.trim) &#123; String.prototype.trim = function()&#123; return this.replace(/^\\s+|\\s+$/g, &apos;&apos;); &#125;;&#125;// examplevar s = &apos; Hello World! &apos;;s = s.trim();console.log(s);// &quot;Hello World!&quot; Set cookie, get cookie and delete cookiefunction getCookie(name) &#123; var v = document.cookie.match(&apos;(^|;) ?&apos; + name + &apos;=([^;]*)(;|$)&apos;); return v ? v[2] : null;&#125;function setCookie(name, value, days) &#123; var d = new Date; d.setTime(d.getTime() + 24*60*60*1000*days); document.cookie = name + &quot;=&quot; + value + &quot;;path=/;expires=&quot; + d.toGMTString();&#125;function deleteCookie(name) &#123; setCookie(name, &apos;&apos;, -1); &#125;","tags":[{"name":"前端 javascript jquery","slug":"前端-javascript-jquery","permalink":"https://lirawx.me/tags/前端-javascript-jquery/"}]},{"title":"前端开发，从草根到英雄(总结)","date":"2016-11-22T00:00:00.000Z","path":"2015/web/2016-11-22-learn-js.html","text":"文章信息：原文： zero to front-end hero From Zero to Front-end Hero (Part 2) 作者：@Jonathan Z. White 翻译： 前端开发，从草根到英雄（第一部分） 前端开发，从草根到英雄（第二部分） 译者：jieniu 总结HTML CSS基础练习工具 CodePen Dribbble 练习使用html，css，包裹google字体的api和google字体的css技巧，当然还有排版。要将注意力放在html，css在一起时如何工作的。然后再dribble这个网站上寻找灵感，在codepen上编写代码。 要点 语义标记 css命名约定 css重置 跨浏览器支持 css预处理器和后处理器 网格系统和响应式 最后要保持更新，从一个又一个例子中学习。 JavaScript基本知识语言 语法和类型 控制流河错误处理 循环和遍历 函数 交互文档对象模型（DOM） 什么是DOM？ 如何查询元素？ 如何添加事件监听者？ 如何合适的改变DOM节点属性？ 检查调试JavaScript 进阶知识语言 强化原型 作用域 闭包 事件循环 事件通知 请求、调用和绑定 回调和承诺 变量及函数挂起 Currying Imperative vs. DeclarativeJavaScript和DOM如何交互，有两种方法：imperative和declarative，一方面，declarative程序专注于what，另一方面，imperative程序专注于how。Jquery是imperative方法，然后才是Angular和React库declarative方法 Ajax新的浏览器请求标准是Fetch jQueryjQuery不是唯一的imperative DOM操作解决方案，PlainJS和You Might Not Need jQuery是两个很好的资源，他们会告诉你和jQuery一样的频繁使用的JavaScript函数。 ES5 vs. ES6有必要知道你今天看到的应用，要么使用ES5，要么使用ES6。ES5，ES6，ES2016，ES.Next: JavaScript版本到底怎么了和Dan Wahlins的ES6入门——下一代JavaScript是很好的ES6介绍。接着你可以在ES6功能列表查看ES5到ES6的变化。如果你还想了解更多，去Github代码库获得更多ES6功能信息。 JavaScript框架Angular，React + Flux，Ember，Aurelia，Vue，和Meteor。你不需要学习所有的框架，选一个学习即可，不要追赶框架的潮流，取而代之的是，你需要理解框架程序底下的原则和哲学。 架构模型MVC MVVM 与其让HTML保留应用状态，还不如用一个JavaScript对象——通常被称为Model——来存储状态。 设计模式 装饰者模式 工厂模式 单件模式 Revealing module 外观模式 观察者模式 AngularJSAngularJS是一个JavaScript MVC框架，有时也是一个MVVM框架，它由google维护，并在2010年初次发布时给JavaScript社区带来了一场风暴 React + FluxAngular很好解决了程序员在构建复杂系统时所面对的问题，另一个流行的工具是React，它是一个创建用户接口的库，你可以把它想象成MVC中的V。由于React只是一个库，所以它会经常伴随着一个框架Flux 风格指南JavaScript风格指南是一组代码规范，它会帮助你设计具有可读性和可维护性高的代码。 AirBnB的编码规范 常用的JavaScript原则 Node编码规范 MDN编码规范 编码基础我已经无法形容读好代码给我带来的帮助到底有多大，一旦当你想读新的好代码时，可以上Github上找 Lodash Underscore Babel Ghost NodeBB KeystoneJS 许多时候，人在做，天在看。","tags":[{"name":"前端 javascript css html","slug":"前端-javascript-css-html","permalink":"https://lirawx.me/tags/前端-javascript-css-html/"}]},{"title":"一个人，一座城","date":"2016-06-24T00:00:00.000Z","path":"2015/2016-06-24-one-men-one-city.html","text":"每个人心里都有一座城，一个人，不曾走远，不敢走近，只是因为那里有一段刻骨铭心的记忆，无法触碰，满是伤怀，每每想起。寂寞有时，伤心有时，哭泣有时，大笑有时。不经意的一个字眼跳出来，使我想起你，一想想个不停，然而伊人已不在身旁，唯有用记忆去填补你的空缺。如果，我说如果，我再见到你，我们之间第一句话会说什么呢，是原来你还在这，还是我过得很好你呢，还是低头不语，转身离开。我想我会说，我一直很想你。斯人已往，话语的界限早已被阻隔在心房外，就算是一墙之隔，也是千山万里远了。最近我很帅，你知道吗，我晚上睡得很早，早上起的很准时。你还是一样的赖床吗，你是否还依然保留着你唯一的爱好，睡觉呢。我过得很好，每天看看书，上上网，听听歌，一切都很完美，只是怀里少了一个你，有点冷，不用担心，我很好，也祝福你过得很好，真心的祝你遇见至少知冷暖的，冷的时候要抱着你，下雨的时候也要抱着你，你要走的时候也要抱抱你。每天要跟你说很多的情话，我已经不能在你身边了，也不能赴约陪你在草地上看白云变换成你的样子了。谢谢你了，陪我走了那么远，教会了我那么多，原来爱一个人是这样的。再见了，不，永别好了。(●’◡’●)","tags":[{"name":"一个人","slug":"一个人","permalink":"https://lirawx.me/tags/一个人/"}]},{"title":"一生只爱一个人","date":"2016-05-27T00:00:00.000Z","path":"2015/2016-05-27-one-life-one-lover.html","text":"对不起，还是没能忘掉你，尝试了很多次，我以为我能忘，结果却越是忘不掉，我很没用。今夜又是一个这样的夜晚，我想了好多我们一起看电影，一起吃饭，一起压马路，一起在那个长亭，一起看星星，无数个画面都历历在目，叫我如何忘，我努力不去打扰你，希望你过得比我好，最好遇到一个不会冷落你，不会跟你生气的人。听说忘记一个人最好的方法是谈另一场恋爱，找一个人代替你的位置，朋友也给我介绍过一两个，然而每次我和她们聊，总想到你，想到你，我就觉得这样不对，她们怎么可以就这样轻易的抹去你在我心里的痕迹，越这样想，泪越止不住的流。今生今世再也见不到你，人生没有丝毫意义。曾经纵酒长醉，曾经深夜难眠，一切都随着你的离去而暗淡。这一生只爱过你一个，泪只为你流。原谅我作为一个男人，这样的拖泥带水，这样的烦人，可是爱一个人有错么，我只是想想一个男人一样对自己所爱的人说一句:我爱你。我幼稚也罢，我不要脸也罢，我混蛋也罢，可是我觉得我也是人，何况是个男人，我这些话不对自己爱的女人说，又能对谁说，也许我的木讷，冷漠，让你没有感受到我的心意，甚至让你丧失了耐心，放弃了我，我不怪你，我恨我自己的懦弱当时为什么没有像个男人一样飞过去抱住你在你耳边说我多么爱你。此生有缘无分，愿来世能再遇见你，我死都不放开你的手。 ########2016年5月27日00:22","tags":[{"name":"静静","slug":"静静","permalink":"https://lirawx.me/tags/静静/"}]},{"title":"网易云翻读电台（自用推荐）","date":"2016-05-22T00:00:00.000Z","path":"2015/2016-05-22-netmusic-radio.html","text":"推荐一个电台，名字很是诗意，叫月半明时，主播是天阶TJ，最新一期是春色年年。 初次听时只觉得主播声音很好听，昨天无意间打开了网易云音乐，听了不一会，我慢慢被代入了这样诗意的情景，少年离乡，几十年官场浮沉，当少年不再。。。。（zZZZZZ）剩下的我就不知道了，等我醒了已经天黑了。挺对不起这个主播的，催眠曲了被我当成。但是听她的电台翻读，真的有一种令人心安的力量，无论是声线也好还是翻读的内容选材上也好，都恰倒好处。以下是最新一期的原文： 少年背着行囊出城时，正下着细细密密的雨。走过了城外的石桥，走过了石桥边的小茶棚，再回头时，城门上青灰色的“扬州”二 字已经被雨雾隔了很远，模模糊糊，就像时光流走时的模样。他握着伞柄的手紧了紧，转身走向了春草绵延的远方。 辗转十数年，南唐开国。少年也不再是少年，他入了京都，风华正茂一身才艺，被国君几番青眼，而后出仕入相。然而，在那个风雨飘摇的年代，世事无常几乎刻进了每一寸光阴里。朝堂中的党派之争，强国环峙的天下格局，无一不在动摇着南唐的根基。 长久地在官场沉浮，两次出任宰相，几起几落，已知天命的他早已经见惯春秋。年年烟雨，却依旧忍不住贪恋，低声询问白驹过隙的岁月：年年春光，不知这样的燕子，这样的亭台，会年年都有吗？ 最后的两年，他被罢去宰相的官职。日日花前常病酒，不辞镜里朱颜瘦。听着屋檐下落花的声音，从前的闲愁却不在了。后来终于又起了迷蒙雨雾，还是少年时候的那座扬州城，还是那座风波桥，他拄着杖藜远远地望着，白鹤飞向了江天一线处，垂髫孩童的纸鸢仍在流云那端。 他去世当年，赵匡胤黄袍加身。又十五年，北宋灭唐，而后吴越王入开封，五代十国彻底退出历史舞台。 他是南唐词人冯延巳，字正中，笔下多闲情逸致，王国维先生曾赞其“虽不失五代风格，而堂庑特大，开北宋一代风气。”","tags":[{"name":"春色年年","slug":"春色年年","permalink":"https://lirawx.me/tags/春色年年/"}]},{"title":"再也不回头","date":"2016-05-04T00:00:00.000Z","path":"2015/2016-05-04-20160504.html","text":"262 我与你曾经只有0.1cm的距离，而现在我们却隔了12219步，我向你走了12218步，最后一步我抬起又落下，然后，转身，再也不回头。 150816160504 2016-05-04","tags":[{"name":"再也不回头","slug":"再也不回头","permalink":"https://lirawx.me/tags/再也不回头/"}]},{"title":"初爱","date":"2016-04-20T00:00:00.000Z","path":"2015/2016-04-20-20160420.html","text":"阶前初见，也似重逢。 粉罗裙，青丝绾， 眉眼情浓， 羞脸粉红生。 长街长，短亭短， 细语呢哝娇做嗔， 膝枕春风稍歇。 梦呓酒醒空屏， 飞雨沾湿罗衣。 #####2016-04-20","tags":[{"name":"初见","slug":"初见","permalink":"https://lirawx.me/tags/初见/"}]},{"title":"恨","date":"2016-03-27T00:00:00.000Z","path":"2015/2016-03-27-20160327.html","text":"偏也爱风尘， 总是负前缘， 秋去春来有时尽， 此恨无绝期。 去年阶前雨， 风吹了无痕， 却是旧杨发新芽， 一枝一叶总关情。 #####2016-03-27","tags":[{"name":"恨","slug":"恨","permalink":"https://lirawx.me/tags/恨/"}]},{"title":"关山月","date":"2016-03-13T00:00:00.000Z","path":"2015/2016-03-13-20160313.html","text":"去年此门中， 庭榭旧时， 春光三月老， 人面何处？ 一时蝶儿舞， 尽付深情， 挽袖荷花香， 半塘婷婷， 信步闲庭晚， 鸣婵炎炎， 将心与你心， 盈盈笑语， 几多情许卿？ 怎堪回首， 别时敬亭山， 《关山月》同。 #####2016-03-13","tags":[{"name":"关山月","slug":"关山月","permalink":"https://lirawx.me/tags/关山月/"}]},{"title":"我的2016","date":"2016-02-07T00:00:00.000Z","path":"2015/2016-02-07-20160207.html","text":"2016，一切都是最好的安排。 #####2016-02-07","tags":[{"name":"2016","slug":"2016","permalink":"https://lirawx.me/tags/2016/"}]},{"title":"雪中歌","date":"2016-01-14T00:00:00.000Z","path":"2015/2016-01-14-20160114.html","text":"雪一场，梦呓回，听歌几时，欲听还休，欲听还休，再从头，列表循环，又一年，人在，情在，有歌有诗，有美酒，一切都是最好的安排。 #####2016-01-14","tags":[{"name":"雪中歌","slug":"雪中歌","permalink":"https://lirawx.me/tags/雪中歌/"}]},{"title":"陌路末路","date":"2015-11-17T00:00:00.000Z","path":"2015/2015-11-17-20151117.html","text":"今夕今惜，陌路末路，遗忘已枉，末世漠视，一时一世。 . #####2015-11-17","tags":[{"name":"陌路末路","slug":"陌路末路","permalink":"https://lirawx.me/tags/陌路末路/"}]},{"title":"对未来的思考","date":"2015-10-25T00:00:00.000Z","path":"2015/2015-10-25-future.html","text":"怪我多喝一包咖啡，到现在都没有睡着，想了很多，很少有这时候独自思考这么多了，或许不曾孤独如此良久。我再想以后我到底会怎么样，有什么爱好，有什么工作，又怎么样过好自己的生活，说不定单身一直，也说不定已经携伊人的手了。仔细的回想了以前的以前，久到小学可能，一直喜欢笛子啊，之类的，特别中意武侠，手持一支笛子，背负一把长剑，帅气。可能是自己身为中国人深深的继承了中国古老的传统也不一定。或许我以后应该学着吹下笛子，小时候直到现在都不知道自己喜欢什么，会做什么，很多都是凭感觉，觉得挺好就挺好，太过随意了现在觉得。太过飘忽不定，我觉得起码现在我应该要确定以及肯定一下自己以后的发展道路了。或许是分手之后长长的空虚寂寞区间，让我也反思了许多。身在21世纪，我却许多次想摆脱这个浮华的世纪带快我的脚步，拒绝微信，拒绝qq，拒绝淘宝之类过激的举动，现在一一妥协，慢慢融入自己的生活，当然问题当然不是变与不变，与加速度一样，身在这个社会怎么可能逃过物理法则。我想说的是这些过快的浮华和过多的诱惑导致我如今不知道该如何是好，一路走来，磕磕绊绊，迷雾重重，会掩盖本来的面目。想来我已经谈了三次主要的恋爱，第一次记住了一个名字，第二次记住了一个qq号，第三次记住了一个电话号码，三次都不能释怀，三次让我也成长了不少。曾经看过读者，记得有一篇文章写，幸福需要等，不要急着去寻找。三次我都以为是上天给我的暗示，我成功的把握住了，期间我也体会到了什么事爱，爱一个人的感觉无论隔着多远，多久，心总是充满热量，激动愉悦，面对所爱的人，那一刻你觉得世界那么美好，美好到今生只为遇见你。然而第二个女友问我：当激情褪去，你还会爱她么？我竟然无言以对，或许只是头脑里激素的一阵悸动，分泌失调。我这样逃避自己和她。我意识到自己善变到了精神都不正常的地步，经常强迫自己还有别人跟自己头脑里的印象重合，每个人都必须和自己投影是一致的，不一致要修正，感觉自己就是上帝一样，谁都是有罪的，都必须向自己赎罪。所以我要告诉自己要保持谦卑，要保持好奇心，要懂得尊敬，要保持希望，要永远乐观，还要一直学习新的东西，最后最重要的要坚持下去。我觉得父母给我最好的教育就是没有限制我的可能性，我也表现的很懂事，当然现在远在家外，我也很少联系他们，但是我知道我是爱他们的，家庭给我最大的最好的就是要读书，我一直保持着对读书的渴望，不读书总会有一种莫名的愧疚感。我觉得这一生都无法改变这一习惯。这一切都来自我的家庭教育。上高中之前可以说是为父母他们读书，那么上大学必须要为自己读书了，大一我确定是为自己读书，尝试了很多不同的东西，然而还是被自己的原则全都否决了，退掉所有社团，推掉所有的责任，一个人独自的玩耍，导致大二被大学上了一年。大三我觉得我要吧大学上一遍才行。我想了想自己的计划，我想看书时必要的，其次还得练字，行书吧，楷书已经不适合我了。保留自己文艺气息，保持自己的审美。大学毕业不要马上工作，我想去外面走走，见见除开景区以外的世界。比如台湾，比如苏州，比如日本。可以打工换食宿在国内，其他的就只能攒钱了。我想以后要开一家不一样的书店，可以加上现代的科技，互联网之类的元素。先想到这里吧。","tags":[{"name":"想想","slug":"想想","permalink":"https://lirawx.me/tags/想想/"}]},{"title":"谁说的青春无悔","date":"2015-10-20T00:00:00.000Z","path":"2015/2015-10-20-diary.html","text":"谁说的青春无悔，我怎么天天都在回望昨日一往情深，不懂什么是爱，现在已经麻木了，何人还爱，何人敢爱，又有谁来爱我。口口声声不悔不回头，渐渐的丢失了底线，然而周围已经没有了可以将心托付的人了，以前可能还有，暧昧多于友谊，然而只能是友谊，不懂为什么她答应又拒绝，或许她比我懂得多，那时我竟然不懂，不明白，原因，太多话没有说明，太多情没有诉尽，太多人还不了债。想来这便是人生？我不懂，我也不知道我怎么去选择，我想让时间划过，但我又想阻延时间，却抓不住，时间在风中溜走。或许我便是矛盾的一生，我期待一个英雄驾着云彩，携我出周身荆棘缠绕，世界一片光明。 2015-10-20","tags":[{"name":"想想","slug":"想想","permalink":"https://lirawx.me/tags/想想/"}]},{"title":"江上有感","date":"2015-10-15T00:00:00.000Z","path":"2015/2015-10-15-20151015.html","text":"江岸郎情，前朝栏杆，不能拍，河堤妾意，妖娆柳腰，不堪抚，余辉仍在，故人已远，不曾想，晚风轻抚，多情离别，不甚伤。 #####2015-10-15","tags":[{"name":"江上有感","slug":"江上有感","permalink":"https://lirawx.me/tags/江上有感/"}]},{"title":"生活，需要一些仪式感","date":"2015-09-24T00:00:00.000Z","path":"2015/2015-09-24-life-need-ceremony.html","text":"最近读了一篇文章，题目是生活，需要一些仪式感我引用一下特有感觉的话： 我向来觉得生活是需要一些仪式感的，这跟矫情无关，而是关于你对生活的热爱，对幸福的敏感，乃至有时候它是一种结束，也是一种开始。 今天的中国人的生活方式似乎少了一些情趣，生活节奏越来越匆忙，生命中越来越缺乏仪式感，而没有仪式感，人生就不庄严，心就不安静。 人人都爱蒂凡尼的早餐，可是却鲜少有人扭头看看自己在生活里，仪式感有多么匮乏。 我仔细的将这些句子在口舌咽喉之间来回可以说是像牛一样反刍，一字一句，我虔诚的像基督徒一样，我认为之前我有罪，没有一丝一毫的仪式感，感到空虚，之前的生活突然觉得没有任何意义，我感到莫大的罪孽，我深深的忏悔，我告诫我自己，要给自己一点点的仪式感，如同刷牙洗脸一样将仪式终身进行下去。 我重拾咖啡，将咖啡放入马克杯，再倒入沸水，一切都是那样的充满敬意，神圣无犯，我知道，这是一种仪式，未来我每天都要进行的仪式。我的心在陶瓷勺搅拌之中随着咖啡粉末融化了，那一刻我从心底里觉得我得到了救赎。像极了肖生克越狱成功后的喜悦。 我不能劝导所有人都要喝咖啡，或者喝茶。我想说的是我同意作者的看法，我遵循仪式，我保持我对仪式的虔诚，坚定我的信仰，我以此来慰借我的罪恶灵魂，一杯咖啡喝完，世间那么的美好。","tags":[{"name":"life","slug":"life","permalink":"https://lirawx.me/tags/life/"}]},{"title":"mac下zsh的安装","date":"2015-09-22T00:00:00.000Z","path":"2015/2015-09-22-mac-zsh.html","text":"mac下zsh的安装 下载oh-my-zsh 1) 直接用git从github上面下载包：git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh 2) 备份已有的zshrc(一般不需要) cp ~/.zshrc ~/.zshrc.orig 3) 替换zshrc cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc 将bash切换为zsh chsh -s /bin/zsh 其实还可以用which来定位（特别是ubuntu的童鞋） chsh -s `which zsh` 直接用zsh会很蛋疼，因为zsh功能很强大但是太复杂，所以需要oh-my-zsh来将它简单化。如果要切换回去： chsh -s /bin/bash","tags":[{"name":"zsh","slug":"zsh","permalink":"https://lirawx.me/tags/zsh/"}]},{"title":"inui n1","date":"2015-09-17T00:00:00.000Z","path":"2015/2015-09-17-iuni-n1.html","text":"一次冲动是必然，两次冲动就是命运了。第一次u2出来我就看中它了，系统也好，手机也好，深深的符合我的审美，与个性。现在，n1第四代深深的震撼了我，怎么可以这么美， 美到窒息，犹豫再三还是下单买下它。不论多少人黑它黑这个品牌，有些事是不会改变，就是人从心底发出的爱。我爱这个品牌，以及这个品牌i am unique的寓意。这也反过来印证了我是个文艺2b青年，全民自黑的时代，文艺青年也是自黑的意思，而我并没有这点想法，我深深的引以为傲自己在这个浮华冷峻的社会还能保持自己的文艺也好，2b也好.我觉得inui n1是前世的情人一般，第一眼便已经定情，此生无怨无悔的爱上它。今天是它到达的日子，我就像等待新娘到来一般的，焦躁，急促，早早的准备好它到来的app，甚至是想好了为它留的席位。而当它到来的时候，我彻底的惊艳了，不负我深爱一场，各种功能简约，纯净，不浮夸，精致而美好，作为新郎的我，沾沾自喜，向别人夸耀内人的贤惠，聪颖，我视它为掌上明珠，捧着它都会笑出声来，感谢今生让我遇见你—-iuni n1。","tags":[{"name":"想想","slug":"想想","permalink":"https://lirawx.me/tags/想想/"}]},{"title":"真的爱你（李嘉琪、张惠春）","date":"2015-09-13T00:00:00.000Z","path":"2015/2015-09-13-zhen-de-ai-ni.html","text":"试听链接 词：梁美薇,刘卓辉曲：黄家驹 李：无法可修饰的一对手带出温暖永远在背后纵使啰嗦始终关注不懂珍惜太内疚张：一个人在创痛的时候按着难以痊愈的伤口究竟应该拼命奋斗还是默默地溜走只有你会理解我的忧让我紧紧握住你的手李：是你多么温馨的目光教我坚毅望着前路叮嘱我跌倒不应放弃没法解释怎可报尽亲恩爱意宽大是无限请准我说声真的爱你张：一个人在孤独的时候走到人群拥挤的街头是在抗议过分自由还是荒谬的地球李：仍记起温馨的一对手始终给我照顾未变样理想今天终于等到分享光辉盼做到合：春风化雨暖透我的心一生眷顾无言地送赠张：我们曾经一样地流浪一样幻想美好时光合：一样的感到流水年长张：我们虽然不在同一个地方没有相同的主张合：可是你知道我的迷惘李：Amani nakupenda nakupenda we we张：Amani nakupenda nakupenda we we合：就让我们一起李：Amani nakupenda nakupenda we we张：Amani nakupenda nakupenda we we合：对全世界呐喊Amani nakupenda nakupenda we weAmani nakupenda nakupenda we we李：Amani nakupenda nakupenda we we","tags":[{"name":"李嘉琪","slug":"李嘉琪","permalink":"https://lirawx.me/tags/李嘉琪/"}]},{"title":"新的心跳 - G.E.M. 邓紫棋","date":"2015-09-13T00:00:00.000Z","path":"2015/2015-09-13-xin-tiao.html","text":"试听链接 (真人秀《极速前进 第二季》主题曲)词：G.E.M. 邓紫棋曲：G.E.M. 邓紫棋 也许 你看过太多悲剧 也受过太多委屈 你怕不愿回首的过去 会一直延续 但生命 够曲折才够真实 人痛过才够坚持 而故事 还没有走到结局 就让我们 忘了过去有多悲伤 打开受伤的翅膀 来为自己戴上 掉下的皇冠 无论世界有多疯狂 我们是浴火的凤凰 经过了燃烧 有新的心跳 新的心跳 新的心跳 新的心跳 爱是 受伤过才够轰烈 牺牲过才够真切 而且 时间还未停歇 就让我们 忘了过去有多悲伤 打开受伤的翅膀 来为自己戴上 掉下的皇冠 无论世界有多疯狂 我们是浴火的凤凰 经过了燃烧 有新的心跳 有新的心跳 有新的心跳 有新的心跳 就用微笑哀悼 死去是复活的先兆 听未来的呼召 埋葬忧伤痛苦的煎熬 旧事再不重要 一切已经来到 永远的句号 我们死而复活 我们失而复得 旧事已过 都变成新的 新的心跳 新的心跳 新的心跳 新的心跳 新的心跳 新的心跳 新的心跳 新的心跳 新的心跳","tags":[{"name":"G.E.M.邓紫棋","slug":"G-E-M-邓紫棋","permalink":"https://lirawx.me/tags/G-E-M-邓紫棋/"}]},{"title":"反思（1）","date":"2015-09-13T00:00:00.000Z","path":"2015/2015-09-13-lunhua.html","text":"今天重拾轮滑，怎么说呢，做什么事，一丝动机就够了，其实出去走走看看，还能看到不一样的风景。一开始穿上鞋子到滑上路，感觉是很熟悉一样，就像学会骑自行车，一生就会一样，风在飞驰，滑轮在旋转，路上人的表情来不及看清就已经掠过，只一道道残影甩在身后。虽然摔了三次，膝盖破皮，但是倒地的一瞬间，整个人人字躺在地上特别有成就感。特别适合一首歌，新的心跳。歌词如下： (真人秀《极速前进 第二季》主题曲) 词：G.E.M. 邓紫棋 曲：G.E.M. 邓紫棋 也许 你看过太多悲剧 也受过太多委屈 你怕不愿回首的过去 会一直延续 但生命 够曲折才够真实 人痛过才够坚持 而故事 还没有走到结局 就让我们 忘了过去有多悲伤 打开受伤的翅膀 来为自己戴上 掉下的皇冠 无论世界有多疯狂 我们是浴火的凤凰 经过了燃烧 有新的心跳 新的心跳 新的心跳 新的心跳 爱是 受伤过才够轰烈 牺牲过才够真切 而且 时间还未停歇 就让我们 忘了过去有多悲伤 打开受伤的翅膀 来为自己戴上 掉下的皇冠 无论世界有多疯狂 我们是浴火的凤凰 经过了燃烧 有新的心跳 有新的心跳 有新的心跳 有新的心跳 就用微笑哀悼 死去是复活的先兆 听未来的呼召 埋葬忧伤痛苦的煎熬 旧事再不重要 一切已经来到 永远的句号 我们死而复活 我们失而复得 旧事已过 都变成新的 新的心跳 新的心跳 新的心跳 新的心跳 新的心跳 新的心跳 新的心跳 新的心跳 新的心跳","tags":[{"name":"轮滑","slug":"轮滑","permalink":"https://lirawx.me/tags/轮滑/"}]},{"title":"2015年生日记","date":"2015-09-12T00:00:00.000Z","path":"2015/2015-09-12-birthday2015.html","text":"昨天是2015年22岁的生日，我觉得是过生日以来过的最好的一次了，以前生日并没有什么像样的活动之类，突然觉得好幸福。昨天碰巧是lol的战斗之夜活动，我11号去留了几台机子，早上2楼我们宿舍，还有6楼的4个，8个人就去玩了一会，中午吃饭大家都开心的开玩笑，聊天，其乐融融自不必说。虽然被灌了两杯啤酒，有种想吐的感觉。不过还是挺开心的。重头戏当然是蛋糕了，我们一起吹的蜡烛，并没有什么特别的愿望，只希望我关心的，关心我的都能好好的。谢谢qq上发来生日祝福的，谢谢你们。我没法发蛋糕给你们，但是心意收到了。 2015-09-13","tags":[{"name":"想想","slug":"想想","permalink":"https://lirawx.me/tags/想想/"}]},{"title":"苦涩的椰汁奶茶","date":"2015-09-10T00:00:00.000Z","path":"2015/2015-09-10-ye-nai-cha.html","text":"头一次觉得奶茶原来是这样的味道。 2015-09-10 00:43:21","tags":[{"name":"奶茶","slug":"奶茶","permalink":"https://lirawx.me/tags/奶茶/"}]},{"title":"镇江-西津渡","date":"2015-09-10T00:00:00.000Z","path":"2015/2015-09-10-xi-jin-du.html","text":"暑假看到记录频道的西津渡感觉挺好的，就去走了走，虽然看的时间挺短，但是，它那种古色古香的建筑还是引人入胜的。长长的古街，碎碎的石板路，三三两两的有人，食香四溢，古老与现代融合在一起。一路走下来，时间不多，但是看到的都是时间的聚合体—古建筑群。从正面一条长长的石阶进去，两边是客栈酒馆。小小的巷子飘出酒香（其实啥也没闻到，哈哈）。不一会就到了一个三岔路口。往上是上山的路，蜿蜒而上是一个歇脚的亭子，再往上就是上山，山不高，但是没有上去，上面是一个超岸寺,听说唐代大诗人李白、孟浩然，宋代王安石、陆游都来过呢。往左是一条叫观音洞一条街，上面有一个很有名的韶关石塔，按照佛教的解释，塔就是佛，所以我们从塔下的券门经过就是礼佛，是对佛的顶礼膜拜。。石塔矗立在街上，游人从下面穿过，仿佛是穿越了一个世纪，如此之久。仿佛看到了古人，素衣而过，的情景。再往前是五十三坡，我们每上一级台阶，仿佛就是参拜了一位圣贤，走完了53级台阶，也就意味着完成了对53位高人的求教。像善财童子一样，陶冶了情操，净化了思想。别以为我信，但是我走完了，走完了（呵呵）。往右是一条很多地方都有的小吃街，跟扬州的关东街差不多，但是要短上许多，街上很多小吃，面食，甜点，奶茶，还有几家台北小吃，很诱人的样子，但是没有买，其实是吃完早饭没有吃的欲望，不然早就开始搜刮了。里面有一家工艺品店，还不知是礼品店，里面有帽子，盆栽，还有韩国代购好像。我给我同学搞了个小小花农，养在罐头里的小花，我觉得挺好看的。旁边好像还有些主题餐厅，还有乐队貌似，旁边是博物馆，不过没有进去，那一带都在整修，不知道什么时候能修好，这样就可以看了。","tags":[{"name":"镇江-西津渡","slug":"镇江-西津渡","permalink":"https://lirawx.me/tags/镇江-西津渡/"}]},{"title":"雨夜（1）","date":"2015-09-10T00:00:00.000Z","path":"2015/2015-09-10-rainy-night.html","text":"寂静雨夜，怎奈心寒，空有相思，与何人说？ 2015-08-24 00:42:22","tags":[{"name":"雨夜","slug":"雨夜","permalink":"https://lirawx.me/tags/雨夜/"}]},{"title":"草在结它的种子，风在摇它的叶子。。。","date":"2015-09-09T00:00:00.000Z","path":"2015/2015-09-09-cao-zai-jie-ta-de-zhong-zi.html","text":"顾城 –《门前》 我多么希望，有一个门口 早晨，阳光照在草上 我们站着 扶着自己的门扇 门很低，但太阳是明亮的 草在结它的种子 风在摇它的叶子 我们站着，不说话 就十分美好 有门，不用开开 是我们的，就十分美好 早晨，黑夜还要流浪 我们把六弦琴交给他 我们不走了 我们需要土地 需要永不毁灭的土地 我们要乘着它 度过一生 土地是粗糙的，有时狭隘 然而，它有历史 有一份天空，一份月亮 一份露水和早晨 我们爱土地 我们站着 用木鞋挖着泥土 门也晒热了 我们轻轻靠着，十分美好 墙后的草 不会再长大了 它只用指尖，触了触阳光","tags":[{"name":"读书摘录","slug":"读书摘录","permalink":"https://lirawx.me/tags/读书摘录/"}]},{"title":"反思（1）","date":"2015-09-08T00:00:00.000Z","path":"2015/2015-09-08-think1.html","text":"突然觉得有必要找一个地方写写，想想，说说，无关他人，只是自己，不悲伤，不欢喜，只是静静的谈谈自己。以前说过总有一个时候一个人会回过头来看看身后，身后的脚印也好，石头磕绊也好，必须有一个时辰拿来检讨自己。或许他人不知道，但是自己，自己的良善会知道。必须要承认自己的过错，比如很容易激动，听不下去别人的言语，尤其是自己不喜欢，不感兴趣，不符合自己的价值观，针对自己的等等。还比如自己现在的随意，满不在乎的样子，其实我也不知道自己以后会在意什么，但是，我觉得这个状态持续下去不太好。听别人的故事，会流着自己的泪，那么这个泪是否有一部分是为自己而流的呢。很多时候告诉自己不后悔，其实经常会回想自己与她人的点点滴滴。医生中总有那么一个人，会给你不一样的体验，终生难忘。尽管不是时时刻刻，但是几乎每天空下来的时候总会无端想起，不知道这是否是后悔的一种表现呢，可是依然要表现出不在乎的样子。放下就会好过许多，真的是这样的放下么？真的就这样么？","tags":[{"name":"想想","slug":"想想","permalink":"https://lirawx.me/tags/想想/"}]},{"title":"css+js实现加载动画","date":"2015-08-29T00:00:00.000Z","path":"2015/2015-08-29-js-animation.html","text":"想要酷炫的加载动画么，那就一起来看看吧。 首先你要找到css和js的代码 css是动画，js控制动画显示和隐藏 一下是我收集的一段css自改代码html &lt;div class=&quot;loaders&quot; id=&quot;loading&quot;&gt; &lt;div class=&quot;loader&quot;&gt; &lt;div class=&quot;loader-inner ball-clip-rotate-multiple&quot;&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; css@keyframes rotate &#123; 0% &#123; -webkit-transform: rotate(0deg) scale(1); transform: rotate(0deg) scale(1) &#125; 50% &#123; -webkit-transform: rotate(180deg) scale(0.6); transform: rotate(180deg) scale(0.6) &#125; 100% &#123; -webkit-transform: rotate(360deg) scale(1); transform: rotate(360deg) scale(1) &#125;&#125;.ball-clip-rotate-multiple &#123; position: absolute; left: 50%; top: 50%;&#125;.ball-clip-rotate-multiple&gt;div &#123; position: absolute; left: 0; top: 0; border: 2px solid #8b8b8b; border-bottom-color: transparent; border-top-color: transparent; border-radius: 100%; height: 35px; width: 35px; -webkit-animation: rotate 1s 0s ease-in-out infinite; animation: rotate 1s 0s ease-in-out infinite&#125;.ball-clip-rotate-multiple&gt;div:last-child &#123; display: inline-block; top: 10px; left: 10px; width: 15px; height: 15px; -webkit-animation-duration: .5s; animation-duration: .5s; border-color: #8b8b8b transparent; -webkit-animation-direction: reverse; animation-direction: reverse&#125; js代码,控制自动隐藏$(window).load(function() &#123; $(&quot;#loading&quot;).fadeOut(500); &#125;) &lt;/script&gt; 特别提示以上代码需要加载jquery.js 百度链接密码： kn1f 以上修改自 http://www.htmleaf.com/css3/css3donghua/201504151682.html","tags":[{"name":"js","slug":"js","permalink":"https://lirawx.me/tags/js/"}]},{"title":"网站添加词霸每日一句","date":"2015-08-29T00:00:00.000Z","path":"2015/2015-08-29-jscb.html","text":"最近给自己网站弄了个每日一句，记录一下经验。主要是词霸开放了api，封装成js了。网址是http://open.iciba.com/index.php?c=api 根据网站提示生成js代码放入js里就可以了。 但是它默认放在网站顶部， 如果你不想放在网站顶部可以借鉴下我的css代码，我放在了底部。 .ciba_ds是词霸自动生成后写入网页的标记， !important是强制使用你设定的css .ciba_ds &#123; left: 70px !important; text-align: center!important; width: 100%; height: 30px; line-height: 30px; position: fixed !important; _position: absolute !important; bottom: 50px !important; _bottom: 0px !important; _margin-top: expression(this.style.pixelHeight+document.documentElement.scrollTop) !important;&#125;","tags":[{"name":"每日一句","slug":"每日一句","permalink":"https://lirawx.me/tags/每日一句/"}]},{"title":"python之pyenv版本控制","date":"2015-08-24T00:00:00.000Z","path":"2015/2015-08-24-python-pyenv.html","text":"当需要多个python共存时，pyenv提供了解决知道 #####安装pyenv git clone git://github.com/yyuu/pyenv.git ~/.pyenvecho &apos;export PYENV_ROOT=&quot;$HOME/.pyenv&quot;&apos; &gt;&gt; ~/.bashrcecho &apos;export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;&apos; &gt;&gt; ~/.bashrcecho &apos;eval &quot;$(pyenv init -)&quot;&apos; &gt;&gt; ~/.bashrcexec $SHELL -l #####用pyenv安装python 查看可安装的版本 pyenv install --list #####安装指定版本(3.4.0为例) pyenv install 3.4.0 -v #####安装之后要对数据库进行更新 pyenv rehash #####设置全局python版本 pyenv global 3.4.0","tags":[{"name":"python","slug":"python","permalink":"https://lirawx.me/tags/python/"}]},{"title":"甲午观后感","date":"2015-08-24T00:00:00.000Z","path":"2015/2015-08-24-jia-wu.html","text":"一直以来都觉得日本是个挺神奇的过度，无关政治，只是单纯的觉得它的一些传统，还有文化方面，确实比中国要好，当然我觉得日语听起来很舒服至少，（不是那个雅灭蝶），语气，语气，语气！（重要的事说三遍）.最近cctv9再放甲午纪录片，cctv9一直都是良心台，至少我看来是的，广告至少都很好看，也很有创业，唯一不满的是老会穿插抗日神剧。当然扯远了，只是想谈一谈我觉得《甲午》做的很有特色，开场音效就很让人警醒，一个国家不是说不能犯错，而是犯了错要改，小孩子都懂的道理。中国也不是一直没有错，我觉得至少很多错都没有改，一个国家强盛总要有人民的支持，总觉得中国想帝国主义，真的是一党专政，实际上却像一党专制。从来就对党中央没什么特别的好映像。当然不是反动，是态度和立场。当所有的知识分子，不是官二代，也不是富二代，那么一个国家能给予他们什么呢，中国人现在都太功利了，很多时候人民觉得不公，外人有仇视，国人只是很少说，想做都不能有那样的机会。我只是希望自己生活的国家能公平公正一点，起码国家重要信息公开，自己犯错也得承认，不然怎么承受的起德国总理的那一跪，看看人家这就是认错的孩纸一样。永远不能强加给自己很厉害，社会风气我觉得我不是底层，但是我觉得非常不好，学校教育问题很大！很大！很大！我都不知道大学上了跟没上区别在哪里。好了，言尽于此。","tags":[{"name":"甲午","slug":"甲午","permalink":"https://lirawx.me/tags/甲午/"}]},{"title":"情人节有感","date":"2015-08-20T00:00:00.000Z","path":"2015/2015-08-20-20150820.html","text":"是催花残，偏执多情，几伤别离，怎又一年？ #####2015-08-20 20:18:21","tags":[{"name":"情人节","slug":"情人节","permalink":"https://lirawx.me/tags/情人节/"}]},{"title":"linux终端中文显示","date":"2015-08-19T00:00:00.000Z","path":"2015/2015-08-19-linux-zh.html","text":"相信玩linux的都有一颗geek的心，什么都想在tty下解决，比如听歌，看网页，甚至还想看视频来着。拿听歌来说，有网易云音乐的命令行，douban.fm，你幸幸苦苦装好了，但是你打开就傻眼了，全是框框框（重要的事情说三遍），然后你百度了，你google了，然后他们告诉处女座的你，图形界面啥不行，然后你伤心了，失望了，绝望了。。。。（扯远了），开始正文： ###首先安装fbtermsudo apt-get install fbterm ###然后把你的用户加入video用户组sudo gpasswd -a xi video 原因是这普通用户(xi)不能启动fbterm，现在基本上就可以显示了，还可以输入中文，但我觉得太鸡肋。","tags":[{"name":"tty","slug":"tty","permalink":"https://lirawx.me/tags/tty/"}]},{"title":"dns记录（自用）","date":"2015-08-19T00:00:00.000Z","path":"2015/2015-08-19-dns.html","text":"相信很多人都遇到过这种，你点一个网页，别人秒开，你却还在加载，你点了淘宝，竟然跳到京东有木有，你还得忍受各种运营商疯狂的投放的广告。所以我决定起义了，革命了： 推荐两个dns one dns112.124.47.27114.215.126.16 v2ex dns178.79.131.110199.91.73.222","tags":[{"name":"dns","slug":"dns","permalink":"https://lirawx.me/tags/dns/"}]},{"title":"mac下ssd trim 开启","date":"2015-08-15T00:00:00.000Z","path":"2015/2015-08-15-mac-ssd-trim.html","text":"很多人自己加ssd给苹果鸡，然后没有开trim，又或者穷屌pc上ssd装了mac开启trim，不知道该怎么办了。大家都知道trim开了对ssd好处，所以就不废话了直接上命令… #####打开终端一次输入以下三句命令： sudo cp /System/Library/Extensions/IOAHCIFamily.kext/Contents/PlugIns/IOAHCIBlockStorage.kext/Contents/MacOS/IOAHCIBlockStorage /System/Library/Extensions/IOAHCIFamily.kext/Contents/PlugIns/IOAHCIBlockStorage.kext/Contents/MacOS/IOAHCIBlockStorage.original sudo perl -p0777i -e &apos;s@((?:Rotational|WakeKey\\x0a)\\x00&#123;1,20&#125;)APPLE SSD(\\x00&#123;1,20&#125;[QMT])@$1\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00$2@&apos; /System/Library/Extensions/IOAHCIFamily.kext/Contents/PlugIns/IOAHCIBlockStorage.kext/Contents/MacOS/IOAHCIBlockStorage sudo touch /System/Library/Extensions/ 以上适用于10.9","tags":[{"name":"efi","slug":"efi","permalink":"https://lirawx.me/tags/efi/"}]},{"title":"linux 无线网络启用","date":"2015-03-07T00:00:00.000Z","path":"2015/2015-03-07-linux-wifion.html","text":"####方法一sudo rmmod acer-wmi #####这样就可以打开无线了！无线信号也会出来 ，但是有一个问题就是，只要机器一重启，那个文件又被修改回来了！ ####方法二（完美）blacklist acer-wmi这个命令加入到/etc/modprobe.d/blacklist.conf文件最后即可。","tags":[{"name":"wifi","slug":"wifi","permalink":"https://lirawx.me/tags/wifi/"}]},{"title":"linux ssh 设置","date":"2015-03-07T00:00:00.000Z","path":"2015/2015-03-07-linux-ssh.html","text":"使用putty的ssh代理功能ubuntu下执行sudo apt-get install putty很简单就可以安装完成了，安装完成后只需要执行plink -C -D 127.0.0.1:7070 -N -pw 密码 用户名@xxx.xxx.xxx -P 1234","tags":[{"name":"ssh","slug":"ssh","permalink":"https://lirawx.me/tags/ssh/"}]},{"title":"mac下efi分区挂载","date":"2014-03-07T00:00:00.000Z","path":"2014/2014-03-07-mac-efi.html","text":"###第一步打开终端输入: diskutil list 效果如上图所示 ##第二步打开终端输入: mkdir /Volumes/efi ##第三步打开终端输入 sudo mount -t msdos /dev/disk0s1 /Volumes/efi 其中/dev/disk0s1 为上图中的efi分区","tags":[{"name":"efi","slug":"efi","permalink":"https://lirawx.me/tags/efi/"}]},{"title":"git 安装与使用","date":"2014-03-07T00:00:00.000Z","path":"2014/2014-03-07-git-install.html","text":"###一、git基本环境配置 1.首先去www.github.com上注册帐号 2.本机安装git. sudo apt-get install git 3.给本机注册SSH，请移步https://help.github.com/articles/generating-ssh-keys，注册SSH后就默认可以在本机上传代码之类，不用在输入用户名密码… 4.配置Git的配置文件，username和email git config –global user.name “your name” //配置用户名 git config –global user.email “your email” //配置email配置这个每次commit都会通过email去关联github账户 ###二、git基本命令 1.git clone 命令将远程的Git版本库在本地克隆一份，然后就可以用git对该目录下的文件进行版本控制。并且此时会默认生成一个文件夹，文件夹名字是远程仓库名字，cd进去之后，git remote -v发现存在远程仓库，其地址是clone的地址，名字是orgin。比如 (git clone git://github.com/1292765944/ACM.git) 或者 (git clone git@github.com:1292765944/ACM.git)但不要用https协议 2.git init 你可以在本地创建了一个工作目录，然后进入这个目录，使用’git init’命令进行初始化，那么git以后就会对该目录下的文件进行版本控制。 这个命令应用比较简单，先cd到目标文件夹，然后git init即可。 3.git remote 通过这个命令我们可以建立和远程仓库的联系。 比如 git remote add origin git@github.com:1292765944/ACM.git 我们就把git@github.com:1292765944/ACM.git这个远程仓库取了origin别名，以后我们再访问的时候可以直接使用别名。 git remote -v 查看远程仓库 git remote rm [name] 删除远程仓库 git pull [remoteName] [localBranchName]拉取远程仓库。比如git pull origin master git push [remoteName] [localBranchName]更新远程仓库，注意在更新之前要先pul。比如git push origin master 4.git add 该命令当前更改或者新增的文件加入到本地仓库中 git add 后面可以加文件名/目录，还有一中写法git add .会自动判断添加哪些文件然后把这个添加提交到本地的仓库 5.git rm 该命令删除本地仓库中的一些文件。git rm 后面可以直接接文件名，但要删除目录时，要加-r 6.git commit 提交你之前做的rm和add操作并必须要提交附加信息。比如 git commit -m “acm_template” ###三、使用git从本地上传github举例 第一步： 进入要所要上传文件的目录输入命令 “git init”第二步： 创建一个远程仓库origin，使用命令 “git remote add origin git@github.com:1292765944/ACM.git”，其中1292765944是你的GitHub的用户名，ACM是你要上传到GitHub的仓库第三步：比如你要添加一个文件xxx到本地仓库，使用命令 “git add xxx”，可以使用“git add .”自动判断添加哪些文件，然后把这个添加提交到本地的仓库，使用命令 ”git commit -m ”说明这次的提交“，最后把本地仓库origin提交到远程的GitHub仓库，使用命令 ”git push origin master“","tags":[{"name":"git","slug":"git","permalink":"https://lirawx.me/tags/git/"}]}]